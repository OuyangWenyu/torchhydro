
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://OuyangWenyu.github.io/torchhydro/api/datasets/">
      
      
        <link rel="prev" href="../models/">
      
      
        <link rel="next" href="../trainers/">
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.17">
    
    
      
        <title>Datasets - torchhydro</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.7e37652d.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../assets/_mkdocstrings.css">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="preference" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#datasets-api" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="torchhydro" class="md-header__button md-logo" aria-label="torchhydro" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            torchhydro
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Datasets
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
      <div class="md-header__source">
        <a href="https://github.com/OuyangWenyu/torchhydro" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 7.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path fill="currentColor" d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M252.8 8C114.1 8 8 113.3 8 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C436.2 457.8 504 362.9 504 252 504 113.3 391.5 8 252.8 8M105.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="torchhydro" class="md-nav__button md-logo" aria-label="torchhydro" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    torchhydro
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/OuyangWenyu/torchhydro" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 7.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path fill="currentColor" d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M252.8 8C114.1 8 8 113.3 8 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C436.2 457.8 504 362.9 504 252 504 113.3 391.5 8 252.8 8M105.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Home
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../installation/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Installation
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../usage/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Usage
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../contributing/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Contributing
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../faq/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    FAQ
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../changelog/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Changelog
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="https://github.com/OuyangWenyu/torchhydro/issues" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Report Issues
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8" checked>
        
          
          <label class="md-nav__link" for="__nav_8" id="__nav_8_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    API Reference
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_8_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_8">
            <span class="md-nav__icon md-icon"></span>
            API Reference
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../torchhydro/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Overview
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../models/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Models
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    Datasets
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    Datasets
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#torchhydro.datasets" class="md-nav__link">
    <span class="md-ellipsis">
      torchhydro.datasets
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_dict" class="md-nav__link">
    <span class="md-ellipsis">
      data_dict
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers" class="md-nav__link">
    <span class="md-ellipsis">
      data_scalers
    </span>
  </a>
  
    <nav class="md-nav" aria-label="data_scalers">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers.DapengScaler" class="md-nav__link">
    <span class="md-ellipsis">
      DapengScaler
    </span>
  </a>
  
    <nav class="md-nav" aria-label="DapengScaler">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers.DapengScaler.mean_prcp" class="md-nav__link">
    <span class="md-ellipsis">
      mean_prcp
    </span>
  </a>
  
    <nav class="md-nav" aria-label="mean_prcp">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers.DapengScaler.mean_prcp--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers.DapengScaler.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="__init__()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers.DapengScaler.__init__--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers.DapengScaler.cal_stat_all" class="md-nav__link">
    <span class="md-ellipsis">
      cal_stat_all()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="cal_stat_all()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers.DapengScaler.cal_stat_all--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers.DapengScaler.get_data_norm" class="md-nav__link">
    <span class="md-ellipsis">
      get_data_norm()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="get_data_norm()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers.DapengScaler.get_data_norm--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers.DapengScaler.get_data_norm--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers.DapengScaler.inverse_transform" class="md-nav__link">
    <span class="md-ellipsis">
      inverse_transform()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="inverse_transform()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers.DapengScaler.inverse_transform--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers.DapengScaler.inverse_transform--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers.DapengScaler.load_norm_data" class="md-nav__link">
    <span class="md-ellipsis">
      load_norm_data()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="load_norm_data()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers.DapengScaler.load_norm_data--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers.ScalerHub" class="md-nav__link">
    <span class="md-ellipsis">
      ScalerHub
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ScalerHub">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers.ScalerHub.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="__init__()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers.ScalerHub.__init__--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers.SklearnScaler" class="md-nav__link">
    <span class="md-ellipsis">
      SklearnScaler
    </span>
  </a>
  
    <nav class="md-nav" aria-label="SklearnScaler">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers.SklearnScaler.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="__init__()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers.SklearnScaler.__init__--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers.SklearnScaler.inverse_transform" class="md-nav__link">
    <span class="md-ellipsis">
      inverse_transform()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="inverse_transform()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers.SklearnScaler.inverse_transform--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers.SklearnScaler.inverse_transform--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets" class="md-nav__link">
    <span class="md-ellipsis">
      data_sets
    </span>
  </a>
  
    <nav class="md-nav" aria-label="data_sets">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.AugmentedFloodEventDataset" class="md-nav__link">
    <span class="md-ellipsis">
      AugmentedFloodEventDataset
    </span>
  </a>
  
    <nav class="md-nav" aria-label="AugmentedFloodEventDataset">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.AugmentedFloodEventDataset.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="__init__()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.AugmentedFloodEventDataset.__init__--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.BaseDataset" class="md-nav__link">
    <span class="md-ellipsis">
      BaseDataset
    </span>
  </a>
  
    <nav class="md-nav" aria-label="BaseDataset">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.BaseDataset.basins" class="md-nav__link">
    <span class="md-ellipsis">
      basins
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.BaseDataset.ngrid" class="md-nav__link">
    <span class="md-ellipsis">
      ngrid
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngrid">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.BaseDataset.ngrid--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.BaseDataset.noutputvar" class="md-nav__link">
    <span class="md-ellipsis">
      noutputvar
    </span>
  </a>
  
    <nav class="md-nav" aria-label="noutputvar">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.BaseDataset.noutputvar--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.BaseDataset.nt" class="md-nav__link">
    <span class="md-ellipsis">
      nt
    </span>
  </a>
  
    <nav class="md-nav" aria-label="nt">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.BaseDataset.nt--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.BaseDataset.times" class="md-nav__link">
    <span class="md-ellipsis">
      times
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.BaseDataset.__getitem__" class="md-nav__link">
    <span class="md-ellipsis">
      __getitem__()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.BaseDataset.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="__init__()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.BaseDataset.__init__--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.BaseDataset.denormalize" class="md-nav__link">
    <span class="md-ellipsis">
      denormalize()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="denormalize()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.BaseDataset.denormalize--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.BaseDataset.denormalize--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.BasinSingleFlowDataset" class="md-nav__link">
    <span class="md-ellipsis">
      BasinSingleFlowDataset
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.DplDataset" class="md-nav__link">
    <span class="md-ellipsis">
      DplDataset
    </span>
  </a>
  
    <nav class="md-nav" aria-label="DplDataset">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.DplDataset.__getitem__" class="md-nav__link">
    <span class="md-ellipsis">
      __getitem__()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="__getitem__()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.DplDataset.__getitem__--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.DplDataset.__getitem__--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.DplDataset.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="__init__()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.DplDataset.__init__--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.FlexibleDataset" class="md-nav__link">
    <span class="md-ellipsis">
      FlexibleDataset
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.FloodEventDataset" class="md-nav__link">
    <span class="md-ellipsis">
      FloodEventDataset
    </span>
  </a>
  
    <nav class="md-nav" aria-label="FloodEventDataset">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.FloodEventDataset.noutputvar" class="md-nav__link">
    <span class="md-ellipsis">
      noutputvar
    </span>
  </a>
  
    <nav class="md-nav" aria-label="noutputvar">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.FloodEventDataset.noutputvar--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.FloodEventDataset.__getitem__" class="md-nav__link">
    <span class="md-ellipsis">
      __getitem__()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.FloodEventDataset.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="__init__()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.FloodEventDataset.__init__--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.FloodEventDplDataset" class="md-nav__link">
    <span class="md-ellipsis">
      FloodEventDplDataset
    </span>
  </a>
  
    <nav class="md-nav" aria-label="FloodEventDplDataset">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.FloodEventDplDataset.__getitem__" class="md-nav__link">
    <span class="md-ellipsis">
      __getitem__()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="__getitem__()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.FloodEventDplDataset.__getitem__--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.FloodEventDplDataset.__getitem__--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.FloodEventDplDataset.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="__init__()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.FloodEventDplDataset.__init__--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.GNNDataset" class="md-nav__link">
    <span class="md-ellipsis">
      GNNDataset
    </span>
  </a>
  
    <nav class="md-nav" aria-label="GNNDataset">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.GNNDataset.__getitem__" class="md-nav__link">
    <span class="md-ellipsis">
      __getitem__()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.GNNDataset.get_adjacency_data" class="md-nav__link">
    <span class="md-ellipsis">
      get_adjacency_data()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="get_adjacency_data()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.GNNDataset.get_adjacency_data--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.GNNDataset.get_edge_weight" class="md-nav__link">
    <span class="md-ellipsis">
      get_edge_weight()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="get_edge_weight()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.GNNDataset.get_edge_weight--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.GNNDataset.get_edge_weight--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.GNNDataset.get_station_data" class="md-nav__link">
    <span class="md-ellipsis">
      get_station_data()
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.ObsForeDataset" class="md-nav__link">
    <span class="md-ellipsis">
      ObsForeDataset
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ObsForeDataset">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.ObsForeDataset.__getitem__" class="md-nav__link">
    <span class="md-ellipsis">
      __getitem__()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="__getitem__()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.ObsForeDataset.__getitem__--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.ObsForeDataset.__getitem__--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.ObsForeDataset.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="__init__()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.ObsForeDataset.__init__--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.detect_date_format" class="md-nav__link">
    <span class="md-ellipsis">
      detect_date_format()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="detect_date_format()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.detect_date_format--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.detect_date_format--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sources" class="md-nav__link">
    <span class="md-ellipsis">
      data_sources
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_utils" class="md-nav__link">
    <span class="md-ellipsis">
      data_utils
    </span>
  </a>
  
    <nav class="md-nav" aria-label="data_utils">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_utils.choose_basins_with_area" class="md-nav__link">
    <span class="md-ellipsis">
      choose_basins_with_area()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="choose_basins_with_area()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_utils.choose_basins_with_area--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_utils.choose_basins_with_area--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_utils.choose_sites_in_ecoregion" class="md-nav__link">
    <span class="md-ellipsis">
      choose_sites_in_ecoregion()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="choose_sites_in_ecoregion()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_utils.choose_sites_in_ecoregion--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_utils.choose_sites_in_ecoregion--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_utils.choose_sites_in_ecoregion--raises" class="md-nav__link">
    <span class="md-ellipsis">
      Raises
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_utils.dam_num_chosen" class="md-nav__link">
    <span class="md-ellipsis">
      dam_num_chosen()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_utils.dor_reservoirs_chosen" class="md-nav__link">
    <span class="md-ellipsis">
      dor_reservoirs_chosen()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_utils.set_unit_to_var" class="md-nav__link">
    <span class="md-ellipsis">
      set_unit_to_var()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="set_unit_to_var()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_utils.set_unit_to_var--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_utils.set_unit_to_var--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_utils.unify_streamflow_unit" class="md-nav__link">
    <span class="md-ellipsis">
      unify_streamflow_unit()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="unify_streamflow_unit()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_utils.unify_streamflow_unit--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_utils.unify_streamflow_unit--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_utils.warn_if_nan" class="md-nav__link">
    <span class="md-ellipsis">
      warn_if_nan()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="warn_if_nan()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_utils.warn_if_nan--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_utils.wrap_t_s_dict" class="md-nav__link">
    <span class="md-ellipsis">
      wrap_t_s_dict()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="wrap_t_s_dict()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_utils.wrap_t_s_dict--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_utils.wrap_t_s_dict--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#torchhydro.datasets.sampler" class="md-nav__link">
    <span class="md-ellipsis">
      sampler
    </span>
  </a>
  
    <nav class="md-nav" aria-label="sampler">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.sampler.BasinBatchSampler" class="md-nav__link">
    <span class="md-ellipsis">
      BasinBatchSampler
    </span>
  </a>
  
    <nav class="md-nav" aria-label="BasinBatchSampler">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.sampler.BasinBatchSampler--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.sampler.KuaiSampler" class="md-nav__link">
    <span class="md-ellipsis">
      KuaiSampler
    </span>
  </a>
  
    <nav class="md-nav" aria-label="KuaiSampler">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.sampler.KuaiSampler.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="__init__()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.sampler.KuaiSampler.__init__--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.sampler.fl_sample_basin" class="md-nav__link">
    <span class="md-ellipsis">
      fl_sample_basin()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="fl_sample_basin()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.sampler.fl_sample_basin--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.sampler.fl_sample_basin--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.sampler.fl_sample_region" class="md-nav__link">
    <span class="md-ellipsis">
      fl_sample_region()
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../trainers/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Trainers
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../configs/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Configs
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../explainers/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Explainers
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#torchhydro.datasets" class="md-nav__link">
    <span class="md-ellipsis">
      torchhydro.datasets
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_dict" class="md-nav__link">
    <span class="md-ellipsis">
      data_dict
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers" class="md-nav__link">
    <span class="md-ellipsis">
      data_scalers
    </span>
  </a>
  
    <nav class="md-nav" aria-label="data_scalers">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers.DapengScaler" class="md-nav__link">
    <span class="md-ellipsis">
      DapengScaler
    </span>
  </a>
  
    <nav class="md-nav" aria-label="DapengScaler">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers.DapengScaler.mean_prcp" class="md-nav__link">
    <span class="md-ellipsis">
      mean_prcp
    </span>
  </a>
  
    <nav class="md-nav" aria-label="mean_prcp">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers.DapengScaler.mean_prcp--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers.DapengScaler.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="__init__()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers.DapengScaler.__init__--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers.DapengScaler.cal_stat_all" class="md-nav__link">
    <span class="md-ellipsis">
      cal_stat_all()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="cal_stat_all()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers.DapengScaler.cal_stat_all--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers.DapengScaler.get_data_norm" class="md-nav__link">
    <span class="md-ellipsis">
      get_data_norm()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="get_data_norm()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers.DapengScaler.get_data_norm--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers.DapengScaler.get_data_norm--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers.DapengScaler.inverse_transform" class="md-nav__link">
    <span class="md-ellipsis">
      inverse_transform()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="inverse_transform()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers.DapengScaler.inverse_transform--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers.DapengScaler.inverse_transform--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers.DapengScaler.load_norm_data" class="md-nav__link">
    <span class="md-ellipsis">
      load_norm_data()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="load_norm_data()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers.DapengScaler.load_norm_data--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers.ScalerHub" class="md-nav__link">
    <span class="md-ellipsis">
      ScalerHub
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ScalerHub">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers.ScalerHub.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="__init__()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers.ScalerHub.__init__--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers.SklearnScaler" class="md-nav__link">
    <span class="md-ellipsis">
      SklearnScaler
    </span>
  </a>
  
    <nav class="md-nav" aria-label="SklearnScaler">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers.SklearnScaler.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="__init__()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers.SklearnScaler.__init__--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers.SklearnScaler.inverse_transform" class="md-nav__link">
    <span class="md-ellipsis">
      inverse_transform()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="inverse_transform()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers.SklearnScaler.inverse_transform--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_scalers.SklearnScaler.inverse_transform--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets" class="md-nav__link">
    <span class="md-ellipsis">
      data_sets
    </span>
  </a>
  
    <nav class="md-nav" aria-label="data_sets">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.AugmentedFloodEventDataset" class="md-nav__link">
    <span class="md-ellipsis">
      AugmentedFloodEventDataset
    </span>
  </a>
  
    <nav class="md-nav" aria-label="AugmentedFloodEventDataset">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.AugmentedFloodEventDataset.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="__init__()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.AugmentedFloodEventDataset.__init__--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.BaseDataset" class="md-nav__link">
    <span class="md-ellipsis">
      BaseDataset
    </span>
  </a>
  
    <nav class="md-nav" aria-label="BaseDataset">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.BaseDataset.basins" class="md-nav__link">
    <span class="md-ellipsis">
      basins
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.BaseDataset.ngrid" class="md-nav__link">
    <span class="md-ellipsis">
      ngrid
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ngrid">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.BaseDataset.ngrid--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.BaseDataset.noutputvar" class="md-nav__link">
    <span class="md-ellipsis">
      noutputvar
    </span>
  </a>
  
    <nav class="md-nav" aria-label="noutputvar">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.BaseDataset.noutputvar--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.BaseDataset.nt" class="md-nav__link">
    <span class="md-ellipsis">
      nt
    </span>
  </a>
  
    <nav class="md-nav" aria-label="nt">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.BaseDataset.nt--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.BaseDataset.times" class="md-nav__link">
    <span class="md-ellipsis">
      times
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.BaseDataset.__getitem__" class="md-nav__link">
    <span class="md-ellipsis">
      __getitem__()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.BaseDataset.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="__init__()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.BaseDataset.__init__--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.BaseDataset.denormalize" class="md-nav__link">
    <span class="md-ellipsis">
      denormalize()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="denormalize()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.BaseDataset.denormalize--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.BaseDataset.denormalize--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.BasinSingleFlowDataset" class="md-nav__link">
    <span class="md-ellipsis">
      BasinSingleFlowDataset
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.DplDataset" class="md-nav__link">
    <span class="md-ellipsis">
      DplDataset
    </span>
  </a>
  
    <nav class="md-nav" aria-label="DplDataset">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.DplDataset.__getitem__" class="md-nav__link">
    <span class="md-ellipsis">
      __getitem__()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="__getitem__()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.DplDataset.__getitem__--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.DplDataset.__getitem__--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.DplDataset.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="__init__()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.DplDataset.__init__--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.FlexibleDataset" class="md-nav__link">
    <span class="md-ellipsis">
      FlexibleDataset
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.FloodEventDataset" class="md-nav__link">
    <span class="md-ellipsis">
      FloodEventDataset
    </span>
  </a>
  
    <nav class="md-nav" aria-label="FloodEventDataset">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.FloodEventDataset.noutputvar" class="md-nav__link">
    <span class="md-ellipsis">
      noutputvar
    </span>
  </a>
  
    <nav class="md-nav" aria-label="noutputvar">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.FloodEventDataset.noutputvar--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.FloodEventDataset.__getitem__" class="md-nav__link">
    <span class="md-ellipsis">
      __getitem__()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.FloodEventDataset.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="__init__()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.FloodEventDataset.__init__--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.FloodEventDplDataset" class="md-nav__link">
    <span class="md-ellipsis">
      FloodEventDplDataset
    </span>
  </a>
  
    <nav class="md-nav" aria-label="FloodEventDplDataset">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.FloodEventDplDataset.__getitem__" class="md-nav__link">
    <span class="md-ellipsis">
      __getitem__()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="__getitem__()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.FloodEventDplDataset.__getitem__--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.FloodEventDplDataset.__getitem__--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.FloodEventDplDataset.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="__init__()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.FloodEventDplDataset.__init__--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.GNNDataset" class="md-nav__link">
    <span class="md-ellipsis">
      GNNDataset
    </span>
  </a>
  
    <nav class="md-nav" aria-label="GNNDataset">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.GNNDataset.__getitem__" class="md-nav__link">
    <span class="md-ellipsis">
      __getitem__()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.GNNDataset.get_adjacency_data" class="md-nav__link">
    <span class="md-ellipsis">
      get_adjacency_data()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="get_adjacency_data()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.GNNDataset.get_adjacency_data--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.GNNDataset.get_edge_weight" class="md-nav__link">
    <span class="md-ellipsis">
      get_edge_weight()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="get_edge_weight()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.GNNDataset.get_edge_weight--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.GNNDataset.get_edge_weight--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.GNNDataset.get_station_data" class="md-nav__link">
    <span class="md-ellipsis">
      get_station_data()
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.ObsForeDataset" class="md-nav__link">
    <span class="md-ellipsis">
      ObsForeDataset
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ObsForeDataset">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.ObsForeDataset.__getitem__" class="md-nav__link">
    <span class="md-ellipsis">
      __getitem__()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="__getitem__()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.ObsForeDataset.__getitem__--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.ObsForeDataset.__getitem__--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.ObsForeDataset.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="__init__()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.ObsForeDataset.__init__--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.detect_date_format" class="md-nav__link">
    <span class="md-ellipsis">
      detect_date_format()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="detect_date_format()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.detect_date_format--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sets.detect_date_format--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_sources" class="md-nav__link">
    <span class="md-ellipsis">
      data_sources
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_utils" class="md-nav__link">
    <span class="md-ellipsis">
      data_utils
    </span>
  </a>
  
    <nav class="md-nav" aria-label="data_utils">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_utils.choose_basins_with_area" class="md-nav__link">
    <span class="md-ellipsis">
      choose_basins_with_area()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="choose_basins_with_area()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_utils.choose_basins_with_area--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_utils.choose_basins_with_area--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_utils.choose_sites_in_ecoregion" class="md-nav__link">
    <span class="md-ellipsis">
      choose_sites_in_ecoregion()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="choose_sites_in_ecoregion()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_utils.choose_sites_in_ecoregion--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_utils.choose_sites_in_ecoregion--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_utils.choose_sites_in_ecoregion--raises" class="md-nav__link">
    <span class="md-ellipsis">
      Raises
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_utils.dam_num_chosen" class="md-nav__link">
    <span class="md-ellipsis">
      dam_num_chosen()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_utils.dor_reservoirs_chosen" class="md-nav__link">
    <span class="md-ellipsis">
      dor_reservoirs_chosen()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_utils.set_unit_to_var" class="md-nav__link">
    <span class="md-ellipsis">
      set_unit_to_var()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="set_unit_to_var()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_utils.set_unit_to_var--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_utils.set_unit_to_var--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_utils.unify_streamflow_unit" class="md-nav__link">
    <span class="md-ellipsis">
      unify_streamflow_unit()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="unify_streamflow_unit()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_utils.unify_streamflow_unit--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_utils.unify_streamflow_unit--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_utils.warn_if_nan" class="md-nav__link">
    <span class="md-ellipsis">
      warn_if_nan()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="warn_if_nan()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_utils.warn_if_nan--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_utils.wrap_t_s_dict" class="md-nav__link">
    <span class="md-ellipsis">
      wrap_t_s_dict()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="wrap_t_s_dict()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_utils.wrap_t_s_dict--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.data_utils.wrap_t_s_dict--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#torchhydro.datasets.sampler" class="md-nav__link">
    <span class="md-ellipsis">
      sampler
    </span>
  </a>
  
    <nav class="md-nav" aria-label="sampler">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.sampler.BasinBatchSampler" class="md-nav__link">
    <span class="md-ellipsis">
      BasinBatchSampler
    </span>
  </a>
  
    <nav class="md-nav" aria-label="BasinBatchSampler">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.sampler.BasinBatchSampler--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.sampler.KuaiSampler" class="md-nav__link">
    <span class="md-ellipsis">
      KuaiSampler
    </span>
  </a>
  
    <nav class="md-nav" aria-label="KuaiSampler">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.sampler.KuaiSampler.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="__init__()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.sampler.KuaiSampler.__init__--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.sampler.fl_sample_basin" class="md-nav__link">
    <span class="md-ellipsis">
      fl_sample_basin()
    </span>
  </a>
  
    <nav class="md-nav" aria-label="fl_sample_basin()">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.sampler.fl_sample_basin--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.sampler.fl_sample_basin--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#torchhydro.datasets.sampler.fl_sample_region" class="md-nav__link">
    <span class="md-ellipsis">
      fl_sample_region()
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                



                  


  
  


<h1 id="datasets-api">Datasets API<a class="headerlink" href="#datasets-api" title="Permanent link">&para;</a></h1>


  <div class="doc doc-object doc-module">

<a id="torchhydro.datasets"></a>
    <div class="doc doc-contents first">




  <div class="doc doc-children">










  <div class="doc doc-object doc-module">



<h2 id="torchhydro.datasets.data_dict" class="doc doc-heading">
        <code>data_dict</code>



<a href="#torchhydro.datasets.data_dict" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Author: Wenyu Ouyang
Date: 2021-12-31 11:08:29
LastEditTime: 2025-07-13 15:40:07
LastEditors: Wenyu Ouyang
Description: A dict used for data source and data loader
FilePath:       orchhydro       orchhydro\datasets\data_dict.py
Copyright (c) 2021-2022 Wenyu Ouyang. All rights reserved.</p>



  <div class="doc doc-children">












  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="torchhydro.datasets.data_scalers" class="doc doc-heading">
        <code>data_scalers</code>



<a href="#torchhydro.datasets.data_scalers" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Author: Wenyu Ouyang
Date: 2024-04-08 18:17:44
LastEditTime: 2025-10-29 08:53:29
LastEditors: Wenyu Ouyang
Description: normalize the data
FilePath:       orchhydro       orchhydro\datasets\data_scalers.py
Copyright (c) 2024-2024 Wenyu Ouyang. All rights reserved.</p>



  <div class="doc doc-children">








  <div class="doc doc-object doc-class">



<h3 id="torchhydro.datasets.data_scalers.DapengScaler" class="doc doc-heading">
        <code>
DapengScaler        </code>



<a href="#torchhydro.datasets.data_scalers.DapengScaler" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">


        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/data_scalers.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">DapengScaler</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">vars_data</span><span class="p">,</span>
        <span class="n">data_cfgs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
        <span class="n">is_tra_val_te</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">other_vars</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">prcp_norm_cols</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">gamma_norm_cols</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">pbm_norm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">data_source</span><span class="p">:</span> <span class="nb">object</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The normalization and denormalization methods from Dapeng&#39;s 1st WRR paper.</span>
<span class="sd">        Some use StandardScaler, and some use special norm methods</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vars_data: dict</span>
<span class="sd">            data for all variables used</span>
<span class="sd">        data_cfgs</span>
<span class="sd">            data parameter config in data source</span>
<span class="sd">        is_tra_val_te</span>
<span class="sd">            train/valid/test</span>
<span class="sd">        other_vars</span>
<span class="sd">            if more input are needed, list them in other_vars</span>
<span class="sd">        prcp_norm_cols</span>
<span class="sd">            data items which use _prcp_norm method to normalize</span>
<span class="sd">        gamma_norm_cols</span>
<span class="sd">            data items which use log(\sqrt(x)+.1) method to normalize</span>
<span class="sd">        pbm_norm</span>
<span class="sd">            if true, use pbm_norm method to normalize; the output of pbms is not normalized data, so its inverse is different.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">prcp_norm_cols</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">prcp_norm_cols</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s2">&quot;streamflow&quot;</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="k">if</span> <span class="n">gamma_norm_cols</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">gamma_norm_cols</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s2">&quot;gpm_tp&quot;</span><span class="p">,</span>
                <span class="s2">&quot;sta_tp&quot;</span><span class="p">,</span>
                <span class="s2">&quot;total_precipitation_hourly&quot;</span><span class="p">,</span>
                <span class="s2">&quot;temperature_2m&quot;</span><span class="p">,</span>
                <span class="s2">&quot;dewpoint_temperature_2m&quot;</span><span class="p">,</span>
                <span class="s2">&quot;surface_net_solar_radiation&quot;</span><span class="p">,</span>
                <span class="s2">&quot;sm_surface&quot;</span><span class="p">,</span>
                <span class="s2">&quot;sm_rootzone&quot;</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_target</span> <span class="o">=</span> <span class="n">vars_data</span><span class="p">[</span><span class="s2">&quot;target_cols&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span> <span class="o">=</span> <span class="n">data_cfgs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t_s_dict</span> <span class="o">=</span> <span class="n">wrap_t_s_dict</span><span class="p">(</span><span class="n">data_cfgs</span><span class="p">,</span> <span class="n">is_tra_val_te</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_other</span> <span class="o">=</span> <span class="n">other_vars</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prcp_norm_cols</span> <span class="o">=</span> <span class="n">prcp_norm_cols</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gamma_norm_cols</span> <span class="o">=</span> <span class="n">gamma_norm_cols</span>
        <span class="c1"># both prcp_norm_cols and gamma_norm_cols use log(\sqrt(x)+.1) method to normalize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_norm_cols</span> <span class="o">=</span> <span class="n">gamma_norm_cols</span> <span class="o">+</span> <span class="n">prcp_norm_cols</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pbm_norm</span> <span class="o">=</span> <span class="n">pbm_norm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_source</span> <span class="o">=</span> <span class="n">data_source</span>
        <span class="c1"># save stat_dict of training period in case_dir for valid/test</span>
        <span class="n">stat_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;case_dir&quot;</span><span class="p">],</span> <span class="s2">&quot;dapengscaler_stat.json&quot;</span><span class="p">)</span>
        <span class="c1"># for testing sometimes such as pub cases, we need stat_dict_file from trained dataset</span>
        <span class="k">if</span> <span class="n">is_tra_val_te</span> <span class="o">==</span> <span class="s2">&quot;train&quot;</span> <span class="ow">and</span> <span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;stat_dict_file&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stat_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cal_stat_all</span><span class="p">(</span><span class="n">vars_data</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">stat_file</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
                <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stat_dict</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># for valid/test, we need to load stat_dict from train</span>
            <span class="k">if</span> <span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;stat_dict_file&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># we used a assigned stat file, typically for PUB exps</span>
                <span class="c1"># shutil.copy(data_cfgs[&quot;stat_dict_file&quot;], stat_file)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">shutil</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;stat_dict_file&quot;</span><span class="p">],</span> <span class="n">stat_file</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">SameFileError</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;The source file and the target file are the same: </span><span class="si">{</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s1">&#39;stat_dict_file&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">, skipping the copy operation.&quot;</span>
                    <span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">stat_file</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">stat_file</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stat_dict</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">mean_prcp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This property is used to be divided by streamflow to normalize streamflow,</span>
<span class="sd">        hence, its unit is same as streamflow</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            mean_prcp with the same unit as streamflow</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the first target variable (usually flow variable) instead of hardcoding &quot;streamflow&quot;</span>
        <span class="n">flow_var_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;target_cols&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">final_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_target</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;units&quot;</span><span class="p">][</span><span class="n">flow_var_name</span><span class="p">]</span>
        <span class="n">mean_prcp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_source</span><span class="o">.</span><span class="n">read_mean_prcp</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">t_s_dict</span><span class="p">[</span><span class="s2">&quot;sites_id&quot;</span><span class="p">],</span> <span class="n">unit</span><span class="o">=</span><span class="n">final_unit</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">mean_prcp</span><span class="o">.</span><span class="n">to_array</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;basin&quot;</span><span class="p">,</span> <span class="s2">&quot;variable&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">inverse_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_values</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Denormalization for output variables</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        target_values</span>
<span class="sd">            output variables</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.array</span>
<span class="sd">            denormalized predictions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stat_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stat_dict</span>
        <span class="n">target_vars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;target_cols&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbm_norm</span><span class="p">:</span>
            <span class="c1"># for (differentiable models) pbm&#39;s output, its unit is mm/day, so we don&#39;t need to recover its unit</span>
            <span class="n">pred</span> <span class="o">=</span> <span class="n">target_values</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pred</span> <span class="o">=</span> <span class="n">_trans_norm</span><span class="p">(</span>
                <span class="n">target_values</span><span class="p">,</span>
                <span class="n">target_vars</span><span class="p">,</span>
                <span class="n">stat_dict</span><span class="p">,</span>
                <span class="n">log_norm_cols</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">log_norm_cols</span><span class="p">,</span>
                <span class="n">to_norm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;target_cols&quot;</span><span class="p">])):</span>
                <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;target_cols&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">prcp_norm_cols</span><span class="p">:</span>
                    <span class="n">pred</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="n">variable</span><span class="o">=</span><span class="n">var</span><span class="p">)]</span> <span class="o">=</span> <span class="n">_prcp_norm</span><span class="p">(</span>
                        <span class="n">pred</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">variable</span><span class="o">=</span><span class="n">var</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">mean_prcp</span><span class="p">,</span>
                        <span class="n">to_norm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pred</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="n">variable</span><span class="o">=</span><span class="n">var</span><span class="p">)]</span> <span class="o">=</span> <span class="n">pred</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">variable</span><span class="o">=</span><span class="n">var</span><span class="p">)</span>
        <span class="c1"># add attrs for units</span>
        <span class="n">pred</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_target</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pred</span><span class="o">.</span><span class="n">to_dataset</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;variable&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">cal_stat_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vars_data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate statistics of outputs(streamflow etc), and inputs(forcing and attributes)</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vars_data: dict</span>
<span class="sd">            data for all variables used</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            a dict with statistic values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stat_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vars_data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)):</span>
                <span class="n">var_name</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">prcp_norm_cols</span><span class="p">:</span>
                    <span class="n">stat_dict</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">cal_stat_prcp_norm</span><span class="p">(</span>
                        <span class="n">v</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">variable</span><span class="o">=</span><span class="n">var_name</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">mean_prcp</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma_norm_cols</span><span class="p">:</span>
                    <span class="n">stat_dict</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">cal_stat_gamma</span><span class="p">(</span>
                        <span class="n">v</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">variable</span><span class="o">=</span><span class="n">var_name</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">stat_dict</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">cal_stat</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">variable</span><span class="o">=</span><span class="n">var_name</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">stat_dict</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_data_norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">to_norm</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get normalized values</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data</span>
<span class="sd">            origin data</span>
<span class="sd">        to_norm</span>
<span class="sd">            if true, perform normalization</span>
<span class="sd">            if false, perform denormalization</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.array</span>
<span class="sd">            the output value for modeling</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stat_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stat_dict</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="c1"># if we don&#39;t set a copy() here, the attrs of data will be changed, which is not our wish</span>
        <span class="n">out</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span>
        <span class="n">_vars</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="k">if</span> <span class="s2">&quot;units&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
            <span class="ne">Warning</span><span class="p">(</span><span class="s2">&quot;The attrs of output data does not contain units&quot;</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;units&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">_vars</span><span class="p">)):</span>
            <span class="n">var</span> <span class="o">=</span> <span class="n">_vars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">prcp_norm_cols</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="n">variable</span><span class="o">=</span><span class="n">var</span><span class="p">)]</span> <span class="o">=</span> <span class="n">_prcp_norm</span><span class="p">(</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">variable</span><span class="o">=</span><span class="n">var</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mean_prcp</span><span class="p">,</span>
                    <span class="n">to_norm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="n">variable</span><span class="o">=</span><span class="n">var</span><span class="p">)]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">variable</span><span class="o">=</span><span class="n">var</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
            <span class="n">out</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;units&quot;</span><span class="p">][</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;dimensionless&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">_trans_norm</span><span class="p">(</span>
            <span class="n">out</span><span class="p">,</span>
            <span class="n">_vars</span><span class="p">,</span>
            <span class="n">stat_dict</span><span class="p">,</span>
            <span class="n">log_norm_cols</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">log_norm_cols</span><span class="p">,</span>
            <span class="n">to_norm</span><span class="o">=</span><span class="n">to_norm</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">load_norm_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vars_data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read data and perform normalization for DL models</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vars_data: dict</span>
<span class="sd">            data for all variables used</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            x: 3-d  gages_num*time_num*var_num</span>
<span class="sd">            y: 3-d  gages_num*time_num*1</span>
<span class="sd">            c: 2-d  gages_num*var_num</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">vars_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data_norm</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vars_data</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">






  <div class="doc doc-object doc-attribute">



<h4 id="torchhydro.datasets.data_scalers.DapengScaler.mean_prcp" class="doc doc-heading">
<code class="highlight language-python"><span class="n">mean_prcp</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-property"><code>property</code></small>
      <small class="doc doc-property doc-property-readonly"><code>readonly</code></small>
  </span>

<a href="#torchhydro.datasets.data_scalers.DapengScaler.mean_prcp" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">

      <p>This property is used to be divided by streamflow to normalize streamflow,
hence, its unit is same as streamflow</p>
<h6 id="torchhydro.datasets.data_scalers.DapengScaler.mean_prcp--returns">Returns<a class="headerlink" href="#torchhydro.datasets.data_scalers.DapengScaler.mean_prcp--returns" title="Permanent link">&para;</a></h6>
<p>np.ndarray
    mean_prcp with the same unit as streamflow</p>
    </div>

  </div>






  <div class="doc doc-object doc-method">



<h4 id="torchhydro.datasets.data_scalers.DapengScaler.__init__" class="doc doc-heading">
<code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vars_data</span><span class="p">,</span> <span class="n">data_cfgs</span><span class="p">,</span> <span class="n">is_tra_val_te</span><span class="p">,</span> <span class="n">other_vars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prcp_norm_cols</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gamma_norm_cols</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pbm_norm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">data_source</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#torchhydro.datasets.data_scalers.DapengScaler.__init__" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">

      <p>The normalization and denormalization methods from Dapeng's 1st WRR paper.
Some use StandardScaler, and some use special norm methods</p>
<h6 id="torchhydro.datasets.data_scalers.DapengScaler.__init__--parameters">Parameters<a class="headerlink" href="#torchhydro.datasets.data_scalers.DapengScaler.__init__--parameters" title="Permanent link">&para;</a></h6>
<p>!!! vars_data "dict"
    data for all variables used
data_cfgs
    data parameter config in data source
is_tra_val_te
    train/valid/test
other_vars
    if more input are needed, list them in other_vars
prcp_norm_cols
    data items which use _prcp_norm method to normalize
gamma_norm_cols
    data items which use log(\sqrt(x)+.1) method to normalize
pbm_norm
    if true, use pbm_norm method to normalize; the output of pbms is not normalized data, so its inverse is different.</p>

        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/data_scalers.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">vars_data</span><span class="p">,</span>
    <span class="n">data_cfgs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
    <span class="n">is_tra_val_te</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">other_vars</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">prcp_norm_cols</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">gamma_norm_cols</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">pbm_norm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">data_source</span><span class="p">:</span> <span class="nb">object</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The normalization and denormalization methods from Dapeng&#39;s 1st WRR paper.</span>
<span class="sd">    Some use StandardScaler, and some use special norm methods</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    vars_data: dict</span>
<span class="sd">        data for all variables used</span>
<span class="sd">    data_cfgs</span>
<span class="sd">        data parameter config in data source</span>
<span class="sd">    is_tra_val_te</span>
<span class="sd">        train/valid/test</span>
<span class="sd">    other_vars</span>
<span class="sd">        if more input are needed, list them in other_vars</span>
<span class="sd">    prcp_norm_cols</span>
<span class="sd">        data items which use _prcp_norm method to normalize</span>
<span class="sd">    gamma_norm_cols</span>
<span class="sd">        data items which use log(\sqrt(x)+.1) method to normalize</span>
<span class="sd">    pbm_norm</span>
<span class="sd">        if true, use pbm_norm method to normalize; the output of pbms is not normalized data, so its inverse is different.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">prcp_norm_cols</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">prcp_norm_cols</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;streamflow&quot;</span><span class="p">,</span>
        <span class="p">]</span>
    <span class="k">if</span> <span class="n">gamma_norm_cols</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">gamma_norm_cols</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;gpm_tp&quot;</span><span class="p">,</span>
            <span class="s2">&quot;sta_tp&quot;</span><span class="p">,</span>
            <span class="s2">&quot;total_precipitation_hourly&quot;</span><span class="p">,</span>
            <span class="s2">&quot;temperature_2m&quot;</span><span class="p">,</span>
            <span class="s2">&quot;dewpoint_temperature_2m&quot;</span><span class="p">,</span>
            <span class="s2">&quot;surface_net_solar_radiation&quot;</span><span class="p">,</span>
            <span class="s2">&quot;sm_surface&quot;</span><span class="p">,</span>
            <span class="s2">&quot;sm_rootzone&quot;</span><span class="p">,</span>
        <span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">data_target</span> <span class="o">=</span> <span class="n">vars_data</span><span class="p">[</span><span class="s2">&quot;target_cols&quot;</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span> <span class="o">=</span> <span class="n">data_cfgs</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">t_s_dict</span> <span class="o">=</span> <span class="n">wrap_t_s_dict</span><span class="p">(</span><span class="n">data_cfgs</span><span class="p">,</span> <span class="n">is_tra_val_te</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">data_other</span> <span class="o">=</span> <span class="n">other_vars</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">prcp_norm_cols</span> <span class="o">=</span> <span class="n">prcp_norm_cols</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">gamma_norm_cols</span> <span class="o">=</span> <span class="n">gamma_norm_cols</span>
    <span class="c1"># both prcp_norm_cols and gamma_norm_cols use log(\sqrt(x)+.1) method to normalize</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">log_norm_cols</span> <span class="o">=</span> <span class="n">gamma_norm_cols</span> <span class="o">+</span> <span class="n">prcp_norm_cols</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">pbm_norm</span> <span class="o">=</span> <span class="n">pbm_norm</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">data_source</span> <span class="o">=</span> <span class="n">data_source</span>
    <span class="c1"># save stat_dict of training period in case_dir for valid/test</span>
    <span class="n">stat_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;case_dir&quot;</span><span class="p">],</span> <span class="s2">&quot;dapengscaler_stat.json&quot;</span><span class="p">)</span>
    <span class="c1"># for testing sometimes such as pub cases, we need stat_dict_file from trained dataset</span>
    <span class="k">if</span> <span class="n">is_tra_val_te</span> <span class="o">==</span> <span class="s2">&quot;train&quot;</span> <span class="ow">and</span> <span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;stat_dict_file&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stat_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cal_stat_all</span><span class="p">(</span><span class="n">vars_data</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">stat_file</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
            <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stat_dict</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># for valid/test, we need to load stat_dict from train</span>
        <span class="k">if</span> <span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;stat_dict_file&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># we used a assigned stat file, typically for PUB exps</span>
            <span class="c1"># shutil.copy(data_cfgs[&quot;stat_dict_file&quot;], stat_file)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">shutil</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;stat_dict_file&quot;</span><span class="p">],</span> <span class="n">stat_file</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">SameFileError</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The source file and the target file are the same: </span><span class="si">{</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s1">&#39;stat_dict_file&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">, skipping the copy operation.&quot;</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">stat_file</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">stat_file</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stat_dict</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="torchhydro.datasets.data_scalers.DapengScaler.cal_stat_all" class="doc doc-heading">
<code class="highlight language-python"><span class="n">cal_stat_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vars_data</span><span class="p">)</span></code>


<a href="#torchhydro.datasets.data_scalers.DapengScaler.cal_stat_all" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">

      <p>Calculate statistics of outputs(streamflow etc), and inputs(forcing and attributes)
Parameters</p>
<hr />
<p>!!! vars_data "dict"
    data for all variables used</p>
<h6 id="torchhydro.datasets.data_scalers.DapengScaler.cal_stat_all--returns">Returns<a class="headerlink" href="#torchhydro.datasets.data_scalers.DapengScaler.cal_stat_all--returns" title="Permanent link">&para;</a></h6>
<p>dict
    a dict with statistic values</p>

        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/data_scalers.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">cal_stat_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vars_data</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate statistics of outputs(streamflow etc), and inputs(forcing and attributes)</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    vars_data: dict</span>
<span class="sd">        data for all variables used</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        a dict with statistic values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">stat_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vars_data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)):</span>
            <span class="n">var_name</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">prcp_norm_cols</span><span class="p">:</span>
                <span class="n">stat_dict</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">cal_stat_prcp_norm</span><span class="p">(</span>
                    <span class="n">v</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">variable</span><span class="o">=</span><span class="n">var_name</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mean_prcp</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma_norm_cols</span><span class="p">:</span>
                <span class="n">stat_dict</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">cal_stat_gamma</span><span class="p">(</span>
                    <span class="n">v</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">variable</span><span class="o">=</span><span class="n">var_name</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stat_dict</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">cal_stat</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">variable</span><span class="o">=</span><span class="n">var_name</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">())</span>

    <span class="k">return</span> <span class="n">stat_dict</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="torchhydro.datasets.data_scalers.DapengScaler.get_data_norm" class="doc doc-heading">
<code class="highlight language-python"><span class="n">get_data_norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">to_norm</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>


<a href="#torchhydro.datasets.data_scalers.DapengScaler.get_data_norm" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">

      <p>Get normalized values</p>
<h6 id="torchhydro.datasets.data_scalers.DapengScaler.get_data_norm--parameters">Parameters<a class="headerlink" href="#torchhydro.datasets.data_scalers.DapengScaler.get_data_norm--parameters" title="Permanent link">&para;</a></h6>
<p>data
    origin data
to_norm
    if true, perform normalization
    if false, perform denormalization</p>
<h6 id="torchhydro.datasets.data_scalers.DapengScaler.get_data_norm--returns">Returns<a class="headerlink" href="#torchhydro.datasets.data_scalers.DapengScaler.get_data_norm--returns" title="Permanent link">&para;</a></h6>
<p>np.array
    the output value for modeling</p>

        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/data_scalers.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">get_data_norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">to_norm</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get normalized values</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data</span>
<span class="sd">        origin data</span>
<span class="sd">    to_norm</span>
<span class="sd">        if true, perform normalization</span>
<span class="sd">        if false, perform denormalization</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.array</span>
<span class="sd">        the output value for modeling</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">stat_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stat_dict</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="c1"># if we don&#39;t set a copy() here, the attrs of data will be changed, which is not our wish</span>
    <span class="n">out</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span>
    <span class="n">_vars</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
    <span class="k">if</span> <span class="s2">&quot;units&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
        <span class="ne">Warning</span><span class="p">(</span><span class="s2">&quot;The attrs of output data does not contain units&quot;</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;units&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">_vars</span><span class="p">)):</span>
        <span class="n">var</span> <span class="o">=</span> <span class="n">_vars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">prcp_norm_cols</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="n">variable</span><span class="o">=</span><span class="n">var</span><span class="p">)]</span> <span class="o">=</span> <span class="n">_prcp_norm</span><span class="p">(</span>
                <span class="n">data</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">variable</span><span class="o">=</span><span class="n">var</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mean_prcp</span><span class="p">,</span>
                <span class="n">to_norm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="n">variable</span><span class="o">=</span><span class="n">var</span><span class="p">)]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">variable</span><span class="o">=</span><span class="n">var</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">out</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;units&quot;</span><span class="p">][</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;dimensionless&quot;</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">_trans_norm</span><span class="p">(</span>
        <span class="n">out</span><span class="p">,</span>
        <span class="n">_vars</span><span class="p">,</span>
        <span class="n">stat_dict</span><span class="p">,</span>
        <span class="n">log_norm_cols</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">log_norm_cols</span><span class="p">,</span>
        <span class="n">to_norm</span><span class="o">=</span><span class="n">to_norm</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="torchhydro.datasets.data_scalers.DapengScaler.inverse_transform" class="doc doc-heading">
<code class="highlight language-python"><span class="n">inverse_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_values</span><span class="p">)</span></code>


<a href="#torchhydro.datasets.data_scalers.DapengScaler.inverse_transform" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">

      <p>Denormalization for output variables</p>
<h6 id="torchhydro.datasets.data_scalers.DapengScaler.inverse_transform--parameters">Parameters<a class="headerlink" href="#torchhydro.datasets.data_scalers.DapengScaler.inverse_transform--parameters" title="Permanent link">&para;</a></h6>
<p>target_values
    output variables</p>
<h6 id="torchhydro.datasets.data_scalers.DapengScaler.inverse_transform--returns">Returns<a class="headerlink" href="#torchhydro.datasets.data_scalers.DapengScaler.inverse_transform--returns" title="Permanent link">&para;</a></h6>
<p>np.array
    denormalized predictions</p>

        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/data_scalers.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">inverse_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_values</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Denormalization for output variables</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    target_values</span>
<span class="sd">        output variables</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.array</span>
<span class="sd">        denormalized predictions</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">stat_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stat_dict</span>
    <span class="n">target_vars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;target_cols&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbm_norm</span><span class="p">:</span>
        <span class="c1"># for (differentiable models) pbm&#39;s output, its unit is mm/day, so we don&#39;t need to recover its unit</span>
        <span class="n">pred</span> <span class="o">=</span> <span class="n">target_values</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pred</span> <span class="o">=</span> <span class="n">_trans_norm</span><span class="p">(</span>
            <span class="n">target_values</span><span class="p">,</span>
            <span class="n">target_vars</span><span class="p">,</span>
            <span class="n">stat_dict</span><span class="p">,</span>
            <span class="n">log_norm_cols</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">log_norm_cols</span><span class="p">,</span>
            <span class="n">to_norm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;target_cols&quot;</span><span class="p">])):</span>
            <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;target_cols&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">prcp_norm_cols</span><span class="p">:</span>
                <span class="n">pred</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="n">variable</span><span class="o">=</span><span class="n">var</span><span class="p">)]</span> <span class="o">=</span> <span class="n">_prcp_norm</span><span class="p">(</span>
                    <span class="n">pred</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">variable</span><span class="o">=</span><span class="n">var</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mean_prcp</span><span class="p">,</span>
                    <span class="n">to_norm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pred</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="n">variable</span><span class="o">=</span><span class="n">var</span><span class="p">)]</span> <span class="o">=</span> <span class="n">pred</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">variable</span><span class="o">=</span><span class="n">var</span><span class="p">)</span>
    <span class="c1"># add attrs for units</span>
    <span class="n">pred</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_target</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pred</span><span class="o">.</span><span class="n">to_dataset</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;variable&quot;</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="torchhydro.datasets.data_scalers.DapengScaler.load_norm_data" class="doc doc-heading">
<code class="highlight language-python"><span class="n">load_norm_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vars_data</span><span class="p">)</span></code>


<a href="#torchhydro.datasets.data_scalers.DapengScaler.load_norm_data" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">

      <p>Read data and perform normalization for DL models
Parameters</p>
<hr />
<p>!!! vars_data "dict"
    data for all variables used</p>
<h6 id="torchhydro.datasets.data_scalers.DapengScaler.load_norm_data--returns">Returns<a class="headerlink" href="#torchhydro.datasets.data_scalers.DapengScaler.load_norm_data--returns" title="Permanent link">&para;</a></h6>
<p>tuple
    x: 3-d  gages_num<em>time_num</em>var_num
    y: 3-d  gages_num<em>time_num</em>1
    c: 2-d  gages_num*var_num</p>

        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/data_scalers.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">load_norm_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vars_data</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Read data and perform normalization for DL models</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    vars_data: dict</span>
<span class="sd">        data for all variables used</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple</span>
<span class="sd">        x: 3-d  gages_num*time_num*var_num</span>
<span class="sd">        y: 3-d  gages_num*time_num*1</span>
<span class="sd">        c: 2-d  gages_num*var_num</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">vars_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data_norm</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vars_data</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="p">}</span>
</code></pre></div>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h3 id="torchhydro.datasets.data_scalers.ScalerHub" class="doc doc-heading">
        <code>
ScalerHub        </code>



<a href="#torchhydro.datasets.data_scalers.ScalerHub" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>A class for Scaler</p>

        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/data_scalers.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">ScalerHub</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class for Scaler</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">vars_data</span><span class="p">,</span>
        <span class="n">data_cfgs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">is_tra_val_te</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">data_source</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform normalization</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vars_data</span>
<span class="sd">            data for all variables used.</span>
<span class="sd">            the dim must be (basin, time, lead_step, var) for 4-d array;</span>
<span class="sd">            the dim must be (basin, time, var) for 3-d array;</span>
<span class="sd">            the dim must be (basin, time) for 2-d array;</span>
<span class="sd">        data_cfgs</span>
<span class="sd">            configs for reading data</span>
<span class="sd">        is_tra_val_te</span>
<span class="sd">            train, valid or test</span>
<span class="sd">        data_source</span>
<span class="sd">            data source to get original data info</span>
<span class="sd">        kwargs</span>
<span class="sd">            other optional parameters for ScalerHub</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span> <span class="o">=</span> <span class="n">data_cfgs</span>
        <span class="n">scaler_type</span> <span class="o">=</span> <span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;scaler&quot;</span><span class="p">]</span>
        <span class="n">pbm_norm</span> <span class="o">=</span> <span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;scaler_params&quot;</span><span class="p">][</span><span class="s2">&quot;pbm_norm&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">scaler_type</span> <span class="o">==</span> <span class="s2">&quot;DapengScaler&quot;</span><span class="p">:</span>
            <span class="n">gamma_norm_cols</span> <span class="o">=</span> <span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;scaler_params&quot;</span><span class="p">][</span><span class="s2">&quot;gamma_norm_cols&quot;</span><span class="p">]</span>
            <span class="n">prcp_norm_cols</span> <span class="o">=</span> <span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;scaler_params&quot;</span><span class="p">][</span><span class="s2">&quot;prcp_norm_cols&quot;</span><span class="p">]</span>
            <span class="n">scaler</span> <span class="o">=</span> <span class="n">DapengScaler</span><span class="p">(</span>
                <span class="n">vars_data</span><span class="p">,</span>
                <span class="n">data_cfgs</span><span class="p">,</span>
                <span class="n">is_tra_val_te</span><span class="p">,</span>
                <span class="n">prcp_norm_cols</span><span class="o">=</span><span class="n">prcp_norm_cols</span><span class="p">,</span>
                <span class="n">gamma_norm_cols</span><span class="o">=</span><span class="n">gamma_norm_cols</span><span class="p">,</span>
                <span class="n">pbm_norm</span><span class="o">=</span><span class="n">pbm_norm</span><span class="p">,</span>
                <span class="n">data_source</span><span class="o">=</span><span class="n">data_source</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">scaler_type</span> <span class="ow">in</span> <span class="n">SCALER_DICT</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">scaler</span> <span class="o">=</span> <span class="n">SklearnScaler</span><span class="p">(</span>
                <span class="n">vars_data</span><span class="p">,</span>
                <span class="n">data_cfgs</span><span class="p">,</span>
                <span class="n">is_tra_val_te</span><span class="p">,</span>
                <span class="n">pbm_norm</span><span class="o">=</span><span class="n">pbm_norm</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;We don&#39;t provide this Scaler now!!! Please choose another one: DapengScaler or key in SCALER_DICT&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">norm_data</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">load_norm_data</span><span class="p">(</span><span class="n">vars_data</span><span class="p">)</span>
        <span class="c1"># we will use target_scaler during denormalization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_scaler</span> <span class="o">=</span> <span class="n">scaler</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Finish Normalization</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">









  <div class="doc doc-object doc-method">



<h4 id="torchhydro.datasets.data_scalers.ScalerHub.__init__" class="doc doc-heading">
<code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vars_data</span><span class="p">,</span> <span class="n">data_cfgs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">is_tra_val_te</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data_source</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#torchhydro.datasets.data_scalers.ScalerHub.__init__" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">

      <p>Perform normalization</p>
<h6 id="torchhydro.datasets.data_scalers.ScalerHub.__init__--parameters">Parameters<a class="headerlink" href="#torchhydro.datasets.data_scalers.ScalerHub.__init__--parameters" title="Permanent link">&para;</a></h6>
<p>vars_data
    data for all variables used.
    the dim must be (basin, time, lead_step, var) for 4-d array;
    the dim must be (basin, time, var) for 3-d array;
    the dim must be (basin, time) for 2-d array;
data_cfgs
    configs for reading data
is_tra_val_te
    train, valid or test
data_source
    data source to get original data info
kwargs
    other optional parameters for ScalerHub</p>

        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/data_scalers.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">vars_data</span><span class="p">,</span>
    <span class="n">data_cfgs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">is_tra_val_te</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">data_source</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform normalization</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    vars_data</span>
<span class="sd">        data for all variables used.</span>
<span class="sd">        the dim must be (basin, time, lead_step, var) for 4-d array;</span>
<span class="sd">        the dim must be (basin, time, var) for 3-d array;</span>
<span class="sd">        the dim must be (basin, time) for 2-d array;</span>
<span class="sd">    data_cfgs</span>
<span class="sd">        configs for reading data</span>
<span class="sd">    is_tra_val_te</span>
<span class="sd">        train, valid or test</span>
<span class="sd">    data_source</span>
<span class="sd">        data source to get original data info</span>
<span class="sd">    kwargs</span>
<span class="sd">        other optional parameters for ScalerHub</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span> <span class="o">=</span> <span class="n">data_cfgs</span>
    <span class="n">scaler_type</span> <span class="o">=</span> <span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;scaler&quot;</span><span class="p">]</span>
    <span class="n">pbm_norm</span> <span class="o">=</span> <span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;scaler_params&quot;</span><span class="p">][</span><span class="s2">&quot;pbm_norm&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">scaler_type</span> <span class="o">==</span> <span class="s2">&quot;DapengScaler&quot;</span><span class="p">:</span>
        <span class="n">gamma_norm_cols</span> <span class="o">=</span> <span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;scaler_params&quot;</span><span class="p">][</span><span class="s2">&quot;gamma_norm_cols&quot;</span><span class="p">]</span>
        <span class="n">prcp_norm_cols</span> <span class="o">=</span> <span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;scaler_params&quot;</span><span class="p">][</span><span class="s2">&quot;prcp_norm_cols&quot;</span><span class="p">]</span>
        <span class="n">scaler</span> <span class="o">=</span> <span class="n">DapengScaler</span><span class="p">(</span>
            <span class="n">vars_data</span><span class="p">,</span>
            <span class="n">data_cfgs</span><span class="p">,</span>
            <span class="n">is_tra_val_te</span><span class="p">,</span>
            <span class="n">prcp_norm_cols</span><span class="o">=</span><span class="n">prcp_norm_cols</span><span class="p">,</span>
            <span class="n">gamma_norm_cols</span><span class="o">=</span><span class="n">gamma_norm_cols</span><span class="p">,</span>
            <span class="n">pbm_norm</span><span class="o">=</span><span class="n">pbm_norm</span><span class="p">,</span>
            <span class="n">data_source</span><span class="o">=</span><span class="n">data_source</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">scaler_type</span> <span class="ow">in</span> <span class="n">SCALER_DICT</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">scaler</span> <span class="o">=</span> <span class="n">SklearnScaler</span><span class="p">(</span>
            <span class="n">vars_data</span><span class="p">,</span>
            <span class="n">data_cfgs</span><span class="p">,</span>
            <span class="n">is_tra_val_te</span><span class="p">,</span>
            <span class="n">pbm_norm</span><span class="o">=</span><span class="n">pbm_norm</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;We don&#39;t provide this Scaler now!!! Please choose another one: DapengScaler or key in SCALER_DICT&quot;</span>
        <span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">norm_data</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">load_norm_data</span><span class="p">(</span><span class="n">vars_data</span><span class="p">)</span>
    <span class="c1"># we will use target_scaler during denormalization</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">target_scaler</span> <span class="o">=</span> <span class="n">scaler</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Finish Normalization</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h3 id="torchhydro.datasets.data_scalers.SklearnScaler" class="doc doc-heading">
        <code>
SklearnScaler        </code>



<a href="#torchhydro.datasets.data_scalers.SklearnScaler" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">


        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/data_scalers.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">SklearnScaler</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">vars_data</span><span class="p">,</span>
        <span class="n">data_cfgs</span><span class="p">,</span>
        <span class="n">is_tra_val_te</span><span class="p">,</span>
        <span class="n">pbm_norm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;_summary_</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vars_data : dict</span>
<span class="sd">            vars data map</span>
<span class="sd">        data_cfgs : _type_</span>
<span class="sd">            _description_</span>
<span class="sd">        is_tra_val_te : bool</span>
<span class="sd">            _description_</span>
<span class="sd">        pbm_norm : bool, optional</span>
<span class="sd">            _description_, by default False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># we will use data_target and target_scaler for denormalization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_target</span> <span class="o">=</span> <span class="n">vars_data</span><span class="p">[</span><span class="s2">&quot;target_cols&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_scaler</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span> <span class="o">=</span> <span class="n">data_cfgs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_tra_val_te</span> <span class="o">=</span> <span class="n">is_tra_val_te</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pbm_norm</span> <span class="o">=</span> <span class="n">pbm_norm</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">load_norm_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vars_data</span><span class="p">):</span>
        <span class="c1"># TODO: not fully tested for differentiable models</span>
        <span class="n">norm_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">scaler_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;scaler&quot;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vars_data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">scaler</span> <span class="o">=</span> <span class="n">SCALER_DICT</span><span class="p">[</span><span class="n">scaler_type</span><span class="p">]()</span>
            <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="c1"># for forcings and outputs</span>
                <span class="n">num_instances</span><span class="p">,</span> <span class="n">num_time_steps</span><span class="p">,</span> <span class="n">num_features</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span>
                <span class="n">v_np</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_features</span><span class="p">)</span>
                <span class="n">scaler</span><span class="p">,</span> <span class="n">data_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sklearn_scale</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_tra_val_te</span><span class="p">,</span> <span class="n">scaler</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v_np</span>
                <span class="p">)</span>
                <span class="n">data_norm</span> <span class="o">=</span> <span class="n">data_norm</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                    <span class="n">num_instances</span><span class="p">,</span> <span class="n">num_time_steps</span><span class="p">,</span> <span class="n">num_features</span>
                <span class="p">)</span>
                <span class="n">norm_xrarray</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
                    <span class="n">data_norm</span><span class="p">,</span>
                    <span class="n">coords</span><span class="o">=</span><span class="p">{</span>
                        <span class="s2">&quot;basin&quot;</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;basin&quot;</span><span class="p">],</span>
                        <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">],</span>
                        <span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">],</span>
                    <span class="p">},</span>
                    <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;basin&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;variable&quot;</span><span class="p">],</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">v</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">num_instances</span><span class="p">,</span> <span class="n">num_features</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span>
                <span class="n">v_np</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_features</span><span class="p">)</span>
                <span class="n">scaler</span><span class="p">,</span> <span class="n">data_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sklearn_scale</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_tra_val_te</span><span class="p">,</span> <span class="n">scaler</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v_np</span>
                <span class="p">)</span>
                <span class="c1"># don&#39;t need to reshape data_norm again as it is 2-d</span>
                <span class="n">norm_xrarray</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
                    <span class="n">data_norm</span><span class="p">,</span>
                    <span class="n">coords</span><span class="o">=</span><span class="p">{</span>
                        <span class="s2">&quot;basin&quot;</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;basin&quot;</span><span class="p">],</span>
                        <span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">],</span>
                    <span class="p">},</span>
                    <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;basin&quot;</span><span class="p">,</span> <span class="s2">&quot;variable&quot;</span><span class="p">],</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">v</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="c1"># for forecast data</span>
                <span class="n">num_instances</span><span class="p">,</span> <span class="n">num_time_steps</span><span class="p">,</span> <span class="n">num_lead_steps</span><span class="p">,</span> <span class="n">num_features</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span>
                <span class="n">v_np</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_features</span><span class="p">)</span>
                <span class="n">scaler</span><span class="p">,</span> <span class="n">data_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sklearn_scale</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_tra_val_te</span><span class="p">,</span> <span class="n">scaler</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v_np</span>
                <span class="p">)</span>
                <span class="n">data_norm</span> <span class="o">=</span> <span class="n">data_norm</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                    <span class="n">num_instances</span><span class="p">,</span> <span class="n">num_time_steps</span><span class="p">,</span> <span class="n">num_lead_steps</span><span class="p">,</span> <span class="n">num_features</span>
                <span class="p">)</span>
                <span class="n">norm_xrarray</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
                    <span class="n">data_norm</span><span class="p">,</span>
                    <span class="n">coords</span><span class="o">=</span><span class="p">{</span>
                        <span class="s2">&quot;basin&quot;</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;basin&quot;</span><span class="p">],</span>
                        <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">],</span>
                        <span class="s2">&quot;lead_step&quot;</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;lead_step&quot;</span><span class="p">],</span>
                        <span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">],</span>
                    <span class="p">},</span>
                    <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;basin&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;lead_step&quot;</span><span class="p">,</span> <span class="s2">&quot;variable&quot;</span><span class="p">],</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;Please check your data, the dim of data must be 2, 3 or 4&quot;</span>
                <span class="p">)</span>

            <span class="n">norm_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">norm_xrarray</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">&quot;target_cols&quot;</span><span class="p">:</span>
                <span class="c1"># we need target cols scaler for denormalization</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">target_scaler</span> <span class="o">=</span> <span class="n">scaler</span>
        <span class="k">return</span> <span class="n">norm_dict</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_sklearn_scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_cfgs</span><span class="p">,</span> <span class="n">is_tra_val_te</span><span class="p">,</span> <span class="n">scaler</span><span class="p">,</span> <span class="n">norm_key</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="n">save_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;case_dir&quot;</span><span class="p">],</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">norm_key</span><span class="si">}</span><span class="s2">_scaler.pkl&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_tra_val_te</span> <span class="o">==</span> <span class="s2">&quot;train&quot;</span> <span class="ow">and</span> <span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;stat_dict_file&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data_norm</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="c1"># Save scaler in case_dir for valid/test</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">save_file</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">outfile</span><span class="p">:</span>
                <span class="n">pkl</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">scaler</span><span class="p">,</span> <span class="n">outfile</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;stat_dict_file&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># NOTE: you need to set data_cfgs[&quot;stat_dict_file&quot;] as a str with &quot;;&quot; as its seperator</span>
                <span class="c1"># the sequence of the stat_dict_file must be same as the sequence of norm_keys</span>
                <span class="c1"># for example: &quot;stat_dict_file&quot;: &quot;target_stat_dict_file;relevant_stat_dict_file;constant_stat_dict_file&quot;</span>
                <span class="n">shutil</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;stat_dict_file&quot;</span><span class="p">][</span><span class="n">norm_key</span><span class="p">],</span> <span class="n">save_file</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">save_file</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="s2">&quot;Please genereate xx_scaler.pkl file&quot;</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">save_file</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">infile</span><span class="p">:</span>
                <span class="n">scaler</span> <span class="o">=</span> <span class="n">pkl</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">infile</span><span class="p">)</span>
                <span class="n">data_norm</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">scaler</span><span class="p">,</span> <span class="n">data_norm</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">inverse_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_values</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Denormalization for output variables</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        target_values</span>
<span class="sd">            output variables (xr.DataArray or np.ndarray)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xr.Dataset</span>
<span class="sd">            denormalized predictions or observations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_target</span><span class="o">.</span><span class="n">coords</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_target</span><span class="o">.</span><span class="n">attrs</span>
        <span class="c1"># input must be xr.DataArray</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target_values</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">):</span>
            <span class="c1"># the shape of target_values must be (basin, time, variable)</span>
            <span class="n">target_values</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
                <span class="n">target_values</span><span class="p">,</span>
                <span class="n">coords</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;basin&quot;</span><span class="p">:</span> <span class="n">coords</span><span class="p">[</span><span class="s2">&quot;basin&quot;</span><span class="p">],</span>
                    <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">coords</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">],</span>
                    <span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">coords</span><span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">],</span>
                <span class="p">},</span>
                <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;basin&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;variable&quot;</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="c1"># transform to numpy array for sklearn inverse_transform</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">target_values</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">target_values</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># sklearn inverse_transform</span>
        <span class="n">arr_inv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_scaler</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
        <span class="c1"># reshape to original shape</span>
        <span class="n">arr_inv</span> <span class="o">=</span> <span class="n">arr_inv</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">arr_inv</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="n">target_values</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span>
            <span class="n">dims</span><span class="o">=</span><span class="n">target_values</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span>
            <span class="n">attrs</span><span class="o">=</span><span class="n">attrs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># add attrs for units</span>
        <span class="n">result</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_target</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">to_dataset</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;variable&quot;</span><span class="p">)</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">









  <div class="doc doc-object doc-method">



<h4 id="torchhydro.datasets.data_scalers.SklearnScaler.__init__" class="doc doc-heading">
<code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vars_data</span><span class="p">,</span> <span class="n">data_cfgs</span><span class="p">,</span> <span class="n">is_tra_val_te</span><span class="p">,</span> <span class="n">pbm_norm</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#torchhydro.datasets.data_scalers.SklearnScaler.__init__" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">

      <p><em>summary</em></p>
<h6 id="torchhydro.datasets.data_scalers.SklearnScaler.__init__--parameters">Parameters<a class="headerlink" href="#torchhydro.datasets.data_scalers.SklearnScaler.__init__--parameters" title="Permanent link">&para;</a></h6>
<p>vars_data : dict
    vars data map
data_cfgs : <em>type</em>
    <em>description</em>
is_tra_val_te : bool
    <em>description</em>
pbm_norm : bool, optional
    <em>description</em>, by default False</p>

        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/data_scalers.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">vars_data</span><span class="p">,</span>
    <span class="n">data_cfgs</span><span class="p">,</span>
    <span class="n">is_tra_val_te</span><span class="p">,</span>
    <span class="n">pbm_norm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;_summary_</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    vars_data : dict</span>
<span class="sd">        vars data map</span>
<span class="sd">    data_cfgs : _type_</span>
<span class="sd">        _description_</span>
<span class="sd">    is_tra_val_te : bool</span>
<span class="sd">        _description_</span>
<span class="sd">    pbm_norm : bool, optional</span>
<span class="sd">        _description_, by default False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># we will use data_target and target_scaler for denormalization</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">data_target</span> <span class="o">=</span> <span class="n">vars_data</span><span class="p">[</span><span class="s2">&quot;target_cols&quot;</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">target_scaler</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span> <span class="o">=</span> <span class="n">data_cfgs</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">is_tra_val_te</span> <span class="o">=</span> <span class="n">is_tra_val_te</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">pbm_norm</span> <span class="o">=</span> <span class="n">pbm_norm</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="torchhydro.datasets.data_scalers.SklearnScaler.inverse_transform" class="doc doc-heading">
<code class="highlight language-python"><span class="n">inverse_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_values</span><span class="p">)</span></code>


<a href="#torchhydro.datasets.data_scalers.SklearnScaler.inverse_transform" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">

      <p>Denormalization for output variables</p>
<h6 id="torchhydro.datasets.data_scalers.SklearnScaler.inverse_transform--parameters">Parameters<a class="headerlink" href="#torchhydro.datasets.data_scalers.SklearnScaler.inverse_transform--parameters" title="Permanent link">&para;</a></h6>
<p>target_values
    output variables (xr.DataArray or np.ndarray)</p>
<h6 id="torchhydro.datasets.data_scalers.SklearnScaler.inverse_transform--returns">Returns<a class="headerlink" href="#torchhydro.datasets.data_scalers.SklearnScaler.inverse_transform--returns" title="Permanent link">&para;</a></h6>
<p>xr.Dataset
    denormalized predictions or observations</p>

        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/data_scalers.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">inverse_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_values</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Denormalization for output variables</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    target_values</span>
<span class="sd">        output variables (xr.DataArray or np.ndarray)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xr.Dataset</span>
<span class="sd">        denormalized predictions or observations</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_target</span><span class="o">.</span><span class="n">coords</span>
    <span class="n">attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_target</span><span class="o">.</span><span class="n">attrs</span>
    <span class="c1"># input must be xr.DataArray</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target_values</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">):</span>
        <span class="c1"># the shape of target_values must be (basin, time, variable)</span>
        <span class="n">target_values</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">target_values</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="p">{</span>
                <span class="s2">&quot;basin&quot;</span><span class="p">:</span> <span class="n">coords</span><span class="p">[</span><span class="s2">&quot;basin&quot;</span><span class="p">],</span>
                <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">coords</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">],</span>
                <span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">coords</span><span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">],</span>
            <span class="p">},</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;basin&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;variable&quot;</span><span class="p">],</span>
        <span class="p">)</span>
    <span class="c1"># transform to numpy array for sklearn inverse_transform</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">target_values</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">target_values</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="c1"># sklearn inverse_transform</span>
    <span class="n">arr_inv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_scaler</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="c1"># reshape to original shape</span>
    <span class="n">arr_inv</span> <span class="o">=</span> <span class="n">arr_inv</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
        <span class="n">arr_inv</span><span class="p">,</span>
        <span class="n">coords</span><span class="o">=</span><span class="n">target_values</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span>
        <span class="n">dims</span><span class="o">=</span><span class="n">target_values</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span>
        <span class="n">attrs</span><span class="o">=</span><span class="n">attrs</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="c1"># add attrs for units</span>
    <span class="n">result</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_target</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">to_dataset</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;variable&quot;</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>







  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="torchhydro.datasets.data_sets" class="doc doc-heading">
        <code>data_sets</code>



<a href="#torchhydro.datasets.data_sets" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Author: Wenyu Ouyang
Date: 2024-04-08 18:16:53
LastEditTime: 2025-11-07 09:39:57
LastEditors: Wenyu Ouyang
Description: A pytorch dataset class; references to https://github.com/neuralhydrology/neuralhydrology
FilePath:       orchhydro       orchhydro\datasets\data_sets.py
Copyright (c) 2024-2024 Wenyu Ouyang. All rights reserved.</p>



  <div class="doc doc-children">









  <div class="doc doc-object doc-class">



<h3 id="torchhydro.datasets.data_sets.AugmentedFloodEventDataset" class="doc doc-heading">
        <code>
AugmentedFloodEventDataset            (<a class="autorefs autorefs-internal" title="
FloodEventDataset            (BaseDataset)
         (torchhydro.datasets.data_sets.FloodEventDataset)" href="#torchhydro.datasets.data_sets.FloodEventDataset">FloodEventDataset</a>)
        </code>



<a href="#torchhydro.datasets.data_sets.AugmentedFloodEventDataset" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Dataset class for augmented flood event data with discontinuous time ranges.</p>
<p>This dataset is designed to handle flood event data that includes augmented
(generated) future data alongside historical data, where time ranges may be
discontinuous (e.g., historical data 1990-2010, then augmented data 2026+).</p>
<p>It connects to hydrodatasource.reader.floodevent.FloodEventDatasource
and uses the read_ts_xrdataset_augmented method to read augmented data.</p>

        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/data_sets.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">AugmentedFloodEventDataset</span><span class="p">(</span><span class="n">FloodEventDataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Dataset class for augmented flood event data with discontinuous time ranges.</span>

<span class="sd">    This dataset is designed to handle flood event data that includes augmented</span>
<span class="sd">    (generated) future data alongside historical data, where time ranges may be</span>
<span class="sd">    discontinuous (e.g., historical data 1990-2010, then augmented data 2026+).</span>

<span class="sd">    It connects to hydrodatasource.reader.floodevent.FloodEventDatasource</span>
<span class="sd">    and uses the read_ts_xrdataset_augmented method to read augmented data.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cfgs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">is_tra_val_te</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize AugmentedFloodEventDataset</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cfgs : dict</span>
<span class="sd">            Configuration dictionary containing data_cfgs, training_cfgs, evaluation_cfgs</span>
<span class="sd">        is_tra_val_te : str</span>
<span class="sd">            One of &#39;train&#39;, &#39;valid&#39;, or &#39;test&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">AugmentedFloodEventDataset</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cfgs</span><span class="p">,</span> <span class="n">is_tra_val_te</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_source</span><span class="p">,</span> <span class="s2">&quot;read_ts_xrdataset_augmented&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Data source must support read_ts_xrdataset_augmented method&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_read_xyc_period</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_date</span><span class="p">,</span> <span class="n">end_date</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Override template method to read augmented flood event data for a specific period</span>

<span class="sd">        This method leverages the parent class&#39;s multi-period handling while using</span>
<span class="sd">        augmented data reading methods for generated future data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start_date : str</span>
<span class="sd">            start time</span>
<span class="sd">        end_date : str</span>
<span class="sd">            end time</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary containing relevant_cols, target_cols, and constant_cols data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_xyc_specified_time_augmented</span><span class="p">(</span><span class="n">start_date</span><span class="p">,</span> <span class="n">end_date</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_read_xyc_specified_time_augmented</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_date</span><span class="p">,</span> <span class="n">end_date</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read x, y, c data from both historical and augmented data sources</span>

<span class="sd">        This method reads both historical observed data (using read_ts_xrdataset)</span>
<span class="sd">        and augmented future data (using read_ts_xrdataset_augmented), then</span>
<span class="sd">        concatenates them along the time dimension to provide a complete dataset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start_date : str</span>
<span class="sd">            start time</span>
<span class="sd">        end_date : str</span>
<span class="sd">            end time</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary containing relevant_cols, target_cols, and constant_cols data</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Read historical observed data using standard method</span>
        <span class="n">relevant_cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;relevant_cols&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;rain&quot;</span><span class="p">])</span>
        <span class="n">target_cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;target_cols&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;inflow&quot;</span><span class="p">,</span> <span class="s2">&quot;flood_event&quot;</span><span class="p">])</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">data_forcing_hist_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_source</span><span class="o">.</span><span class="n">read_ts_xrdataset</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">t_s_dict</span><span class="p">[</span><span class="s2">&quot;sites_id&quot;</span><span class="p">],</span>
                <span class="p">[</span><span class="n">start_date</span><span class="p">,</span> <span class="n">end_date</span><span class="p">],</span>
                <span class="n">relevant_cols</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">data_output_hist_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_source</span><span class="o">.</span><span class="n">read_ts_xrdataset</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">t_s_dict</span><span class="p">[</span><span class="s2">&quot;sites_id&quot;</span><span class="p">],</span>
                <span class="p">[</span><span class="n">start_date</span><span class="p">,</span> <span class="n">end_date</span><span class="p">],</span>
                <span class="n">target_cols</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Process historical data</span>
            <span class="n">data_forcing_hist_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rm_timeunit_key</span><span class="p">(</span><span class="n">data_forcing_hist_</span><span class="p">)</span>
            <span class="n">data_output_hist_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rm_timeunit_key</span><span class="p">(</span><span class="n">data_output_hist_</span><span class="p">)</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">data_forcing_hist_</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">data_output_hist_</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Read augmented data using augmented method</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">data_forcing_aug_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_source</span><span class="o">.</span><span class="n">read_ts_xrdataset_augmented</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">t_s_dict</span><span class="p">[</span><span class="s2">&quot;sites_id&quot;</span><span class="p">],</span>
                <span class="p">[</span><span class="n">start_date</span><span class="p">,</span> <span class="n">end_date</span><span class="p">],</span>
                <span class="n">relevant_cols</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">data_output_aug_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_source</span><span class="o">.</span><span class="n">read_ts_xrdataset_augmented</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">t_s_dict</span><span class="p">[</span><span class="s2">&quot;sites_id&quot;</span><span class="p">],</span>
                <span class="p">[</span><span class="n">start_date</span><span class="p">,</span> <span class="n">end_date</span><span class="p">],</span>
                <span class="n">target_cols</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Process augmented data</span>
            <span class="n">data_forcing_aug_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rm_timeunit_key</span><span class="p">(</span><span class="n">data_forcing_aug_</span><span class="p">)</span>
            <span class="n">data_output_aug_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rm_timeunit_key</span><span class="p">(</span><span class="n">data_output_aug_</span><span class="p">)</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">data_forcing_aug_</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">data_output_aug_</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Combine historical and augmented data</span>
        <span class="n">data_forcing_ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_historical_and_augmented_data</span><span class="p">(</span>
            <span class="n">data_forcing_hist_</span><span class="p">,</span> <span class="n">data_forcing_aug_</span><span class="p">,</span> <span class="s2">&quot;forcing&quot;</span>
        <span class="p">)</span>
        <span class="n">data_output_ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_historical_and_augmented_data</span><span class="p">(</span>
            <span class="n">data_output_hist_</span><span class="p">,</span> <span class="n">data_output_aug_</span><span class="p">,</span> <span class="s2">&quot;target&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Check and process combined data</span>
        <span class="n">data_forcing_ds</span><span class="p">,</span> <span class="n">data_output_ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_ts_xrds_unit</span><span class="p">(</span>
            <span class="n">data_forcing_ds</span><span class="p">,</span> <span class="n">data_output_ds</span>
        <span class="p">)</span>

        <span class="c1"># Read constant/attribute data (same as parent class)</span>
        <span class="n">data_attr_ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_source</span><span class="o">.</span><span class="n">read_attr_xrdataset</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">t_s_dict</span><span class="p">[</span><span class="s2">&quot;sites_id&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;constant_cols&quot;</span><span class="p">],</span>
            <span class="n">all_number</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Convert to DataArray with units</span>
        <span class="n">x_origin</span><span class="p">,</span> <span class="n">y_origin</span><span class="p">,</span> <span class="n">c_origin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_dataarray_with_unit</span><span class="p">(</span>
            <span class="n">data_forcing_ds</span><span class="p">,</span> <span class="n">data_output_ds</span><span class="p">,</span> <span class="n">data_attr_ds</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;relevant_cols&quot;</span><span class="p">:</span> <span class="n">x_origin</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;basin&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;variable&quot;</span><span class="p">),</span>
            <span class="s2">&quot;target_cols&quot;</span><span class="p">:</span> <span class="n">y_origin</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;basin&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;variable&quot;</span><span class="p">),</span>
            <span class="s2">&quot;constant_cols&quot;</span><span class="p">:</span> <span class="p">(</span>
                <span class="n">c_origin</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;basin&quot;</span><span class="p">,</span> <span class="s2">&quot;variable&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">c_origin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="k">else</span> <span class="kc">None</span>
            <span class="p">),</span>
        <span class="p">}</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_combine_historical_and_augmented_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hist_data</span><span class="p">,</span> <span class="n">aug_data</span><span class="p">,</span> <span class="n">data_type</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Combine historical observed data and augmented generated data</span>

<span class="sd">        This method concatenates historical and augmented data along the time dimension,</span>
<span class="sd">        handling cases where data may be discontinuous or overlapping.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        hist_data : xr.Dataset or None</span>
<span class="sd">            Historical observed data</span>
<span class="sd">        aug_data : xr.Dataset or None</span>
<span class="sd">            Augmented generated data</span>
<span class="sd">        data_type : str</span>
<span class="sd">            Type of data (&quot;forcing&quot; or &quot;target&quot;) for logging purposes</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xr.Dataset</span>
<span class="sd">            Combined dataset with historical and augmented data concatenated</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">xarray</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">xr</span>

        <span class="c1"># Handle cases where one or both data sources are None</span>
        <span class="k">if</span> <span class="n">hist_data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">aug_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Both historical and augmented </span><span class="si">{</span><span class="n">data_type</span><span class="si">}</span><span class="s2"> data are None&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">hist_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;No historical </span><span class="si">{</span><span class="n">data_type</span><span class="si">}</span><span class="s2"> data found, using only augmented data&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">aug_data</span>
        <span class="k">elif</span> <span class="n">aug_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;No augmented </span><span class="si">{</span><span class="n">data_type</span><span class="si">}</span><span class="s2"> data found, using only historical data&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">hist_data</span>

        <span class="c1"># Both datasets exist - need to combine them</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Check if there&#39;s time overlap between datasets</span>
            <span class="n">hist_times</span> <span class="o">=</span> <span class="n">hist_data</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">values</span> <span class="k">if</span> <span class="s2">&quot;time&quot;</span> <span class="ow">in</span> <span class="n">hist_data</span><span class="o">.</span><span class="n">dims</span> <span class="k">else</span> <span class="p">[]</span>
            <span class="n">aug_times</span> <span class="o">=</span> <span class="n">aug_data</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">values</span> <span class="k">if</span> <span class="s2">&quot;time&quot;</span> <span class="ow">in</span> <span class="n">aug_data</span><span class="o">.</span><span class="n">dims</span> <span class="k">else</span> <span class="p">[]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hist_times</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Historical </span><span class="si">{</span><span class="n">data_type</span><span class="si">}</span><span class="s2"> data has no time dimension, using only augmented data&quot;</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="n">aug_data</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">aug_times</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Augmented </span><span class="si">{</span><span class="n">data_type</span><span class="si">}</span><span class="s2"> data has no time dimension, using only historical data&quot;</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="n">hist_data</span>

            <span class="c1"># Find overlap period</span>
            <span class="n">hist_start</span><span class="p">,</span> <span class="n">hist_end</span> <span class="o">=</span> <span class="n">hist_times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">hist_times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">aug_start</span><span class="p">,</span> <span class="n">aug_end</span> <span class="o">=</span> <span class="n">aug_times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">aug_times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Check for overlap</span>
            <span class="k">if</span> <span class="n">hist_end</span> <span class="o">&lt;</span> <span class="n">aug_start</span><span class="p">:</span>
                <span class="c1"># No overlap - historical data ends before augmented data starts</span>
                <span class="n">LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;No temporal overlap for </span><span class="si">{</span><span class="n">data_type</span><span class="si">}</span><span class="s2"> data, concatenating sequentially&quot;</span>
                <span class="p">)</span>
                <span class="n">combined_data</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">hist_data</span><span class="p">,</span> <span class="n">aug_data</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s2">&quot;time&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">aug_end</span> <span class="o">&lt;</span> <span class="n">hist_start</span><span class="p">:</span>
                <span class="c1"># No overlap - augmented data ends before historical data starts</span>
                <span class="n">LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Augmented </span><span class="si">{</span><span class="n">data_type</span><span class="si">}</span><span class="s2"> data precedes historical data, concatenating&quot;</span>
                <span class="p">)</span>
                <span class="n">combined_data</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">aug_data</span><span class="p">,</span> <span class="n">hist_data</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s2">&quot;time&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># There is overlap - need to handle carefully</span>
                <span class="n">LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Temporal overlap detected for </span><span class="si">{</span><span class="n">data_type</span><span class="si">}</span><span class="s2"> data, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;merging with priority to historical data&quot;</span>
                <span class="p">)</span>

                <span class="c1"># Create time index for the full range</span>
                <span class="n">all_times</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">hist_times</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">aug_times</span><span class="p">)))</span>

                <span class="c1"># Reindex both datasets to the full time range</span>
                <span class="n">hist_reindexed</span> <span class="o">=</span> <span class="n">hist_data</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="n">all_times</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">aug_reindexed</span> <span class="o">=</span> <span class="n">aug_data</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="n">all_times</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

                <span class="c1"># Combine: use historical data where available, fill with augmented data</span>
                <span class="n">combined_data</span> <span class="o">=</span> <span class="n">hist_reindexed</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="o">~</span><span class="n">hist_reindexed</span><span class="o">.</span><span class="n">isnull</span><span class="p">(),</span> <span class="n">aug_reindexed</span>
                <span class="p">)</span>

            <span class="c1"># Sort by time to ensure proper ordering</span>
            <span class="n">combined_data</span> <span class="o">=</span> <span class="n">combined_data</span><span class="o">.</span><span class="n">sortby</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">)</span>

            <span class="n">LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Successfully combined </span><span class="si">{</span><span class="n">data_type</span><span class="si">}</span><span class="s2"> data: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;historical shape </span><span class="si">{</span><span class="n">hist_data</span><span class="o">.</span><span class="n">dims</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="nb">hasattr</span><span class="p">(</span><span class="n">hist_data</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;dims&#39;</span><span class="p">)</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;N/A&#39;</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;augmented shape </span><span class="si">{</span><span class="n">aug_data</span><span class="o">.</span><span class="n">dims</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="nb">hasattr</span><span class="p">(</span><span class="n">aug_data</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;dims&#39;</span><span class="p">)</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;N/A&#39;</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;combined shape </span><span class="si">{</span><span class="n">combined_data</span><span class="o">.</span><span class="n">dims</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

            <span class="k">return</span> <span class="n">combined_data</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to combine </span><span class="si">{</span><span class="n">data_type</span><span class="si">}</span><span class="s2"> data: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># Fallback: prefer historical data if combination fails</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Falling back to historical </span><span class="si">{</span><span class="n">data_type</span><span class="si">}</span><span class="s2"> data only&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">hist_data</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_handle_discontinuous_time_ranges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_dict</span><span class="p">,</span> <span class="n">start_date</span><span class="p">,</span> <span class="n">end_date</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Handle discontinuous time ranges by filling gaps with NaN values</span>

<span class="sd">        This method creates a continuous time index and fills missing periods</span>
<span class="sd">        with NaN values, handling cases such as training data covers 1990-2010,</span>
<span class="sd">        augmented data starts from 2026+, and test data covers 2011-2025.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data_dict : dict</span>
<span class="sd">            Dictionary containing xarray data with keys &#39;relevant_cols&#39;,</span>
<span class="sd">            &#39;target_cols&#39;, &#39;constant_cols&#39;</span>
<span class="sd">        start_date : str</span>
<span class="sd">            Overall start date for the continuous timeline</span>
<span class="sd">        end_date : str</span>
<span class="sd">            Overall end date for the continuous timeline</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary with continuous time index and NaN-filled gaps</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create continuous daily time index from start_date to end_date</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">continuous_time</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">start_date</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end_date</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s2">&quot;D&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to create continuous time index: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">data_dict</span>

        <span class="c1"># Process each data type (relevant_cols, target_cols)</span>
        <span class="n">processed_dict</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">data_key</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;relevant_cols&quot;</span><span class="p">,</span> <span class="s2">&quot;target_cols&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">data_key</span> <span class="ow">in</span> <span class="n">data_dict</span> <span class="ow">and</span> <span class="n">data_dict</span><span class="p">[</span><span class="n">data_key</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">original_data</span> <span class="o">=</span> <span class="n">data_dict</span><span class="p">[</span><span class="n">data_key</span><span class="p">]</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># Check if data has time dimension</span>
                    <span class="k">if</span> <span class="s2">&quot;time&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">original_data</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                        <span class="n">LOGGER</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">data_key</span><span class="si">}</span><span class="s2"> has no time dimension, skipping time alignment&quot;</span>
                        <span class="p">)</span>
                        <span class="n">processed_dict</span><span class="p">[</span><span class="n">data_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">original_data</span>
                        <span class="k">continue</span>

                    <span class="c1"># Reindex to continuous time, filling gaps with NaN</span>
                    <span class="n">aligned_data</span> <span class="o">=</span> <span class="n">original_data</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span>
                        <span class="n">time</span><span class="o">=</span><span class="n">continuous_time</span><span class="p">,</span>
                        <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># No interpolation, fill with NaN</span>
                        <span class="n">fill_value</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;nan&quot;</span><span class="p">),</span>
                    <span class="p">)</span>

                    <span class="n">processed_dict</span><span class="p">[</span><span class="n">data_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">aligned_data</span>

                    <span class="c1"># Log information about the alignment</span>
                    <span class="n">original_time_points</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">original_data</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
                    <span class="n">aligned_time_points</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">aligned_data</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
                    <span class="n">nan_points</span> <span class="o">=</span> <span class="n">aligned_data</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">values</span>

                    <span class="n">LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">data_key</span><span class="si">}</span><span class="s2">: aligned from </span><span class="si">{</span><span class="n">original_time_points</span><span class="si">}</span><span class="s2"> to &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">aligned_time_points</span><span class="si">}</span><span class="s2"> time points, with </span><span class="si">{</span><span class="n">nan_points</span><span class="si">}</span><span class="s2"> &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;NaN values for discontinuous periods&quot;</span>
                    <span class="p">)</span>

                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">LOGGER</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Failed to align </span><span class="si">{</span><span class="n">data_key</span><span class="si">}</span><span class="s2"> to continuous timeline: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                    <span class="n">processed_dict</span><span class="p">[</span><span class="n">data_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">original_data</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">processed_dict</span><span class="p">[</span><span class="n">data_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">data_key</span><span class="p">)</span>

        <span class="c1"># Constant cols don&#39;t need time alignment</span>
        <span class="n">processed_dict</span><span class="p">[</span><span class="s2">&quot;constant_cols&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;constant_cols&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">processed_dict</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">









  <div class="doc doc-object doc-method">



<h4 id="torchhydro.datasets.data_sets.AugmentedFloodEventDataset.__init__" class="doc doc-heading">
<code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cfgs</span><span class="p">,</span> <span class="n">is_tra_val_te</span><span class="p">)</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#torchhydro.datasets.data_sets.AugmentedFloodEventDataset.__init__" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">

      <p>Initialize AugmentedFloodEventDataset</p>
<h6 id="torchhydro.datasets.data_sets.AugmentedFloodEventDataset.__init__--parameters">Parameters<a class="headerlink" href="#torchhydro.datasets.data_sets.AugmentedFloodEventDataset.__init__--parameters" title="Permanent link">&para;</a></h6>
<p>cfgs : dict
    Configuration dictionary containing data_cfgs, training_cfgs, evaluation_cfgs
is_tra_val_te : str
    One of 'train', 'valid', or 'test'</p>

        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/data_sets.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cfgs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">is_tra_val_te</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initialize AugmentedFloodEventDataset</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cfgs : dict</span>
<span class="sd">        Configuration dictionary containing data_cfgs, training_cfgs, evaluation_cfgs</span>
<span class="sd">    is_tra_val_te : str</span>
<span class="sd">        One of &#39;train&#39;, &#39;valid&#39;, or &#39;test&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">AugmentedFloodEventDataset</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cfgs</span><span class="p">,</span> <span class="n">is_tra_val_te</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_source</span><span class="p">,</span> <span class="s2">&quot;read_ts_xrdataset_augmented&quot;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Data source must support read_ts_xrdataset_augmented method&quot;</span>
        <span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h3 id="torchhydro.datasets.data_sets.BaseDataset" class="doc doc-heading">
        <code>
BaseDataset            (<span title="torch.utils.data.dataset.Dataset">Dataset</span>)
        </code>



<a href="#torchhydro.datasets.data_sets.BaseDataset" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Base data set class to load and preprocess data (batch-first) using PyTorch's Dataset</p>

        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/data_sets.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">BaseDataset</span><span class="p">(</span><span class="n">Dataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base data set class to load and preprocess data (batch-first) using PyTorch&#39;s Dataset&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cfgs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">is_tra_val_te</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cfgs</span>
<span class="sd">            configs, including data and training + evaluation settings</span>
<span class="sd">            which will be used for organizing batch data</span>
<span class="sd">        is_tra_val_te</span>
<span class="sd">            train, vaild or test</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BaseDataset</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span> <span class="o">=</span> <span class="n">cfgs</span><span class="p">[</span><span class="s2">&quot;data_cfgs&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">training_cfgs</span> <span class="o">=</span> <span class="n">cfgs</span><span class="p">[</span><span class="s2">&quot;training_cfgs&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">evaluation_cfgs</span> <span class="o">=</span> <span class="n">cfgs</span><span class="p">[</span><span class="s2">&quot;evaluation_cfgs&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pre_load_data</span><span class="p">(</span><span class="n">is_tra_val_te</span><span class="p">)</span>
        <span class="c1"># load and preprocess data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load_data</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_pre_load_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_tra_val_te</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        some preprocessing before loading data, such as</span>
<span class="sd">        setting the way to organize batch data</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        is_tra_val_te: bool</span>
<span class="sd">            train, valid or test</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            _description_</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">is_tra_val_te</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;train&quot;</span><span class="p">,</span> <span class="s2">&quot;valid&quot;</span><span class="p">,</span> <span class="s2">&quot;test&quot;</span><span class="p">}:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">is_tra_val_te</span> <span class="o">=</span> <span class="n">is_tra_val_te</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;&#39;is_tra_val_te&#39; must be one of &#39;train&#39;, &#39;valid&#39; or &#39;test&#39; &quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">train_mode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_tra_val_te</span> <span class="o">==</span> <span class="s2">&quot;train&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t_s_dict</span> <span class="o">=</span> <span class="n">wrap_t_s_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_tra_val_te</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">training_cfgs</span><span class="p">[</span><span class="s2">&quot;hindcast_length&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">warmup_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">training_cfgs</span><span class="p">[</span><span class="s2">&quot;warmup_length&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">horizon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">training_cfgs</span><span class="p">[</span><span class="s2">&quot;forecast_length&quot;</span><span class="p">]</span>
        <span class="n">valid_batch_mode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">training_cfgs</span><span class="p">[</span><span class="s2">&quot;valid_batch_mode&quot;</span><span class="p">]</span>
        <span class="c1"># train + valid with valid_mode is train means we will use the same batch data for train and valid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_new_batch_way</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">is_tra_val_te</span> <span class="o">!=</span> <span class="s2">&quot;valid&quot;</span> <span class="ow">or</span> <span class="n">valid_batch_mode</span> <span class="o">!=</span> <span class="s2">&quot;train&quot;</span>
        <span class="p">)</span> <span class="ow">and</span> <span class="n">is_tra_val_te</span> <span class="o">!=</span> <span class="s2">&quot;train&quot;</span>
        <span class="n">rolling</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluation_cfgs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rolling&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluation_cfgs</span><span class="p">[</span><span class="s2">&quot;hrwin&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hrwin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hrwin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluation_cfgs</span><span class="p">[</span><span class="s2">&quot;hrwin&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluation_cfgs</span><span class="p">[</span><span class="s2">&quot;frwin&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">frwin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">horizon</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">frwin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluation_cfgs</span><span class="p">[</span><span class="s2">&quot;frwin&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">rolling</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">hrwin</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">hrwin</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">hrwin</span>
            <span class="n">frwin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nt</span> <span class="o">-</span> <span class="n">hrwin</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">warmup_length</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_new_batch_way</span><span class="p">:</span>
            <span class="c1"># we will set the batch data for valid and test</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rolling</span> <span class="o">=</span> <span class="n">rolling</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">=</span> <span class="n">hrwin</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">horizon</span> <span class="o">=</span> <span class="n">frwin</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">data_source</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">source_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;source_cfgs&quot;</span><span class="p">][</span><span class="s2">&quot;source_name&quot;</span><span class="p">]</span>
        <span class="n">source_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;source_cfgs&quot;</span><span class="p">][</span><span class="s2">&quot;source_path&quot;</span><span class="p">]</span>

        <span class="c1">#  source_name  source_path </span>

        <span class="c1"># </span>
        <span class="n">other_settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;source_cfgs&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;other_settings&quot;</span><span class="p">,</span> <span class="p">{})</span>

        <span class="c1">#  source_name, source_path</span>
        <span class="n">other_settings</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;source_name&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">other_settings</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;source_path&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">data_sources_dict</span><span class="p">[</span><span class="n">source_name</span><span class="p">](</span><span class="n">source_path</span><span class="p">,</span> <span class="o">**</span><span class="n">other_settings</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">streamflow_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;target_cols&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">precipitation_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;relevant_cols&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ngrid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;How many basins/grids in the dataset</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            number of basins/grids</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basins</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">noutputvar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;How many output variables in the dataset</span>
<span class="sd">        Used in evaluation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            number of variables</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;target_cols&quot;</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;length of longest time series in all basins</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            number of longest time steps</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t_s_dict</span><span class="p">[</span><span class="s2">&quot;t_final_range&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">trange_type_num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t_s_dict</span><span class="p">[</span><span class="s2">&quot;t_final_range&quot;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">trange_type_num</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ngrid</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;The number of time ranges should be equal to the number of basins &quot;</span>
                    <span class="s2">&quot;if you choose different time ranges for different basins&quot;</span>
                <span class="p">)</span>
            <span class="n">earliest_date</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">latest_date</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">start_date_str</span><span class="p">,</span> <span class="n">end_date_str</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_s_dict</span><span class="p">[</span><span class="s2">&quot;t_final_range&quot;</span><span class="p">]:</span>
                <span class="n">date_format</span> <span class="o">=</span> <span class="n">detect_date_format</span><span class="p">(</span><span class="n">start_date_str</span><span class="p">)</span>

                <span class="n">start_date</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">start_date_str</span><span class="p">,</span> <span class="n">date_format</span><span class="p">)</span>
                <span class="n">end_date</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">end_date_str</span><span class="p">,</span> <span class="n">date_format</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">earliest_date</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">start_date</span> <span class="o">&lt;</span> <span class="n">earliest_date</span><span class="p">:</span>
                    <span class="n">earliest_date</span> <span class="o">=</span> <span class="n">start_date</span>
                <span class="k">if</span> <span class="n">latest_date</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">end_date</span> <span class="o">&gt;</span> <span class="n">latest_date</span><span class="p">:</span>
                    <span class="n">latest_date</span> <span class="o">=</span> <span class="n">end_date</span>
            <span class="n">earliest_date</span> <span class="o">=</span> <span class="n">earliest_date</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="n">date_format</span><span class="p">)</span>
            <span class="n">latest_date</span> <span class="o">=</span> <span class="n">latest_date</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="n">date_format</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">trange_type_num</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">earliest_date</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_s_dict</span><span class="p">[</span><span class="s2">&quot;t_final_range&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">latest_date</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_s_dict</span><span class="p">[</span><span class="s2">&quot;t_final_range&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">min_time_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;min_time_unit&quot;</span><span class="p">]</span>
        <span class="n">min_time_interval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;min_time_interval&quot;</span><span class="p">]</span>

        <span class="c1"># </span>
        <span class="n">unit_to_hours</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;h&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="s2">&quot;H&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="s2">&quot;d&quot;</span><span class="p">:</span> <span class="mi">24</span><span class="p">,</span>
            <span class="s2">&quot;D&quot;</span><span class="p">:</span> <span class="mi">24</span><span class="p">,</span>
            <span class="s2">&quot;m&quot;</span><span class="p">:</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">60</span><span class="p">,</span>
            <span class="s2">&quot;M&quot;</span><span class="p">:</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">60</span><span class="p">,</span>
            <span class="s2">&quot;s&quot;</span><span class="p">:</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">3600</span><span class="p">,</span>
            <span class="s2">&quot;S&quot;</span><span class="p">:</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">3600</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">hours_per_step</span> <span class="o">=</span> <span class="n">min_time_interval</span> <span class="o">*</span> <span class="n">unit_to_hours</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">min_time_unit</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># </span>
        <span class="n">date_format</span> <span class="o">=</span> <span class="n">detect_date_format</span><span class="p">(</span>
            <span class="n">earliest_date</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">earliest_date</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span>
            <span class="k">else</span> <span class="n">earliest_date</span>
        <span class="p">)</span>

        <span class="c1"># </span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">earliest_date</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">s_date</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span>
                <span class="n">earliest_date</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">date_format</span>
            <span class="p">)</span>  <span class="c1"># </span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s_date</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">earliest_date</span><span class="p">,</span> <span class="n">date_format</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">latest_date</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">e_date</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span>
                <span class="n">latest_date</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">date_format</span>
            <span class="p">)</span>  <span class="c1"># </span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">e_date</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">latest_date</span><span class="p">,</span> <span class="n">date_format</span><span class="p">)</span>

        <span class="c1"># </span>
        <span class="n">total_hours</span> <span class="o">=</span> <span class="p">(</span><span class="n">e_date</span> <span class="o">-</span> <span class="n">s_date</span><span class="p">)</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span> <span class="o">/</span> <span class="mi">3600</span>

        <span class="c1"># </span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">total_hours</span> <span class="o">/</span> <span class="n">hours_per_step</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">basins</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the basins of the dataset&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_s_dict</span><span class="p">[</span><span class="s2">&quot;sites_id&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">times</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the times of all basins</span>

<span class="sd">        TODO: Although we support get different time ranges for different basins,</span>
<span class="sd">        we didn&#39;t implement the reading function for this case in _read_xyc method.</span>
<span class="sd">        Hence, it&#39;s better to choose unified time range for all basins</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">min_time_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;min_time_unit&quot;</span><span class="p">]</span>
        <span class="n">min_time_interval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;min_time_interval&quot;</span><span class="p">]</span>
        <span class="n">time_step</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">min_time_interval</span><span class="si">}{</span><span class="n">min_time_unit</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t_s_dict</span><span class="p">[</span><span class="s2">&quot;t_final_range&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">times_</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">trange_type_num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t_s_dict</span><span class="p">[</span><span class="s2">&quot;t_final_range&quot;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">trange_type_num</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ngrid</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;The number of time ranges should be equal to the number of basins &quot;</span>
                    <span class="s2">&quot;if you choose different time ranges for different basins&quot;</span>
                <span class="p">)</span>
            <span class="n">detect_date_format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t_s_dict</span><span class="p">[</span><span class="s2">&quot;t_final_range&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">start_date_str</span><span class="p">,</span> <span class="n">end_date_str</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_s_dict</span><span class="p">[</span><span class="s2">&quot;t_final_range&quot;</span><span class="p">]:</span>
                <span class="n">s_date</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">start_date_str</span><span class="p">)</span>
                <span class="n">e_date</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">end_date_str</span><span class="p">)</span>
                <span class="n">time_series</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">s_date</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">e_date</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">time_step</span><span class="p">)</span>
                <span class="n">times_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">time_series</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">detect_date_format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t_s_dict</span><span class="p">[</span><span class="s2">&quot;t_final_range&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">trange_type_num</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">s_date</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t_s_dict</span><span class="p">[</span><span class="s2">&quot;t_final_range&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">e_date</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t_s_dict</span><span class="p">[</span><span class="s2">&quot;t_final_range&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">times_</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">s_date</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">e_date</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">time_step</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">times_</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get one sample from the dataset with a unified return format.</span>

<span class="sd">        Args:</span>
<span class="sd">            item: The index of the sample to retrieve.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A tuple of (input_data, output_data), where input_data is a tensor</span>
<span class="sd">            of input features and output_data is a tensor of target values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">basin</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">actual_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lookup_table</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
        <span class="n">warmup_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">warmup_length</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">basin</span><span class="p">,</span> <span class="n">idx</span> <span class="o">-</span> <span class="n">warmup_length</span> <span class="p">:</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">actual_length</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">basin</span><span class="p">,</span> <span class="n">idx</span> <span class="p">:</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">actual_length</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">(),</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">basin</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">xc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">c</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">xc</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">(),</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_load_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">origin_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_xyc</span><span class="p">()</span>
        <span class="c1"># normalization</span>
        <span class="n">norm_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalize</span><span class="p">(</span><span class="n">origin_data</span><span class="p">)</span>
        <span class="c1">#  NaN </span>
        <span class="n">origin_data_wonan</span><span class="p">,</span> <span class="n">norm_data_wonan</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kill_nan</span><span class="p">(</span><span class="n">origin_data</span><span class="p">,</span> <span class="n">norm_data</span><span class="p">)</span>
        <span class="c1"># origin_data_wonan, norm_data_wonan = origin_data, norm_data  #  NaN </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_trans2nparr</span><span class="p">(</span><span class="n">origin_data_wonan</span><span class="p">,</span> <span class="n">norm_data_wonan</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_lookup_table</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_trans2nparr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin_data</span><span class="p">,</span> <span class="n">norm_data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;To make __getitem__ more efficient,</span>
<span class="sd">        we transform x, y, c to numpy array with shape (nsample, nt, nvar)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">origin_data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">_origin</span> <span class="o">=</span> <span class="n">origin_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="n">_norm</span> <span class="o">=</span> <span class="n">norm_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">_origin</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">_norm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">norm_arr</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">origin_arr</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">norm_arr</span> <span class="o">=</span> <span class="n">_norm</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
                <span class="n">origin_arr</span> <span class="o">=</span> <span class="n">_origin</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;relevant_cols&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">x_origin</span> <span class="o">=</span> <span class="n">origin_arr</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">norm_arr</span>
            <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;target_cols&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">y_origin</span> <span class="o">=</span> <span class="n">origin_arr</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">norm_arr</span>
            <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;constant_cols&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">c_origin</span> <span class="o">=</span> <span class="n">origin_arr</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">norm_arr</span>
            <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;forecast_cols&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">f_origin</span> <span class="o">=</span> <span class="n">origin_arr</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">norm_arr</span>
            <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;global_cols&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">g_origin</span> <span class="o">=</span> <span class="n">origin_arr</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">g</span> <span class="o">=</span> <span class="n">norm_arr</span>
            <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;station_cols&quot;</span><span class="p">:</span>
                <span class="c1"># GNN</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">station_cols_origin</span> <span class="o">=</span> <span class="n">origin_arr</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">station_cols</span> <span class="o">=</span> <span class="n">norm_arr</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Unknown data type </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> in origin_data, &quot;</span>
                    <span class="s2">&quot;it should be one of relevant_cols, target_cols, constant_cols, forecast_cols, global_cols, station_cols&quot;</span>
                <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_normalize</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">origin_data</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;_summary_</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        origin_data : dict</span>
<span class="sd">            data with key as data type</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        _type_</span>
<span class="sd">            _description_</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scaler_hub</span> <span class="o">=</span> <span class="n">ScalerHub</span><span class="p">(</span>
            <span class="n">origin_data</span><span class="p">,</span>
            <span class="n">data_cfgs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">,</span>
            <span class="n">is_tra_val_te</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">is_tra_val_te</span><span class="p">,</span>
            <span class="n">data_source</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_source</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_scaler</span> <span class="o">=</span> <span class="n">scaler_hub</span><span class="o">.</span><span class="n">target_scaler</span>
        <span class="k">return</span> <span class="n">scaler_hub</span><span class="o">.</span><span class="n">norm_data</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_selected_time_points_for_denorm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;get the time points for denormalization</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            a list of time points</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_scaler</span><span class="o">.</span><span class="n">data_target</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">warmup_length</span> <span class="p">:]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">denormalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">norm_data</span><span class="p">,</span> <span class="n">pace_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Denormalize the norm_data</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        norm_data : np.ndarray</span>
<span class="sd">            batch-first data</span>
<span class="sd">        pace_idx : int, optional</span>
<span class="sd">            which pace to show, by default None</span>
<span class="sd">            sometimes we may have multiple results for one time period and we flatten them</span>
<span class="sd">            so we need a temp time to replace real one</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xr.Dataset</span>
<span class="sd">            denormlized data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">target_scaler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_scaler</span>
        <span class="n">target_data</span> <span class="o">=</span> <span class="n">target_scaler</span><span class="o">.</span><span class="n">data_target</span>
        <span class="c1"># the units are dimensionless for pure DL models</span>
        <span class="n">units</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="s2">&quot;dimensionless&quot;</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">target_data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;units&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
        <span class="c1"># mainly to get information about the time points of norm_data</span>
        <span class="n">selected_time_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selected_time_points_for_denorm</span><span class="p">()</span>
        <span class="n">selected_data</span> <span class="o">=</span> <span class="n">target_data</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="n">selected_time_points</span><span class="p">)</span>

        <span class="c1">#  (basin, time, variable)</span>
        <span class="k">if</span> <span class="n">norm_data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;basin&quot;</span><span class="p">:</span> <span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;basin&quot;</span><span class="p">],</span>
                <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">],</span>
                <span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">],</span>
            <span class="p">}</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;basin&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;variable&quot;</span><span class="p">]</span>
            <span class="c1"># add</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">selected_time_points</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">):</span>
                <span class="c1">#  target_data </span>
                <span class="n">time_coords</span> <span class="o">=</span> <span class="n">target_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
                <span class="c1">#  selected_time_points </span>
                <span class="n">selected_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">time_coords</span><span class="p">,</span> <span class="n">selected_time_points</span><span class="p">))[</span>
                    <span class="mi">0</span>
                <span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#  selected_time_points </span>
                <span class="n">selected_indices</span> <span class="o">=</span> <span class="n">selected_time_points</span>

            <span class="c1"># </span>
            <span class="n">max_idx</span> <span class="o">=</span> <span class="n">norm_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">selected_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">selected_indices</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">max_idx</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">norm_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]):</span>
                <span class="n">norm_data_3d</span> <span class="o">=</span> <span class="n">norm_data</span><span class="p">[:,</span> <span class="n">selected_indices</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">norm_data_3d</span> <span class="o">=</span> <span class="n">norm_data</span>

        <span class="c1"># </span>
        <span class="k">elif</span> <span class="n">norm_data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="c1"># Check if the data is organized by basins</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluation_cfgs</span><span class="p">[</span><span class="s2">&quot;evaluator&quot;</span><span class="p">][</span><span class="s2">&quot;recover_mode&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;bybasins&quot;</span><span class="p">:</span>
                <span class="c1"># Shape: (basin_num, i_e_time_length, forecast_length, nf)</span>
                <span class="n">basin_num</span><span class="p">,</span> <span class="n">i_e_time_length</span><span class="p">,</span> <span class="n">forecast_length</span><span class="p">,</span> <span class="n">nf</span> <span class="o">=</span> <span class="n">norm_data</span><span class="o">.</span><span class="n">shape</span>

                <span class="c1"># If pace_idx is specified, select the specific forecast step</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">pace_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                    <span class="ow">and</span> <span class="n">pace_idx</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="ow">and</span> <span class="n">pace_idx</span> <span class="o">&gt;=</span> <span class="mi">0</span>
                    <span class="ow">and</span> <span class="n">pace_idx</span> <span class="o">&lt;</span> <span class="n">forecast_length</span>
                <span class="p">):</span>
                    <span class="n">norm_data_3d</span> <span class="o">=</span> <span class="n">norm_data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">pace_idx</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="c1"># </span>
                    <span class="c1"># basin</span>
                    <span class="k">if</span> <span class="n">basin_num</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;basin&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="c1"># </span>
                        <span class="n">basin_coord</span> <span class="o">=</span> <span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;basin&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">basin_coord</span> <span class="o">=</span> <span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;basin&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[:</span><span class="n">basin_num</span><span class="p">]</span>

                    <span class="n">coords</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="s2">&quot;basin&quot;</span><span class="p">:</span> <span class="n">basin_coord</span><span class="p">,</span>
                        <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">][:</span><span class="n">i_e_time_length</span><span class="p">],</span>
                        <span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">],</span>
                    <span class="p">}</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># pace_idx&#39;horizon&#39;</span>
                    <span class="n">norm_data_3d</span> <span class="o">=</span> <span class="n">norm_data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                        <span class="n">basin_num</span><span class="p">,</span> <span class="n">i_e_time_length</span> <span class="o">*</span> <span class="n">forecast_length</span><span class="p">,</span> <span class="n">nf</span>
                    <span class="p">)</span>
                    <span class="c1"># i_e_time_length</span>
                    <span class="n">new_times</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">forecast_length</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]):</span>
                            <span class="n">new_times</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                                <span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">][:</span><span class="n">i_e_time_length</span><span class="p">]</span>
                            <span class="p">)</span>

                    <span class="c1"># </span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_times</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">i_e_time_length</span> <span class="o">*</span> <span class="n">forecast_length</span><span class="p">:</span>
                        <span class="n">new_times</span> <span class="o">=</span> <span class="n">new_times</span><span class="p">[:</span> <span class="n">i_e_time_length</span> <span class="o">*</span> <span class="n">forecast_length</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_times</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">i_e_time_length</span> <span class="o">*</span> <span class="n">forecast_length</span><span class="p">:</span>
                        <span class="c1"># </span>
                        <span class="n">last_time</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">new_times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                            <span class="k">if</span> <span class="n">new_times</span>
                            <span class="k">else</span> <span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="p">)</span>
                        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_times</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">i_e_time_length</span> <span class="o">*</span> <span class="n">forecast_length</span><span class="p">:</span>
                            <span class="n">new_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">last_time</span><span class="p">)</span>

                    <span class="c1"># basin</span>
                    <span class="k">if</span> <span class="n">basin_num</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;basin&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">basin_coord</span> <span class="o">=</span> <span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;basin&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">basin_coord</span> <span class="o">=</span> <span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;basin&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[:</span><span class="n">basin_num</span><span class="p">]</span>

                    <span class="n">coords</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="s2">&quot;basin&quot;</span><span class="p">:</span> <span class="n">basin_coord</span><span class="p">,</span>
                        <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">new_times</span><span class="p">,</span>
                        <span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">],</span>
                    <span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># byforecast</span>
                <span class="c1">#  (forecast_length, basin_num, i_e_time_length, nf)</span>
                <span class="n">forecast_length</span><span class="p">,</span> <span class="n">basin_num</span><span class="p">,</span> <span class="n">i_e_time_length</span><span class="p">,</span> <span class="n">nf</span> <span class="o">=</span> <span class="n">norm_data</span><span class="o">.</span><span class="n">shape</span>

                <span class="c1"># pace_idx</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">pace_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                    <span class="ow">and</span> <span class="n">pace_idx</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="ow">and</span> <span class="n">pace_idx</span> <span class="o">&gt;=</span> <span class="mi">0</span>
                    <span class="ow">and</span> <span class="n">pace_idx</span> <span class="o">&lt;</span> <span class="n">forecast_length</span>
                <span class="p">):</span>
                    <span class="n">norm_data_3d</span> <span class="o">=</span> <span class="n">norm_data</span><span class="p">[</span><span class="n">pace_idx</span><span class="p">]</span>
                    <span class="c1"># basin</span>
                    <span class="k">if</span> <span class="n">basin_num</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;basin&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">basin_coord</span> <span class="o">=</span> <span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;basin&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">basin_coord</span> <span class="o">=</span> <span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;basin&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[:</span><span class="n">basin_num</span><span class="p">]</span>

                    <span class="n">coords</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="s2">&quot;basin&quot;</span><span class="p">:</span> <span class="n">basin_coord</span><span class="p">,</span>
                        <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">][:</span><span class="n">i_e_time_length</span><span class="p">],</span>
                        <span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">],</span>
                    <span class="p">}</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># If pace_idx is not specified, create a new dimension &#39;horizon&#39;</span>
                    <span class="c1"># Reshape (forecast_length, basin_num, i_e_time_length, nf) -&gt; (basin_num, forecast_length * i_e_time_length, nf)</span>
                    <span class="n">norm_data_3d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">norm_data</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                        <span class="n">basin_num</span><span class="p">,</span> <span class="n">forecast_length</span> <span class="o">*</span> <span class="n">i_e_time_length</span><span class="p">,</span> <span class="n">nf</span>
                    <span class="p">)</span>

                    <span class="c1"># </span>
                    <span class="n">new_times</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">forecast_length</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]):</span>
                            <span class="n">new_times</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                                <span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">][:</span><span class="n">i_e_time_length</span><span class="p">]</span>
                            <span class="p">)</span>

                    <span class="c1"># </span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_times</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">forecast_length</span> <span class="o">*</span> <span class="n">i_e_time_length</span><span class="p">:</span>
                        <span class="n">new_times</span> <span class="o">=</span> <span class="n">new_times</span><span class="p">[:</span> <span class="n">forecast_length</span> <span class="o">*</span> <span class="n">i_e_time_length</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_times</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">forecast_length</span> <span class="o">*</span> <span class="n">i_e_time_length</span><span class="p">:</span>
                        <span class="c1"># </span>
                        <span class="n">last_time</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">new_times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                            <span class="k">if</span> <span class="n">new_times</span>
                            <span class="k">else</span> <span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="p">)</span>
                        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_times</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">forecast_length</span> <span class="o">*</span> <span class="n">i_e_time_length</span><span class="p">:</span>
                            <span class="n">new_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">last_time</span><span class="p">)</span>

                    <span class="c1"># basin</span>
                    <span class="k">if</span> <span class="n">basin_num</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;basin&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">basin_coord</span> <span class="o">=</span> <span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;basin&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">basin_coord</span> <span class="o">=</span> <span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;basin&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[:</span><span class="n">basin_num</span><span class="p">]</span>

                    <span class="n">coords</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="s2">&quot;basin&quot;</span><span class="p">:</span> <span class="n">basin_coord</span><span class="p">,</span>
                        <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">new_times</span><span class="p">,</span>
                        <span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">],</span>
                    <span class="p">}</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;basin&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;variable&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="n">selected_data</span><span class="o">.</span><span class="n">dims</span>
            <span class="n">norm_data_3d</span> <span class="o">=</span> <span class="n">norm_data</span>

        <span class="c1"># create DataArray and inverse transform</span>
        <span class="n">denorm_xr_ds</span> <span class="o">=</span> <span class="n">target_scaler</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span>
            <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
                <span class="n">norm_data_3d</span><span class="p">,</span>
                <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span>
                <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span>
                <span class="n">attrs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;units&quot;</span><span class="p">:</span> <span class="n">units</span><span class="p">},</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">set_unit_to_var</span><span class="p">(</span><span class="n">denorm_xr_ds</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_to_dataarray_with_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert xarray datasets to xarray data arrays and set units for each variable.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        *args : xr.Dataset</span>
<span class="sd">            Any number of xarray dataset inputs.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            A tuple of converted data arrays, with the same number as the input parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ds</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># First convert some string-type data to floating-point type</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_trans2da_and_setunits</span><span class="p">(</span><span class="n">ds</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_ts_xrds_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_forcing_ds</span><span class="p">,</span> <span class="n">data_output_ds</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check timeseries xarray dataset unit and convert if necessary</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data_forcing_ds : xr.Dataset</span>
<span class="sd">            the forcing data</span>
<span class="sd">        data_output_ds : xr.Dataset</span>
<span class="sd">            outputs including streamflow data</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">standardize_unit</span><span class="p">(</span><span class="n">unit</span><span class="p">):</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="n">unit</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>  <span class="c1"># convert to lower case</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;day&quot;</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;hour&quot;</span><span class="p">,</span> <span class="s2">&quot;h&quot;</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">unit</span>

        <span class="n">streamflow_unit</span> <span class="o">=</span> <span class="n">data_output_ds</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">streamflow_name</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;units&quot;</span><span class="p">]</span>
        <span class="n">prcp_unit</span> <span class="o">=</span> <span class="n">data_forcing_ds</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">precipitation_name</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;units&quot;</span><span class="p">]</span>

        <span class="n">standardized_streamflow_unit</span> <span class="o">=</span> <span class="n">standardize_unit</span><span class="p">(</span><span class="n">streamflow_unit</span><span class="p">)</span>
        <span class="n">standardized_prcp_unit</span> <span class="o">=</span> <span class="n">standardize_unit</span><span class="p">(</span><span class="n">prcp_unit</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">standardized_streamflow_unit</span> <span class="o">!=</span> <span class="n">standardized_prcp_unit</span><span class="p">:</span>
            <span class="n">streamflow_dataset</span> <span class="o">=</span> <span class="n">data_output_ds</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">streamflow_name</span><span class="p">]]</span>
            <span class="n">converted_streamflow_dataset</span> <span class="o">=</span> <span class="n">streamflow_unit_conv</span><span class="p">(</span>
                <span class="n">streamflow_dataset</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data_source</span><span class="o">.</span><span class="n">read_area</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t_s_dict</span><span class="p">[</span><span class="s2">&quot;sites_id&quot;</span><span class="p">]),</span>
                <span class="n">target_unit</span><span class="o">=</span><span class="n">prcp_unit</span><span class="p">,</span>
                <span class="n">source_unit</span><span class="o">=</span><span class="n">streamflow_unit</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">data_output_ds</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">streamflow_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">converted_streamflow_dataset</span><span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">streamflow_name</span>
            <span class="p">]</span>
        <span class="k">return</span> <span class="n">data_forcing_ds</span><span class="p">,</span> <span class="n">data_output_ds</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_read_xyc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read x, y, c data from data source</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            data with key as data type</span>
<span class="sd">            the dim must be (basin, time, lead_step, variable) for 4-d xr array;</span>
<span class="sd">            the dim must be (basin, time, variable) for 3-d xr array;</span>
<span class="sd">            the dim must be (basin, variable) for 2-d xr array;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check if we have multiple time periods (for multi-period training)</span>
        <span class="n">t_range</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_s_dict</span><span class="p">[</span><span class="s2">&quot;t_final_range&quot;</span><span class="p">]</span>

        <span class="c1"># Check if first element is a list/tuple (indicating multiple periods)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="c1"># Validate multi-period format</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_validate_multi_period_format</span><span class="p">(</span><span class="n">t_range</span><span class="p">)</span>

            <span class="c1"># Multiple periods case - can be any number of periods</span>
            <span class="n">all_data</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">start_date</span><span class="p">,</span> <span class="n">end_date</span> <span class="ow">in</span> <span class="n">t_range</span><span class="p">:</span>
                <span class="n">period_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_xyc_period</span><span class="p">(</span><span class="n">start_date</span><span class="p">,</span> <span class="n">end_date</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">all_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">all_data</span> <span class="o">=</span> <span class="n">period_data</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Concatenate along time dimension</span>
                    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">period_data</span><span class="p">:</span>
                        <span class="c1"># </span>
                        <span class="k">if</span> <span class="n">all_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">period_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">all_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
                                <span class="n">all_data</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">all_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">period_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
                                <span class="n">period_data</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">period_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                                    <span class="nb">str</span>
                                <span class="p">)</span>

                            <span class="n">all_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
                                <span class="p">[</span><span class="n">all_data</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">period_data</span><span class="p">[</span><span class="n">key</span><span class="p">]],</span> <span class="n">dim</span><span class="o">=</span><span class="s2">&quot;time&quot;</span>
                            <span class="p">)</span>
            <span class="k">return</span> <span class="n">all_data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Single period case (existing behavior)</span>
            <span class="n">start_date</span> <span class="o">=</span> <span class="n">t_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">end_date</span> <span class="o">=</span> <span class="n">t_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_xyc_period</span><span class="p">(</span><span class="n">start_date</span><span class="p">,</span> <span class="n">end_date</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_read_xyc_period</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_date</span><span class="p">,</span> <span class="n">end_date</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Template method for reading x, y, c data for a specific time period</span>

<span class="sd">        This method can be overridden by subclasses to customize how data is read</span>
<span class="sd">        for each time period while keeping the multi-period handling logic in the parent class.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start_date : str</span>
<span class="sd">            start time</span>
<span class="sd">        end_date : str</span>
<span class="sd">            end time</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary containing relevant_cols, target_cols, and constant_cols data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Default implementation: delegate to the original method</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_xyc_specified_time</span><span class="p">(</span><span class="n">start_date</span><span class="p">,</span> <span class="n">end_date</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_validate_multi_period_format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t_range</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validate format of multi-period time ranges</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        t_range : list</span>
<span class="sd">            List of time periods, where each period should be [start_date, end_date]</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any period doesn&#39;t have exactly 2 elements (start_date, end_date)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">period</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">t_range</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">period</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">period</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Period </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> must be a list/tuple with exactly 2 elements (start_date, end_date), got: </span><span class="si">{</span><span class="n">period</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_rm_timeunit_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ds_</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;this means the data source return a dict with key as time_unit</span>
<span class="sd">            in this BaseDataset, we only support unified time range for all basins, so we chose the first key</span>
<span class="sd">            TODO: maybe this could be refactored better</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ds_ : dict</span>
<span class="sd">            the xarray data with time_unit as key</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        ds_ : xr.Dataset</span>
<span class="sd">            the output data without time_unit</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ds_</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">ds_</span> <span class="o">=</span> <span class="n">ds_</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">ds_</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">return</span> <span class="n">ds_</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_read_xyc_specified_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_date</span><span class="p">,</span> <span class="n">end_date</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read x, y, c data from data source with specified time range</span>
<span class="sd">        We set this function as sometimes we need adjust the time range for some specific dataset,</span>
<span class="sd">        such as seq2seq dataset (it needs one more period for the end of the time range)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start_date : str</span>
<span class="sd">            start time</span>
<span class="sd">        end_date : str</span>
<span class="sd">            end time</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data_forcing_ds_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_source</span><span class="o">.</span><span class="n">read_ts_xrdataset</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">t_s_dict</span><span class="p">[</span><span class="s2">&quot;sites_id&quot;</span><span class="p">],</span>
            <span class="p">[</span><span class="n">start_date</span><span class="p">,</span> <span class="n">end_date</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;relevant_cols&quot;</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="c1"># y</span>
        <span class="n">data_output_ds_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_source</span><span class="o">.</span><span class="n">read_ts_xrdataset</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">t_s_dict</span><span class="p">[</span><span class="s2">&quot;sites_id&quot;</span><span class="p">],</span>
            <span class="p">[</span><span class="n">start_date</span><span class="p">,</span> <span class="n">end_date</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;target_cols&quot;</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">data_output_ds_</span><span class="p">)</span>
        <span class="n">data_forcing_ds_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rm_timeunit_key</span><span class="p">(</span><span class="n">data_forcing_ds_</span><span class="p">)</span>
        <span class="n">data_output_ds_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rm_timeunit_key</span><span class="p">(</span><span class="n">data_output_ds_</span><span class="p">)</span>
        <span class="n">data_forcing_ds</span><span class="p">,</span> <span class="n">data_output_ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_ts_xrds_unit</span><span class="p">(</span>
            <span class="n">data_forcing_ds_</span><span class="p">,</span> <span class="n">data_output_ds_</span>
        <span class="p">)</span>
        <span class="c1"># c</span>
        <span class="n">data_attr_ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_source</span><span class="o">.</span><span class="n">read_attr_xrdataset</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">t_s_dict</span><span class="p">[</span><span class="s2">&quot;sites_id&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;constant_cols&quot;</span><span class="p">],</span>
            <span class="n">all_number</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">x_origin</span><span class="p">,</span> <span class="n">y_origin</span><span class="p">,</span> <span class="n">c_origin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_dataarray_with_unit</span><span class="p">(</span>
            <span class="n">data_forcing_ds</span><span class="p">,</span> <span class="n">data_output_ds</span><span class="p">,</span> <span class="n">data_attr_ds</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;relevant_cols&quot;</span><span class="p">:</span> <span class="n">x_origin</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;basin&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;variable&quot;</span><span class="p">),</span>
            <span class="s2">&quot;target_cols&quot;</span><span class="p">:</span> <span class="n">y_origin</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;basin&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;variable&quot;</span><span class="p">),</span>
            <span class="s2">&quot;constant_cols&quot;</span><span class="p">:</span> <span class="p">(</span>
                <span class="n">c_origin</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;basin&quot;</span><span class="p">,</span> <span class="s2">&quot;variable&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">c_origin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="k">else</span> <span class="kc">None</span>
            <span class="p">),</span>
        <span class="p">}</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_trans2da_and_setunits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ds</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set units for dataarray transfromed from dataset&quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">to_array</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;variable&quot;</span><span class="p">)</span>
        <span class="n">units_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">var</span><span class="p">:</span> <span class="n">ds</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;units&quot;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">variables</span>
            <span class="k">if</span> <span class="s2">&quot;units&quot;</span> <span class="ow">in</span> <span class="n">ds</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span>
        <span class="p">}</span>
        <span class="n">result</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;units&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">units_dict</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_kill_nan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin_data</span><span class="p">,</span> <span class="n">norm_data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function is used to remove NaN values in the original data and its normalized data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        origin_data : dict</span>
<span class="sd">            the original data</span>
<span class="sd">        norm_data : dict</span>
<span class="sd">            the normalized data</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict, dict</span>
<span class="sd">            the original data and normalized data after removing NaN values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data_cfgs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span>
        <span class="n">origins_wonan</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">norms_wonan</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">origin_data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">_origin</span> <span class="o">=</span> <span class="n">origin_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="n">_norm</span> <span class="o">=</span> <span class="n">norm_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">_origin</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">_norm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">origins_wonan</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">norms_wonan</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">continue</span>
            <span class="n">kill_way</span> <span class="o">=</span> <span class="s2">&quot;interpolate&quot;</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;relevant_cols&quot;</span><span class="p">:</span>
                <span class="n">rm_nan</span> <span class="o">=</span> <span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;relevant_rm_nan&quot;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;target_cols&quot;</span><span class="p">:</span>
                <span class="n">rm_nan</span> <span class="o">=</span> <span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;target_rm_nan&quot;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;constant_cols&quot;</span><span class="p">:</span>
                <span class="n">rm_nan</span> <span class="o">=</span> <span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;constant_rm_nan&quot;</span><span class="p">]</span>
                <span class="n">kill_way</span> <span class="o">=</span> <span class="s2">&quot;mean&quot;</span>
            <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;forecast_cols&quot;</span><span class="p">:</span>
                <span class="n">rm_nan</span> <span class="o">=</span> <span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;forecast_rm_nan&quot;</span><span class="p">]</span>
                <span class="n">kill_way</span> <span class="o">=</span> <span class="s2">&quot;lead_step&quot;</span>
            <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;global_cols&quot;</span><span class="p">:</span>
                <span class="n">rm_nan</span> <span class="o">=</span> <span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;global_rm_nan&quot;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;station_cols&quot;</span><span class="p">:</span>
                <span class="n">rm_nan</span> <span class="o">=</span> <span class="n">data_cfgs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;station_rm_nan&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Unknown data type </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> in origin_data, &quot;</span>
                    <span class="s2">&quot;it should be one of relevant_cols, target_cols, constant_cols, forecast_cols, global_cols and station_cols&quot;</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">rm_nan</span><span class="p">:</span>
                <span class="n">norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kill_1type_nan</span><span class="p">(</span>
                    <span class="n">_norm</span><span class="p">,</span>
                    <span class="n">kill_way</span><span class="p">,</span>
                    <span class="s2">&quot;original data&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;nan_filled data&quot;</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">origin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kill_1type_nan</span><span class="p">(</span>
                    <span class="n">_origin</span><span class="p">,</span>
                    <span class="n">kill_way</span><span class="p">,</span>
                    <span class="s2">&quot;original data&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;nan_filled data&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">norm</span> <span class="o">=</span> <span class="n">_norm</span>
                <span class="n">origin</span> <span class="o">=</span> <span class="n">_origin</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;target_cols&quot;</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">rm_nan</span><span class="p">:</span>
                <span class="n">warn_if_nan</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">nan_mode</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="n">data_name</span><span class="o">=</span><span class="s2">&quot;nan_filled target data&quot;</span><span class="p">)</span>
                <span class="n">warn_if_nan</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">nan_mode</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="n">data_name</span><span class="o">=</span><span class="s2">&quot;nan_filled target data&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warn_if_nan</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">nan_mode</span><span class="o">=</span><span class="s2">&quot;any&quot;</span><span class="p">,</span> <span class="n">data_name</span><span class="o">=</span><span class="s2">&quot;nan_filled input data&quot;</span><span class="p">)</span>
                <span class="n">warn_if_nan</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">nan_mode</span><span class="o">=</span><span class="s2">&quot;any&quot;</span><span class="p">,</span> <span class="n">data_name</span><span class="o">=</span><span class="s2">&quot;nan_filled input data&quot;</span><span class="p">)</span>
            <span class="n">origins_wonan</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">origin</span>
            <span class="n">norms_wonan</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">norm</span>
        <span class="k">return</span> <span class="n">origins_wonan</span><span class="p">,</span> <span class="n">norms_wonan</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_kill_1type_nan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">the_data</span><span class="p">,</span> <span class="n">fill_nan</span><span class="p">,</span> <span class="n">data_name_before</span><span class="p">,</span> <span class="n">data_name_after</span><span class="p">):</span>
        <span class="n">is_any_nan</span> <span class="o">=</span> <span class="n">warn_if_nan</span><span class="p">(</span><span class="n">the_data</span><span class="p">,</span> <span class="n">data_name</span><span class="o">=</span><span class="n">data_name_before</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_any_nan</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">the_data</span>
        <span class="c1"># As input, we cannot have NaN values</span>
        <span class="n">the_filled_data</span> <span class="o">=</span> <span class="n">_fill_gaps_da</span><span class="p">(</span><span class="n">the_data</span><span class="p">,</span> <span class="n">fill_nan</span><span class="o">=</span><span class="n">fill_nan</span><span class="p">)</span>
        <span class="n">warn_if_nan</span><span class="p">(</span><span class="n">the_filled_data</span><span class="p">,</span> <span class="n">data_name</span><span class="o">=</span><span class="n">data_name_after</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">the_filled_data</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_create_lookup_table</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">lookup</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># list to collect basins ids of basins without a single training sample</span>
        <span class="n">basin_coordinates</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t_s_dict</span><span class="p">[</span><span class="s2">&quot;sites_id&quot;</span><span class="p">])</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span>
        <span class="n">warmup_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">warmup_length</span>
        <span class="n">horizon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">horizon</span>
        <span class="c1"># NOTE: we set seq_len to rho + horizon instead of warmup_length + rho + horizon</span>
        <span class="n">seq_len</span> <span class="o">=</span> <span class="n">rho</span> <span class="o">+</span> <span class="n">horizon</span>
        <span class="n">max_time_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nt</span>
        <span class="n">variable_length_cfgs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">training_cfgs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;variable_length_cfgs&quot;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="n">use_variable_length</span> <span class="o">=</span> <span class="n">variable_length_cfgs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;use_variable_length&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">variable_length_type</span> <span class="o">=</span> <span class="n">variable_length_cfgs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="s2">&quot;variable_length_type&quot;</span><span class="p">,</span> <span class="s2">&quot;dynamic&quot;</span>
        <span class="p">)</span>  <span class="c1"># only used for case when use_variable_length is True</span>
        <span class="n">fixed_lengths</span> <span class="o">=</span> <span class="n">variable_length_cfgs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;fixed_lengths&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">365</span><span class="p">,</span> <span class="mi">1095</span><span class="p">,</span> <span class="mi">1825</span><span class="p">])</span>
        <span class="c1"># Use fixed type variable length if enabled and type is fixed</span>
        <span class="n">is_fixed_length_train</span> <span class="o">=</span> <span class="n">use_variable_length</span> <span class="ow">and</span> <span class="n">variable_length_type</span> <span class="o">==</span> <span class="s2">&quot;fixed&quot;</span>
        <span class="k">for</span> <span class="n">basin</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">basin_coordinates</span><span class="p">),</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">,</span> <span class="n">disable</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">train_mode</span><span class="p">:</span>
                <span class="c1"># we don&#39;t need to ignore those with full nan in target vars for prediction without loss calculation</span>
                <span class="c1"># all samples should be included so that we can recover results to specified basins easily</span>
                <span class="n">lookup</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">basin</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">seq_len</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">warmup_length</span><span class="p">,</span> <span class="n">max_time_length</span> <span class="o">-</span> <span class="n">rho</span> <span class="o">-</span> <span class="n">horizon</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># some dataloader load data with warmup period, so leave some periods for it</span>
                <span class="c1"># [warmup_len] -&gt; time_start -&gt; [rho] -&gt; [horizon]</span>
                <span class="c1">#                       window: \-----------------/ meaning rho + horizon</span>
                <span class="n">nan_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">basin</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span>
                <span class="k">if</span> <span class="n">is_fixed_length_train</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">window</span> <span class="ow">in</span> <span class="n">fixed_lengths</span><span class="p">:</span>
                        <span class="n">lookup</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                            <span class="p">(</span><span class="n">basin</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">window</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span>
                                <span class="n">warmup_length</span><span class="p">,</span>
                                <span class="n">max_time_length</span> <span class="o">-</span> <span class="n">window</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                            <span class="p">)</span>
                            <span class="c1"># if all nan in window, we skip this sample</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">nan_array</span><span class="p">[</span><span class="n">f</span> <span class="p">:</span> <span class="n">f</span> <span class="o">+</span> <span class="n">window</span><span class="p">])</span>
                        <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">lookup</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">basin</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">seq_len</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span>
                            <span class="n">warmup_length</span><span class="p">,</span> <span class="n">max_time_length</span> <span class="o">-</span> <span class="n">rho</span> <span class="o">-</span> <span class="n">horizon</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="p">)</span>
                        <span class="c1"># if all nan in rho + horizon window, we skip this sample</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">nan_array</span><span class="p">[</span><span class="n">f</span> <span class="p">:</span> <span class="n">f</span> <span class="o">+</span> <span class="n">rho</span> <span class="o">+</span> <span class="n">horizon</span><span class="p">])</span>
                    <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lookup_table</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">lookup</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lookup_table</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_create_multi_len_lookup_table</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a lookup table for multi-length training</span>
<span class="sd">        TODO: not fully tested</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lookup</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># list to collect basins ids of basins without a single training sample</span>
        <span class="n">basin_coordinates</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t_s_dict</span><span class="p">[</span><span class="s2">&quot;sites_id&quot;</span><span class="p">])</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span>
        <span class="n">warmup_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">warmup_length</span>
        <span class="n">horizon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">horizon</span>
        <span class="n">seq_len</span> <span class="o">=</span> <span class="n">warmup_length</span> <span class="o">+</span> <span class="n">rho</span> <span class="o">+</span> <span class="n">horizon</span>
        <span class="n">max_time_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nt</span>
        <span class="n">variable_length_cfgs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">training_cfgs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;variable_length_cfgs&quot;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="n">use_variable_length</span> <span class="o">=</span> <span class="n">variable_length_cfgs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;use_variable_length&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">variable_length_type</span> <span class="o">=</span> <span class="n">variable_length_cfgs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="s2">&quot;variable_length_type&quot;</span><span class="p">,</span> <span class="s2">&quot;dynamic&quot;</span>
        <span class="p">)</span>
        <span class="n">fixed_lengths</span> <span class="o">=</span> <span class="n">variable_length_cfgs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;fixed_lengths&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">365</span><span class="p">,</span> <span class="mi">1095</span><span class="p">,</span> <span class="mi">1825</span><span class="p">])</span>
        <span class="c1"># Use fixed type variable length if enabled and type is fixed</span>
        <span class="n">is_fixed_length_train</span> <span class="o">=</span> <span class="n">use_variable_length</span> <span class="ow">and</span> <span class="n">variable_length_type</span> <span class="o">==</span> <span class="s2">&quot;fixed&quot;</span>

        <span class="c1"># lookup</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lookup_tables_by_length</span> <span class="o">=</span> <span class="p">{</span><span class="n">length</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">length</span> <span class="ow">in</span> <span class="n">fixed_lengths</span><span class="p">}</span>

        <span class="c1"># New: Global lookup table to map a single index to (window_length, index_within_that_window_length_table)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">global_lookup_table_indices</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">basin</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">basin_coordinates</span><span class="p">),</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">,</span> <span class="n">disable</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">train_mode</span><span class="p">:</span>
                <span class="c1"># For prediction, we still use the original rho for simplicity if multi_length_training is enabled</span>
                <span class="c1"># or we can extend this logic to support multi-length prediction if needed.</span>
                <span class="c1"># For now, let&#39;s assume prediction uses a fixed rho or is handled differently.</span>
                <span class="c1"># If multi_length_training is active, we might need to decide which window_len to use for prediction.</span>
                <span class="c1"># For now, let&#39;s stick to the original logic for train_mode=False</span>
                <span class="n">lookup</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">basin</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">seq_len</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">warmup_length</span><span class="p">,</span> <span class="n">max_time_length</span> <span class="o">-</span> <span class="n">rho</span> <span class="o">-</span> <span class="n">horizon</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># some dataloader load data with warmup period, so leave some periods for it</span>
                <span class="c1"># [warmup_len] -&gt; time_start -&gt; [rho] -&gt; [horizon]</span>
                <span class="n">nan_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">basin</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span>
                <span class="k">if</span> <span class="n">is_fixed_length_train</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">window</span> <span class="ow">in</span> <span class="n">fixed_lengths</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span>
                            <span class="n">warmup_length</span><span class="p">,</span> <span class="n">max_time_length</span> <span class="o">-</span> <span class="n">window</span> <span class="o">-</span> <span class="n">horizon</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="p">):</span>
                            <span class="c1"># nan</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">nan_array</span><span class="p">[</span><span class="n">f</span> <span class="o">+</span> <span class="n">window</span> <span class="p">:</span> <span class="n">f</span> <span class="o">+</span> <span class="n">window</span> <span class="o">+</span> <span class="n">horizon</span><span class="p">]):</span>
                                <span class="c1">#  (basin, )  lookup table</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">lookup_tables_by_length</span><span class="p">[</span><span class="n">window</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">basin</span><span class="p">,</span> <span class="n">f</span><span class="p">))</span>
                                <span class="c1">#  (,  lookup table ) </span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">global_lookup_table_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                    <span class="p">(</span>
                                        <span class="n">window</span><span class="p">,</span>
                                        <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lookup_tables_by_length</span><span class="p">[</span><span class="n">window</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                                    <span class="p">)</span>
                                <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">lookup</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">basin</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">seq_len</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span>
                            <span class="n">warmup_length</span><span class="p">,</span> <span class="n">max_time_length</span> <span class="o">-</span> <span class="n">rho</span> <span class="o">-</span> <span class="n">horizon</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="p">)</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">nan_array</span><span class="p">[</span><span class="n">f</span> <span class="o">+</span> <span class="n">rho</span> <span class="p">:</span> <span class="n">f</span> <span class="o">+</span> <span class="n">rho</span> <span class="o">+</span> <span class="n">horizon</span><span class="p">])</span>
                    <span class="p">)</span>

        <span class="k">if</span> <span class="n">is_fixed_length_train</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">train_mode</span><span class="p">:</span>
            <span class="c1"># If fixed-length training is enabled and in train mode, use the global lookup table</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lookup_table</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">global_lookup_table_indices</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">global_lookup_table_indices</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Otherwise, use the original lookup table (for fixed length training or prediction)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lookup_table</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">lookup</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lookup_table</span><span class="p">)</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">






  <div class="doc doc-object doc-attribute">



<h4 id="torchhydro.datasets.data_sets.BaseDataset.basins" class="doc doc-heading">
<code class="highlight language-python"><span class="n">basins</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-property"><code>property</code></small>
      <small class="doc doc-property doc-property-readonly"><code>readonly</code></small>
  </span>

<a href="#torchhydro.datasets.data_sets.BaseDataset.basins" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">

      <p>Return the basins of the dataset</p>
    </div>

  </div>




  <div class="doc doc-object doc-attribute">



<h4 id="torchhydro.datasets.data_sets.BaseDataset.ngrid" class="doc doc-heading">
<code class="highlight language-python"><span class="n">ngrid</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-property"><code>property</code></small>
      <small class="doc doc-property doc-property-readonly"><code>readonly</code></small>
  </span>

<a href="#torchhydro.datasets.data_sets.BaseDataset.ngrid" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">

      <p>How many basins/grids in the dataset</p>
<h6 id="torchhydro.datasets.data_sets.BaseDataset.ngrid--returns">Returns<a class="headerlink" href="#torchhydro.datasets.data_sets.BaseDataset.ngrid--returns" title="Permanent link">&para;</a></h6>
<p>int
    number of basins/grids</p>
    </div>

  </div>



  <div class="doc doc-object doc-attribute">



<h4 id="torchhydro.datasets.data_sets.BaseDataset.noutputvar" class="doc doc-heading">
<code class="highlight language-python"><span class="n">noutputvar</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-property"><code>property</code></small>
      <small class="doc doc-property doc-property-readonly"><code>readonly</code></small>
  </span>

<a href="#torchhydro.datasets.data_sets.BaseDataset.noutputvar" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">

      <p>How many output variables in the dataset
Used in evaluation.</p>
<h6 id="torchhydro.datasets.data_sets.BaseDataset.noutputvar--returns">Returns<a class="headerlink" href="#torchhydro.datasets.data_sets.BaseDataset.noutputvar--returns" title="Permanent link">&para;</a></h6>
<p>int
    number of variables</p>
    </div>

  </div>



  <div class="doc doc-object doc-attribute">



<h4 id="torchhydro.datasets.data_sets.BaseDataset.nt" class="doc doc-heading">
<code class="highlight language-python"><span class="n">nt</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-property"><code>property</code></small>
      <small class="doc doc-property doc-property-readonly"><code>readonly</code></small>
  </span>

<a href="#torchhydro.datasets.data_sets.BaseDataset.nt" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">

      <p>length of longest time series in all basins</p>
<h6 id="torchhydro.datasets.data_sets.BaseDataset.nt--returns">Returns<a class="headerlink" href="#torchhydro.datasets.data_sets.BaseDataset.nt--returns" title="Permanent link">&para;</a></h6>
<p>int
    number of longest time steps</p>
    </div>

  </div>





  <div class="doc doc-object doc-attribute">



<h4 id="torchhydro.datasets.data_sets.BaseDataset.times" class="doc doc-heading">
<code class="highlight language-python"><span class="n">times</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-property"><code>property</code></small>
      <small class="doc doc-property doc-property-readonly"><code>readonly</code></small>
  </span>

<a href="#torchhydro.datasets.data_sets.BaseDataset.times" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">

      <p>Return the times of all basins</p>
<p>TODO: Although we support get different time ranges for different basins,
we didn't implement the reading function for this case in _read_xyc method.
Hence, it's better to choose unified time range for all basins</p>
    </div>

  </div>






  <div class="doc doc-object doc-method">



<h4 id="torchhydro.datasets.data_sets.BaseDataset.__getitem__" class="doc doc-heading">
<code class="highlight language-python"><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#torchhydro.datasets.data_sets.BaseDataset.__getitem__" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">

      <p>Get one sample from the dataset with a unified return format.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>item</code></td>
        <td><code>int</code></td>
        <td><p>The index of the sample to retrieve.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td></td>
      <td><p>A tuple of (input_data, output_data), where input_data is a tensor
of input features and output_data is a tensor of target values.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/data_sets.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get one sample from the dataset with a unified return format.</span>

<span class="sd">    Args:</span>
<span class="sd">        item: The index of the sample to retrieve.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A tuple of (input_data, output_data), where input_data is a tensor</span>
<span class="sd">        of input features and output_data is a tensor of target values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">basin</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">actual_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lookup_table</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
    <span class="n">warmup_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">warmup_length</span>
    <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">basin</span><span class="p">,</span> <span class="n">idx</span> <span class="o">-</span> <span class="n">warmup_length</span> <span class="p">:</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">actual_length</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">basin</span><span class="p">,</span> <span class="n">idx</span> <span class="p">:</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">actual_length</span><span class="p">,</span> <span class="p">:]</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">(),</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
    <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">basin</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="n">xc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">c</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">xc</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">(),</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="torchhydro.datasets.data_sets.BaseDataset.__init__" class="doc doc-heading">
<code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cfgs</span><span class="p">,</span> <span class="n">is_tra_val_te</span><span class="p">)</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#torchhydro.datasets.data_sets.BaseDataset.__init__" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">

      <h6 id="torchhydro.datasets.data_sets.BaseDataset.__init__--parameters">Parameters<a class="headerlink" href="#torchhydro.datasets.data_sets.BaseDataset.__init__--parameters" title="Permanent link">&para;</a></h6>
<p>cfgs
    configs, including data and training + evaluation settings
    which will be used for organizing batch data
is_tra_val_te
    train, vaild or test</p>

        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/data_sets.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cfgs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">is_tra_val_te</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cfgs</span>
<span class="sd">        configs, including data and training + evaluation settings</span>
<span class="sd">        which will be used for organizing batch data</span>
<span class="sd">    is_tra_val_te</span>
<span class="sd">        train, vaild or test</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">BaseDataset</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span> <span class="o">=</span> <span class="n">cfgs</span><span class="p">[</span><span class="s2">&quot;data_cfgs&quot;</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">training_cfgs</span> <span class="o">=</span> <span class="n">cfgs</span><span class="p">[</span><span class="s2">&quot;training_cfgs&quot;</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">evaluation_cfgs</span> <span class="o">=</span> <span class="n">cfgs</span><span class="p">[</span><span class="s2">&quot;evaluation_cfgs&quot;</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_pre_load_data</span><span class="p">(</span><span class="n">is_tra_val_te</span><span class="p">)</span>
    <span class="c1"># load and preprocess data</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_load_data</span><span class="p">()</span>
</code></pre></div>
        </details>
    </div>

  </div>




  <div class="doc doc-object doc-method">



<h4 id="torchhydro.datasets.data_sets.BaseDataset.denormalize" class="doc doc-heading">
<code class="highlight language-python"><span class="n">denormalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">norm_data</span><span class="p">,</span> <span class="n">pace_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>


<a href="#torchhydro.datasets.data_sets.BaseDataset.denormalize" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">

      <p>Denormalize the norm_data</p>
<h6 id="torchhydro.datasets.data_sets.BaseDataset.denormalize--parameters">Parameters<a class="headerlink" href="#torchhydro.datasets.data_sets.BaseDataset.denormalize--parameters" title="Permanent link">&para;</a></h6>
<p>norm_data : np.ndarray
    batch-first data
pace_idx : int, optional
    which pace to show, by default None
    sometimes we may have multiple results for one time period and we flatten them
    so we need a temp time to replace real one</p>
<h6 id="torchhydro.datasets.data_sets.BaseDataset.denormalize--returns">Returns<a class="headerlink" href="#torchhydro.datasets.data_sets.BaseDataset.denormalize--returns" title="Permanent link">&para;</a></h6>
<p>xr.Dataset
    denormlized data</p>

        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/data_sets.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">denormalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">norm_data</span><span class="p">,</span> <span class="n">pace_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Denormalize the norm_data</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    norm_data : np.ndarray</span>
<span class="sd">        batch-first data</span>
<span class="sd">    pace_idx : int, optional</span>
<span class="sd">        which pace to show, by default None</span>
<span class="sd">        sometimes we may have multiple results for one time period and we flatten them</span>
<span class="sd">        so we need a temp time to replace real one</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xr.Dataset</span>
<span class="sd">        denormlized data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">target_scaler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_scaler</span>
    <span class="n">target_data</span> <span class="o">=</span> <span class="n">target_scaler</span><span class="o">.</span><span class="n">data_target</span>
    <span class="c1"># the units are dimensionless for pure DL models</span>
    <span class="n">units</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="s2">&quot;dimensionless&quot;</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">target_data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;units&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
    <span class="c1"># mainly to get information about the time points of norm_data</span>
    <span class="n">selected_time_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selected_time_points_for_denorm</span><span class="p">()</span>
    <span class="n">selected_data</span> <span class="o">=</span> <span class="n">target_data</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="n">selected_time_points</span><span class="p">)</span>

    <span class="c1">#  (basin, time, variable)</span>
    <span class="k">if</span> <span class="n">norm_data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;basin&quot;</span><span class="p">:</span> <span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;basin&quot;</span><span class="p">],</span>
            <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">],</span>
            <span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">],</span>
        <span class="p">}</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;basin&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;variable&quot;</span><span class="p">]</span>
        <span class="c1"># add</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">selected_time_points</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">):</span>
            <span class="c1">#  target_data </span>
            <span class="n">time_coords</span> <span class="o">=</span> <span class="n">target_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
            <span class="c1">#  selected_time_points </span>
            <span class="n">selected_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">time_coords</span><span class="p">,</span> <span class="n">selected_time_points</span><span class="p">))[</span>
                <span class="mi">0</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#  selected_time_points </span>
            <span class="n">selected_indices</span> <span class="o">=</span> <span class="n">selected_time_points</span>

        <span class="c1"># </span>
        <span class="n">max_idx</span> <span class="o">=</span> <span class="n">norm_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">selected_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">selected_indices</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">max_idx</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">norm_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]):</span>
            <span class="n">norm_data_3d</span> <span class="o">=</span> <span class="n">norm_data</span><span class="p">[:,</span> <span class="n">selected_indices</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">norm_data_3d</span> <span class="o">=</span> <span class="n">norm_data</span>

    <span class="c1"># </span>
    <span class="k">elif</span> <span class="n">norm_data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
        <span class="c1"># Check if the data is organized by basins</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluation_cfgs</span><span class="p">[</span><span class="s2">&quot;evaluator&quot;</span><span class="p">][</span><span class="s2">&quot;recover_mode&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;bybasins&quot;</span><span class="p">:</span>
            <span class="c1"># Shape: (basin_num, i_e_time_length, forecast_length, nf)</span>
            <span class="n">basin_num</span><span class="p">,</span> <span class="n">i_e_time_length</span><span class="p">,</span> <span class="n">forecast_length</span><span class="p">,</span> <span class="n">nf</span> <span class="o">=</span> <span class="n">norm_data</span><span class="o">.</span><span class="n">shape</span>

            <span class="c1"># If pace_idx is specified, select the specific forecast step</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">pace_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="ow">and</span> <span class="n">pace_idx</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="ow">and</span> <span class="n">pace_idx</span> <span class="o">&gt;=</span> <span class="mi">0</span>
                <span class="ow">and</span> <span class="n">pace_idx</span> <span class="o">&lt;</span> <span class="n">forecast_length</span>
            <span class="p">):</span>
                <span class="n">norm_data_3d</span> <span class="o">=</span> <span class="n">norm_data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">pace_idx</span><span class="p">,</span> <span class="p">:]</span>
                <span class="c1"># </span>
                <span class="c1"># basin</span>
                <span class="k">if</span> <span class="n">basin_num</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;basin&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># </span>
                    <span class="n">basin_coord</span> <span class="o">=</span> <span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;basin&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">basin_coord</span> <span class="o">=</span> <span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;basin&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[:</span><span class="n">basin_num</span><span class="p">]</span>

                <span class="n">coords</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;basin&quot;</span><span class="p">:</span> <span class="n">basin_coord</span><span class="p">,</span>
                    <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">][:</span><span class="n">i_e_time_length</span><span class="p">],</span>
                    <span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">],</span>
                <span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># pace_idx&#39;horizon&#39;</span>
                <span class="n">norm_data_3d</span> <span class="o">=</span> <span class="n">norm_data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                    <span class="n">basin_num</span><span class="p">,</span> <span class="n">i_e_time_length</span> <span class="o">*</span> <span class="n">forecast_length</span><span class="p">,</span> <span class="n">nf</span>
                <span class="p">)</span>
                <span class="c1"># i_e_time_length</span>
                <span class="n">new_times</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">forecast_length</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]):</span>
                        <span class="n">new_times</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                            <span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">][:</span><span class="n">i_e_time_length</span><span class="p">]</span>
                        <span class="p">)</span>

                <span class="c1"># </span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_times</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">i_e_time_length</span> <span class="o">*</span> <span class="n">forecast_length</span><span class="p">:</span>
                    <span class="n">new_times</span> <span class="o">=</span> <span class="n">new_times</span><span class="p">[:</span> <span class="n">i_e_time_length</span> <span class="o">*</span> <span class="n">forecast_length</span><span class="p">]</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_times</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">i_e_time_length</span> <span class="o">*</span> <span class="n">forecast_length</span><span class="p">:</span>
                    <span class="c1"># </span>
                    <span class="n">last_time</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">new_times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">new_times</span>
                        <span class="k">else</span> <span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="p">)</span>
                    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_times</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">i_e_time_length</span> <span class="o">*</span> <span class="n">forecast_length</span><span class="p">:</span>
                        <span class="n">new_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">last_time</span><span class="p">)</span>

                <span class="c1"># basin</span>
                <span class="k">if</span> <span class="n">basin_num</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;basin&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">basin_coord</span> <span class="o">=</span> <span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;basin&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">basin_coord</span> <span class="o">=</span> <span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;basin&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[:</span><span class="n">basin_num</span><span class="p">]</span>

                <span class="n">coords</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;basin&quot;</span><span class="p">:</span> <span class="n">basin_coord</span><span class="p">,</span>
                    <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">new_times</span><span class="p">,</span>
                    <span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">],</span>
                <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># byforecast</span>
            <span class="c1">#  (forecast_length, basin_num, i_e_time_length, nf)</span>
            <span class="n">forecast_length</span><span class="p">,</span> <span class="n">basin_num</span><span class="p">,</span> <span class="n">i_e_time_length</span><span class="p">,</span> <span class="n">nf</span> <span class="o">=</span> <span class="n">norm_data</span><span class="o">.</span><span class="n">shape</span>

            <span class="c1"># pace_idx</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">pace_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="ow">and</span> <span class="n">pace_idx</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="ow">and</span> <span class="n">pace_idx</span> <span class="o">&gt;=</span> <span class="mi">0</span>
                <span class="ow">and</span> <span class="n">pace_idx</span> <span class="o">&lt;</span> <span class="n">forecast_length</span>
            <span class="p">):</span>
                <span class="n">norm_data_3d</span> <span class="o">=</span> <span class="n">norm_data</span><span class="p">[</span><span class="n">pace_idx</span><span class="p">]</span>
                <span class="c1"># basin</span>
                <span class="k">if</span> <span class="n">basin_num</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;basin&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">basin_coord</span> <span class="o">=</span> <span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;basin&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">basin_coord</span> <span class="o">=</span> <span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;basin&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[:</span><span class="n">basin_num</span><span class="p">]</span>

                <span class="n">coords</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;basin&quot;</span><span class="p">:</span> <span class="n">basin_coord</span><span class="p">,</span>
                    <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">][:</span><span class="n">i_e_time_length</span><span class="p">],</span>
                    <span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">],</span>
                <span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If pace_idx is not specified, create a new dimension &#39;horizon&#39;</span>
                <span class="c1"># Reshape (forecast_length, basin_num, i_e_time_length, nf) -&gt; (basin_num, forecast_length * i_e_time_length, nf)</span>
                <span class="n">norm_data_3d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">norm_data</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                    <span class="n">basin_num</span><span class="p">,</span> <span class="n">forecast_length</span> <span class="o">*</span> <span class="n">i_e_time_length</span><span class="p">,</span> <span class="n">nf</span>
                <span class="p">)</span>

                <span class="c1"># </span>
                <span class="n">new_times</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">forecast_length</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]):</span>
                        <span class="n">new_times</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                            <span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">][:</span><span class="n">i_e_time_length</span><span class="p">]</span>
                        <span class="p">)</span>

                <span class="c1"># </span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_times</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">forecast_length</span> <span class="o">*</span> <span class="n">i_e_time_length</span><span class="p">:</span>
                    <span class="n">new_times</span> <span class="o">=</span> <span class="n">new_times</span><span class="p">[:</span> <span class="n">forecast_length</span> <span class="o">*</span> <span class="n">i_e_time_length</span><span class="p">]</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_times</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">forecast_length</span> <span class="o">*</span> <span class="n">i_e_time_length</span><span class="p">:</span>
                    <span class="c1"># </span>
                    <span class="n">last_time</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">new_times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">new_times</span>
                        <span class="k">else</span> <span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="p">)</span>
                    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_times</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">forecast_length</span> <span class="o">*</span> <span class="n">i_e_time_length</span><span class="p">:</span>
                        <span class="n">new_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">last_time</span><span class="p">)</span>

                <span class="c1"># basin</span>
                <span class="k">if</span> <span class="n">basin_num</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;basin&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">basin_coord</span> <span class="o">=</span> <span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;basin&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">basin_coord</span> <span class="o">=</span> <span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;basin&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[:</span><span class="n">basin_num</span><span class="p">]</span>

                <span class="n">coords</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;basin&quot;</span><span class="p">:</span> <span class="n">basin_coord</span><span class="p">,</span>
                    <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">new_times</span><span class="p">,</span>
                    <span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">],</span>
                <span class="p">}</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;basin&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;variable&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">selected_data</span><span class="o">.</span><span class="n">coords</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="n">selected_data</span><span class="o">.</span><span class="n">dims</span>
        <span class="n">norm_data_3d</span> <span class="o">=</span> <span class="n">norm_data</span>

    <span class="c1"># create DataArray and inverse transform</span>
    <span class="n">denorm_xr_ds</span> <span class="o">=</span> <span class="n">target_scaler</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span>
        <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">norm_data_3d</span><span class="p">,</span>
            <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span>
            <span class="n">attrs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;units&quot;</span><span class="p">:</span> <span class="n">units</span><span class="p">},</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">set_unit_to_var</span><span class="p">(</span><span class="n">denorm_xr_ds</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h3 id="torchhydro.datasets.data_sets.BasinSingleFlowDataset" class="doc doc-heading">
        <code>
BasinSingleFlowDataset            (<a class="autorefs autorefs-internal" title="
BaseDataset            (Dataset)
         (torchhydro.datasets.data_sets.BaseDataset)" href="#torchhydro.datasets.data_sets.BaseDataset">BaseDataset</a>)
        </code>



<a href="#torchhydro.datasets.data_sets.BasinSingleFlowDataset" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>one time length output for each grid in a batch</p>

        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/data_sets.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">BasinSingleFlowDataset</span><span class="p">(</span><span class="n">BaseDataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;one time length output for each grid in a batch&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cfgs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">is_tra_val_te</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BasinSingleFlowDataset</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cfgs</span><span class="p">,</span> <span class="n">is_tra_val_te</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="n">xc</span><span class="p">,</span> <span class="n">ys</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">BasinSingleFlowDataset</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">ys</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">return</span> <span class="n">xc</span><span class="p">,</span> <span class="n">y</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">













  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h3 id="torchhydro.datasets.data_sets.DplDataset" class="doc doc-heading">
        <code>
DplDataset            (<a class="autorefs autorefs-internal" title="
BaseDataset            (Dataset)
         (torchhydro.datasets.data_sets.BaseDataset)" href="#torchhydro.datasets.data_sets.BaseDataset">BaseDataset</a>)
        </code>



<a href="#torchhydro.datasets.data_sets.DplDataset" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>pytorch dataset for Differential parameter learning</p>

        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/data_sets.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">DplDataset</span><span class="p">(</span><span class="n">BaseDataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;pytorch dataset for Differential parameter learning&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cfgs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">is_tra_val_te</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cfgs</span>
<span class="sd">            all configs</span>
<span class="sd">        is_tra_val_te</span>
<span class="sd">            train, vaild or test</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DplDataset</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cfgs</span><span class="p">,</span> <span class="n">is_tra_val_te</span><span class="p">)</span>
        <span class="c1"># we don&#39;t use y_un_norm as its name because in the main function we will use &quot;y&quot;</span>
        <span class="c1"># For physical hydrological models, we need warmup, hence the target values should exclude data in warmup period</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">warmup_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">training_cfgs</span><span class="p">[</span><span class="s2">&quot;warmup_length&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_as_input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;target_as_input&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constant_only</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;constant_only&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_as_input</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">train_mode</span><span class="p">):</span>
            <span class="c1"># if the target is used as input and train_mode is False,</span>
            <span class="c1"># we need to get the target data in training period to generate pbm params</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">train_dataset</span> <span class="o">=</span> <span class="n">DplDataset</span><span class="p">(</span><span class="n">cfgs</span><span class="p">,</span> <span class="n">is_tra_val_te</span><span class="o">=</span><span class="s2">&quot;train&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get one mini-batch for dPL (differential parameter learning) model</span>

<span class="sd">        TODO: not check target_as_input and constant_only cases yet</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        item</span>
<span class="sd">            index</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            a mini-batch data;</span>
<span class="sd">            x_train (not normalized forcing), z_train (normalized data for DL model), y_train (not normalized output)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warmup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">warmup_length</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span>
        <span class="n">horizon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">horizon</span>
        <span class="n">xc_norm</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">DplDataset</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="n">basin</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lookup_table</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_as_input</span><span class="p">:</span>
            <span class="c1"># y_morn and xc_norm are concatenated and used for DL model</span>
            <span class="n">y_norm</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">basin</span><span class="p">,</span> <span class="n">time</span> <span class="o">-</span> <span class="n">warmup</span> <span class="p">:</span> <span class="n">time</span> <span class="o">+</span> <span class="n">rho</span> <span class="o">+</span> <span class="n">horizon</span><span class="p">,</span> <span class="p">:]</span>
            <span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
            <span class="c1"># the order of xc_norm and y_norm matters, please be careful!</span>
            <span class="n">z_train</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">xc_norm</span><span class="p">,</span> <span class="n">y_norm</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">constant_only</span><span class="p">:</span>
            <span class="c1"># only use attributes data for DL model</span>
            <span class="n">z_train</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">basin</span><span class="p">,</span> <span class="p">:])</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">z_train</span> <span class="o">=</span> <span class="n">xc_norm</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
        <span class="n">x_train</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_origin</span><span class="p">[</span><span class="n">basin</span><span class="p">,</span> <span class="n">time</span> <span class="o">-</span> <span class="n">warmup</span> <span class="p">:</span> <span class="n">time</span> <span class="o">+</span> <span class="n">rho</span> <span class="o">+</span> <span class="n">horizon</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">y_train</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_origin</span><span class="p">[</span><span class="n">basin</span><span class="p">,</span> <span class="n">time</span> <span class="p">:</span> <span class="n">time</span> <span class="o">+</span> <span class="n">rho</span> <span class="o">+</span> <span class="n">horizon</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">x_train</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">(),</span>
            <span class="n">z_train</span><span class="p">,</span>
        <span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">y_train</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">









  <div class="doc doc-object doc-method">



<h4 id="torchhydro.datasets.data_sets.DplDataset.__getitem__" class="doc doc-heading">
<code class="highlight language-python"><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#torchhydro.datasets.data_sets.DplDataset.__getitem__" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">

      <p>Get one mini-batch for dPL (differential parameter learning) model</p>
<p>TODO: not check target_as_input and constant_only cases yet</p>
<h6 id="torchhydro.datasets.data_sets.DplDataset.__getitem__--parameters">Parameters<a class="headerlink" href="#torchhydro.datasets.data_sets.DplDataset.__getitem__--parameters" title="Permanent link">&para;</a></h6>
<p>item
    index</p>
<h6 id="torchhydro.datasets.data_sets.DplDataset.__getitem__--returns">Returns<a class="headerlink" href="#torchhydro.datasets.data_sets.DplDataset.__getitem__--returns" title="Permanent link">&para;</a></h6>
<p>tuple
    a mini-batch data;
    x_train (not normalized forcing), z_train (normalized data for DL model), y_train (not normalized output)</p>

        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/data_sets.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get one mini-batch for dPL (differential parameter learning) model</span>

<span class="sd">    TODO: not check target_as_input and constant_only cases yet</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    item</span>
<span class="sd">        index</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple</span>
<span class="sd">        a mini-batch data;</span>
<span class="sd">        x_train (not normalized forcing), z_train (normalized data for DL model), y_train (not normalized output)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">warmup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">warmup_length</span>
    <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span>
    <span class="n">horizon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">horizon</span>
    <span class="n">xc_norm</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">DplDataset</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
    <span class="n">basin</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lookup_table</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_as_input</span><span class="p">:</span>
        <span class="c1"># y_morn and xc_norm are concatenated and used for DL model</span>
        <span class="n">y_norm</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">basin</span><span class="p">,</span> <span class="n">time</span> <span class="o">-</span> <span class="n">warmup</span> <span class="p">:</span> <span class="n">time</span> <span class="o">+</span> <span class="n">rho</span> <span class="o">+</span> <span class="n">horizon</span><span class="p">,</span> <span class="p">:]</span>
        <span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
        <span class="c1"># the order of xc_norm and y_norm matters, please be careful!</span>
        <span class="n">z_train</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">xc_norm</span><span class="p">,</span> <span class="n">y_norm</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">constant_only</span><span class="p">:</span>
        <span class="c1"># only use attributes data for DL model</span>
        <span class="n">z_train</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">basin</span><span class="p">,</span> <span class="p">:])</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">z_train</span> <span class="o">=</span> <span class="n">xc_norm</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
    <span class="n">x_train</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_origin</span><span class="p">[</span><span class="n">basin</span><span class="p">,</span> <span class="n">time</span> <span class="o">-</span> <span class="n">warmup</span> <span class="p">:</span> <span class="n">time</span> <span class="o">+</span> <span class="n">rho</span> <span class="o">+</span> <span class="n">horizon</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">y_train</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_origin</span><span class="p">[</span><span class="n">basin</span><span class="p">,</span> <span class="n">time</span> <span class="p">:</span> <span class="n">time</span> <span class="o">+</span> <span class="n">rho</span> <span class="o">+</span> <span class="n">horizon</span><span class="p">,</span> <span class="p">:]</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">x_train</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">(),</span>
        <span class="n">z_train</span><span class="p">,</span>
    <span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">y_train</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="torchhydro.datasets.data_sets.DplDataset.__init__" class="doc doc-heading">
<code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cfgs</span><span class="p">,</span> <span class="n">is_tra_val_te</span><span class="p">)</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#torchhydro.datasets.data_sets.DplDataset.__init__" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">

      <h6 id="torchhydro.datasets.data_sets.DplDataset.__init__--parameters">Parameters<a class="headerlink" href="#torchhydro.datasets.data_sets.DplDataset.__init__--parameters" title="Permanent link">&para;</a></h6>
<p>cfgs
    all configs
is_tra_val_te
    train, vaild or test</p>

        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/data_sets.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cfgs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">is_tra_val_te</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cfgs</span>
<span class="sd">        all configs</span>
<span class="sd">    is_tra_val_te</span>
<span class="sd">        train, vaild or test</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">DplDataset</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cfgs</span><span class="p">,</span> <span class="n">is_tra_val_te</span><span class="p">)</span>
    <span class="c1"># we don&#39;t use y_un_norm as its name because in the main function we will use &quot;y&quot;</span>
    <span class="c1"># For physical hydrological models, we need warmup, hence the target values should exclude data in warmup period</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">warmup_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">training_cfgs</span><span class="p">[</span><span class="s2">&quot;warmup_length&quot;</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">target_as_input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;target_as_input&quot;</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">constant_only</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;constant_only&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_as_input</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">train_mode</span><span class="p">):</span>
        <span class="c1"># if the target is used as input and train_mode is False,</span>
        <span class="c1"># we need to get the target data in training period to generate pbm params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">train_dataset</span> <span class="o">=</span> <span class="n">DplDataset</span><span class="p">(</span><span class="n">cfgs</span><span class="p">,</span> <span class="n">is_tra_val_te</span><span class="o">=</span><span class="s2">&quot;train&quot;</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h3 id="torchhydro.datasets.data_sets.FlexibleDataset" class="doc doc-heading">
        <code>
FlexibleDataset            (<a class="autorefs autorefs-internal" title="
BaseDataset            (Dataset)
         (torchhydro.datasets.data_sets.BaseDataset)" href="#torchhydro.datasets.data_sets.BaseDataset">BaseDataset</a>)
        </code>



<a href="#torchhydro.datasets.data_sets.FlexibleDataset" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>A dataset whose datasources are from multiple sources according to the configuration</p>

        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/data_sets.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">FlexibleDataset</span><span class="p">(</span><span class="n">BaseDataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A dataset whose datasources are from multiple sources according to the configuration&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cfgs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">is_tra_val_te</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">FlexibleDataset</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cfgs</span><span class="p">,</span> <span class="n">is_tra_val_te</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">data_source</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">source_cfgs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;source_cfgs&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="n">name</span><span class="p">:</span> <span class="n">data_sources_dict</span><span class="p">[</span><span class="n">name</span><span class="p">](</span><span class="n">path</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">path</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="n">source_cfgs</span><span class="p">[</span><span class="s2">&quot;source_names&quot;</span><span class="p">],</span> <span class="n">source_cfgs</span><span class="p">[</span><span class="s2">&quot;source_paths&quot;</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="p">}</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_read_xyc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">var_to_source_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;var_to_source_map&quot;</span><span class="p">]</span>
        <span class="n">x_datasets</span><span class="p">,</span> <span class="n">y_datasets</span><span class="p">,</span> <span class="n">c_datasets</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">gage_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_s_dict</span><span class="p">[</span><span class="s2">&quot;sites_id&quot;</span><span class="p">]</span>
        <span class="n">t_range</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_s_dict</span><span class="p">[</span><span class="s2">&quot;t_final_range&quot;</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="n">var_to_source_map</span><span class="p">:</span>
            <span class="n">source_name</span> <span class="o">=</span> <span class="n">var_to_source_map</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span>
            <span class="n">data_source_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_source</span><span class="p">[</span><span class="n">source_name</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;relevant_cols&quot;</span><span class="p">]:</span>
                <span class="n">x_datasets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">data_source_</span><span class="o">.</span><span class="n">read_ts_xrdataset</span><span class="p">(</span><span class="n">gage_ids</span><span class="p">,</span> <span class="n">t_range</span><span class="p">,</span> <span class="p">[</span><span class="n">var_name</span><span class="p">])</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;target_cols&quot;</span><span class="p">]:</span>
                <span class="n">y_datasets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">data_source_</span><span class="o">.</span><span class="n">read_ts_xrdataset</span><span class="p">(</span><span class="n">gage_ids</span><span class="p">,</span> <span class="n">t_range</span><span class="p">,</span> <span class="p">[</span><span class="n">var_name</span><span class="p">])</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;constant_cols&quot;</span><span class="p">]:</span>
                <span class="n">c_datasets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">data_source_</span><span class="o">.</span><span class="n">read_attr_xrdataset</span><span class="p">(</span><span class="n">gage_ids</span><span class="p">,</span> <span class="p">[</span><span class="n">var_name</span><span class="p">])</span>
                <span class="p">)</span>

        <span class="c1"># x, y, c</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">x_datasets</span><span class="p">)</span> <span class="k">if</span> <span class="n">x_datasets</span> <span class="k">else</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">()</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">y_datasets</span><span class="p">)</span> <span class="k">if</span> <span class="n">y_datasets</span> <span class="k">else</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">()</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">c_datasets</span><span class="p">)</span> <span class="k">if</span> <span class="n">c_datasets</span> <span class="k">else</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">()</span>
        <span class="c1"># Check if any flow variable exists in y dataset instead of hardcoding &quot;streamflow&quot;</span>
        <span class="n">flow_var_name</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">streamflow_name</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;streamflow_name&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">streamflow_name</span> <span class="ow">in</span> <span class="n">y</span>
            <span class="k">else</span> <span class="kc">None</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">flow_var_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># fallback: check if any target variable is in y</span>
            <span class="k">for</span> <span class="n">target_var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;target_cols&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">target_var</span> <span class="ow">in</span> <span class="n">y</span><span class="p">:</span>
                    <span class="n">flow_var_name</span> <span class="o">=</span> <span class="n">target_var</span>
                    <span class="k">break</span>
        <span class="k">if</span> <span class="n">flow_var_name</span> <span class="ow">and</span> <span class="n">flow_var_name</span> <span class="ow">in</span> <span class="n">y</span><span class="p">:</span>
            <span class="n">area</span> <span class="o">=</span> <span class="n">data_source_</span><span class="o">.</span><span class="n">camels</span><span class="o">.</span><span class="n">read_area</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t_s_dict</span><span class="p">[</span><span class="s2">&quot;sites_id&quot;</span><span class="p">])</span>
            <span class="n">y</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">streamflow_unit_conv</span><span class="p">(</span><span class="n">y</span><span class="p">[[</span><span class="n">flow_var_name</span><span class="p">]],</span> <span class="n">area</span><span class="p">))</span>
        <span class="n">x_origin</span><span class="p">,</span> <span class="n">y_origin</span><span class="p">,</span> <span class="n">c_origin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_dataarray_with_unit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x_origin</span><span class="p">,</span> <span class="n">y_origin</span><span class="p">,</span> <span class="n">c_origin</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">var_to_source_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;var_to_source_map&quot;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="n">var_to_source_map</span><span class="p">:</span>
            <span class="n">source_name</span> <span class="o">=</span> <span class="n">var_to_source_map</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span>
            <span class="n">data_source_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_source</span><span class="p">[</span><span class="n">source_name</span><span class="p">]</span>
            <span class="k">break</span>
        <span class="c1"># TODO: only support CAMELS for now</span>
        <span class="n">scaler_hub</span> <span class="o">=</span> <span class="n">ScalerHub</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y_origin</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x_origin</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c_origin</span><span class="p">,</span>
            <span class="n">data_cfgs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">,</span>
            <span class="n">is_tra_val_te</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">is_tra_val_te</span><span class="p">,</span>
            <span class="n">data_source</span><span class="o">=</span><span class="n">data_source_</span><span class="o">.</span><span class="n">camels</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_scaler</span> <span class="o">=</span> <span class="n">scaler_hub</span><span class="o">.</span><span class="n">target_scaler</span>
        <span class="k">return</span> <span class="n">scaler_hub</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">scaler_hub</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">scaler_hub</span><span class="o">.</span><span class="n">c</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">













  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h3 id="torchhydro.datasets.data_sets.FloodEventDataset" class="doc doc-heading">
        <code>
FloodEventDataset            (<a class="autorefs autorefs-internal" title="
BaseDataset            (Dataset)
         (torchhydro.datasets.data_sets.BaseDataset)" href="#torchhydro.datasets.data_sets.BaseDataset">BaseDataset</a>)
        </code>



<a href="#torchhydro.datasets.data_sets.FloodEventDataset" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Dataset class for flood event detection and prediction tasks.</p>
<p>This dataset is specifically designed to handle flood event data where
flood_event column contains binary indicators (0 for normal, non-zero for flood).
It automatically creates a flood_mask from the flood_event data for special
loss computation purposes.</p>
<p>The dataset reads data using SelfMadeHydroDataset from hydrodatasource,
expecting CSV files with columns like: time, rain, inflow, flood_event.</p>

        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/data_sets.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">FloodEventDataset</span><span class="p">(</span><span class="n">BaseDataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Dataset class for flood event detection and prediction tasks.</span>

<span class="sd">    This dataset is specifically designed to handle flood event data where</span>
<span class="sd">    flood_event column contains binary indicators (0 for normal, non-zero for flood).</span>
<span class="sd">    It automatically creates a flood_mask from the flood_event data for special</span>
<span class="sd">    loss computation purposes.</span>

<span class="sd">    The dataset reads data using SelfMadeHydroDataset from hydrodatasource,</span>
<span class="sd">    expecting CSV files with columns like: time, rain, inflow, flood_event.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cfgs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">is_tra_val_te</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize FloodEventDataset</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cfgs : dict</span>
<span class="sd">            Configuration dictionary containing data_cfgs, training_cfgs, evaluation_cfgs</span>
<span class="sd">        is_tra_val_te : str</span>
<span class="sd">            One of &#39;train&#39;, &#39;valid&#39;, or &#39;test&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Find flood_event column index for later processing</span>
        <span class="n">target_cols</span> <span class="o">=</span> <span class="n">cfgs</span><span class="p">[</span><span class="s2">&quot;data_cfgs&quot;</span><span class="p">][</span><span class="s2">&quot;target_cols&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flood_event_idx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">target_cols</span><span class="p">):</span>
            <span class="k">if</span> <span class="s2">&quot;flood_event&quot;</span> <span class="ow">in</span> <span class="n">col</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">flood_event_idx</span> <span class="o">=</span> <span class="n">i</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">flood_event_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;flood_event column not found in target_cols. Please ensure flood_event is included in the target columns.&quot;</span>
            <span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">FloodEventDataset</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cfgs</span><span class="p">,</span> <span class="n">is_tra_val_te</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">noutputvar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;How many output variables in the dataset</span>
<span class="sd">        Used in evaluation.</span>
<span class="sd">        For flood datasets, the number of output variables is 2.</span>
<span class="sd">        But we don&#39;t need flood_mask in evaluation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            number of variables</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;target_cols&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_create_flood_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create flood mask from flood_event column</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y : np.ndarray</span>
<span class="sd">            Target data with shape [seq_len, n_targets] containing flood_event column</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            Flood mask with shape [seq_len, 1] where 1 indicates flood event, 0 indicates normal</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">flood_event_idx</span> <span class="o">&gt;=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;flood_event_idx </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">flood_event_idx</span><span class="si">}</span><span class="s2"> exceeds target dimensions </span><span class="si">{</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Extract flood_event column</span>
        <span class="n">flood_events</span> <span class="o">=</span> <span class="n">y</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flood_event_idx</span><span class="p">]</span>

        <span class="c1"># Create binary mask: 1 for flood (non-zero), 0 for normal (zero)</span>
        <span class="n">no_flood_data</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">flood_events</span><span class="p">)</span>
        <span class="n">flood_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">flood_events</span> <span class="o">!=</span> <span class="n">no_flood_data</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="c1"># Reshape to maintain dimension consistency</span>
        <span class="n">flood_mask</span> <span class="o">=</span> <span class="n">flood_mask</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">flood_mask</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_create_lookup_table</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create lookup table based on flood events with sliding window</span>

<span class="sd">        This method creates samples where:</span>
<span class="sd">        1. For each flood event sequence:</span>
<span class="sd">           - In training: use sliding window to generate samples with fixed length</span>
<span class="sd">           - In testing: use the entire flood event sequence as one sample with its actual length</span>
<span class="sd">        2. Each sample covers the full sequence length without internal structure division</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lookup</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Calculate total sample sequence length for training/validation</span>
        <span class="n">sample_seqlen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">warmup_length</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">horizon</span>

        <span class="k">for</span> <span class="n">basin_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ngrid</span><span class="p">):</span>
            <span class="c1"># Get flood events for this basin</span>
            <span class="n">flood_events</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_origin</span><span class="p">[</span><span class="n">basin_idx</span><span class="p">,</span> <span class="p">:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flood_event_idx</span><span class="p">]</span>

            <span class="c1"># Find flood event sequences (consecutive non-zero values)</span>
            <span class="n">flood_sequences</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_flood_sequences</span><span class="p">(</span><span class="n">flood_events</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">seq_start</span><span class="p">,</span> <span class="n">seq_end</span> <span class="ow">in</span> <span class="n">flood_sequences</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_new_batch_way</span><span class="p">:</span>
                    <span class="c1"># For test period, use the entire flood event sequence as one sample</span>
                    <span class="c1"># But we need to ensure the sample includes enough context (sample_seqlen)</span>
                    <span class="n">flood_length</span> <span class="o">=</span> <span class="n">seq_end</span> <span class="o">-</span> <span class="n">seq_start</span> <span class="o">+</span> <span class="mi">1</span>

                    <span class="c1"># Calculate the start index to include enough context before the flood</span>
                    <span class="c1"># We want to include some data before the flood event starts</span>
                    <span class="n">context_before</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">sample_seqlen</span> <span class="o">-</span> <span class="n">flood_length</span><span class="p">,</span> <span class="n">seq_start</span><span class="p">)</span>
                    <span class="n">context_before</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">context_before</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="c1"># The actual start index should be early enough to provide context</span>
                    <span class="n">actual_start</span> <span class="o">=</span> <span class="n">seq_start</span> <span class="o">-</span> <span class="n">context_before</span>

                    <span class="c1"># The total length should be at least sample_seqlen or the actual flood sequence length</span>
                    <span class="n">total_length</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">sample_seqlen</span><span class="p">,</span> <span class="n">flood_length</span> <span class="o">+</span> <span class="n">context_before</span><span class="p">)</span>

                    <span class="c1"># Ensure we don&#39;t exceed the data bounds</span>
                    <span class="k">if</span> <span class="n">actual_start</span> <span class="o">+</span> <span class="n">total_length</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nt</span><span class="p">:</span>
                        <span class="n">total_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nt</span> <span class="o">-</span> <span class="n">actual_start</span>

                    <span class="n">lookup</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">basin_idx</span><span class="p">,</span> <span class="n">actual_start</span><span class="p">,</span> <span class="n">total_length</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># For training, use sliding window approach</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_create_sliding_window_samples</span><span class="p">(</span>
                        <span class="n">basin_idx</span><span class="p">,</span> <span class="n">seq_start</span><span class="p">,</span> <span class="n">seq_end</span><span class="p">,</span> <span class="n">sample_seqlen</span><span class="p">,</span> <span class="n">lookup</span>
                    <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">lookup_table</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">lookup</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lookup_table</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_find_flood_sequences</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flood_events</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find sequences of consecutive flood events</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        flood_events : np.ndarray</span>
<span class="sd">            1D array of flood event indicators</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            List of tuples (start_idx, end_idx) for each flood sequence</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sequences</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">in_sequence</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">start_idx</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">event</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">flood_events</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">event</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">in_sequence</span><span class="p">:</span>
                <span class="c1"># Start of a new flood sequence</span>
                <span class="n">in_sequence</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">start_idx</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">elif</span> <span class="n">event</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">in_sequence</span><span class="p">:</span>
                <span class="c1"># End of current flood sequence</span>
                <span class="n">in_sequence</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">sequences</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">start_idx</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">flood_events</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">in_sequence</span><span class="p">:</span>
                <span class="c1"># End of data while in sequence</span>
                <span class="n">sequences</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">start_idx</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">sequences</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_create_sliding_window_samples</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">basin_idx</span><span class="p">,</span> <span class="n">seq_start</span><span class="p">,</span> <span class="n">seq_end</span><span class="p">,</span> <span class="n">sample_seqlen</span><span class="p">,</span> <span class="n">lookup</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create samples for a flood sequence using sliding window approach with data validity check</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        basin_idx : int</span>
<span class="sd">            Index of the basin</span>
<span class="sd">        seq_start : int</span>
<span class="sd">            Start index of flood sequence</span>
<span class="sd">        seq_end : int</span>
<span class="sd">            End index of flood sequence</span>
<span class="sd">        sample_seqlen : int</span>
<span class="sd">            Maximum length of each sample (warmup_length + rho + horizon)</span>
<span class="sd">        lookup : list</span>
<span class="sd">            List to append new samples to (basin_idx, actual_start, actual_length)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Generate sliding window samples for this flood sequence</span>
        <span class="c1"># Each window should include at least some flood event data</span>

        <span class="c1"># Calculate the range where we can place the sliding window</span>
        <span class="c1"># The window end should not exceed the flood sequence end</span>
        <span class="n">max_window_start</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
            <span class="n">seq_end</span> <span class="o">-</span> <span class="n">sample_seqlen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nt</span> <span class="o">-</span> <span class="n">sample_seqlen</span>
        <span class="p">)</span>  <span class="c1"># Window end should not exceed seq_end or data bounds</span>
        <span class="n">min_window_start</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
            <span class="mi">0</span><span class="p">,</span> <span class="n">seq_start</span> <span class="o">-</span> <span class="n">sample_seqlen</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="p">)</span>  <span class="c1"># Window must include at least the first flood event</span>

        <span class="c1"># Ensure we have a valid range</span>
        <span class="k">if</span> <span class="n">max_window_start</span> <span class="o">&lt;</span> <span class="n">min_window_start</span><span class="p">:</span>
            <span class="k">return</span>  <span class="c1"># Skip this flood sequence if no valid window can be created</span>

        <span class="c1"># Generate samples with sliding window</span>
        <span class="k">for</span> <span class="n">window_start</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">min_window_start</span><span class="p">,</span> <span class="n">max_window_start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">window_end</span> <span class="o">=</span> <span class="n">window_start</span> <span class="o">+</span> <span class="n">sample_seqlen</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="c1"># Check if the window is valid (doesn&#39;t exceed data bounds and flood sequence)</span>
            <span class="k">if</span> <span class="n">window_end</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nt</span> <span class="ow">and</span> <span class="n">window_end</span> <span class="o">&lt;=</span> <span class="n">seq_end</span><span class="p">:</span>
                <span class="c1"># Check if this window includes at least some flood events</span>
                <span class="n">window_includes_flood</span> <span class="o">=</span> <span class="p">(</span><span class="n">window_start</span> <span class="o">&lt;=</span> <span class="n">seq_end</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                    <span class="n">window_end</span> <span class="o">&gt;=</span> <span class="n">seq_start</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="n">window_includes_flood</span><span class="p">:</span>
                    <span class="c1"># Find the actual valid data range within this window closest to flood</span>
                    <span class="n">actual_start</span><span class="p">,</span> <span class="n">actual_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_valid_data_range</span><span class="p">(</span>
                        <span class="n">basin_idx</span><span class="p">,</span> <span class="n">window_start</span><span class="p">,</span> <span class="n">window_end</span><span class="p">,</span> <span class="n">seq_start</span><span class="p">,</span> <span class="n">seq_end</span>
                    <span class="p">)</span>

                    <span class="c1"># Only add sample if we have sufficient valid data</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">actual_length</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">horizon</span>
                    <span class="p">):</span>  <span class="c1"># At least need rho + horizon</span>
                        <span class="n">lookup</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">basin_idx</span><span class="p">,</span> <span class="n">actual_start</span><span class="p">,</span> <span class="n">actual_length</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_find_valid_data_range</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">basin_idx</span><span class="p">,</span> <span class="n">window_start</span><span class="p">,</span> <span class="n">window_end</span><span class="p">,</span> <span class="n">flood_start</span><span class="p">,</span> <span class="n">flood_end</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find the continuous valid data range closest to the flood sequence</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        basin_idx : int</span>
<span class="sd">            Basin index</span>
<span class="sd">        window_start : int</span>
<span class="sd">            Start of the window to check</span>
<span class="sd">        window_end : int</span>
<span class="sd">            End of the window to check</span>
<span class="sd">        flood_start : int</span>
<span class="sd">            Start index of the flood sequence</span>
<span class="sd">        flood_end : int</span>
<span class="sd">            End index of the flood sequence</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            (actual_start, actual_length) of the valid data range closest to flood sequence</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get data for this basin and window</span>
        <span class="n">x_window</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">basin_idx</span><span class="p">,</span> <span class="n">window_start</span> <span class="p">:</span> <span class="n">window_end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1"># Check for NaN values in both input and output</span>
        <span class="n">valid_mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x_window</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Valid if no NaN in any feature</span>

        <span class="c1"># Find the continuous valid sequence closest to the flood sequence</span>
        <span class="n">closest_start</span><span class="p">,</span> <span class="n">closest_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_closest_valid_sequence</span><span class="p">(</span>
            <span class="n">valid_mask</span><span class="p">,</span> <span class="n">window_start</span><span class="p">,</span> <span class="n">flood_start</span><span class="p">,</span> <span class="n">flood_end</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">closest_length</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">window_start</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">closest_start</span><span class="p">,</span> <span class="n">closest_length</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_find_closest_valid_sequence</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">valid_mask</span><span class="p">,</span> <span class="n">window_start</span><span class="p">,</span> <span class="n">flood_start</span><span class="p">,</span> <span class="n">flood_end</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find the continuous valid sequence closest to the flood sequence</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        valid_mask : np.ndarray</span>
<span class="sd">            Boolean array indicating valid positions within the window</span>
<span class="sd">        window_start : int</span>
<span class="sd">            Start index of the window in the original time series</span>
<span class="sd">        flood_start : int</span>
<span class="sd">            Start index of the flood sequence in the original time series</span>
<span class="sd">        flood_end : int</span>
<span class="sd">            End index of the flood sequence in the original time series</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            (closest_start, closest_length) in original time series coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">valid_mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">window_start</span><span class="p">,</span> <span class="mi">0</span>

        <span class="c1"># Find all continuous valid sequences within the window</span>
        <span class="n">sequences</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">current_start</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">is_valid</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">valid_mask</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">is_valid</span> <span class="ow">and</span> <span class="n">current_start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">current_start</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">is_valid</span> <span class="ow">and</span> <span class="n">current_start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">sequences</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">current_start</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">current_start</span><span class="p">))</span>
                <span class="n">current_start</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Handle case where sequence continues to the end</span>
        <span class="k">if</span> <span class="n">current_start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sequences</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">current_start</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid_mask</span><span class="p">)</span> <span class="o">-</span> <span class="n">current_start</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">sequences</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">window_start</span><span class="p">,</span> <span class="mi">0</span>

        <span class="c1"># If only one sequence, return it directly</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequences</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">seq_start_rel</span><span class="p">,</span> <span class="n">seq_length</span> <span class="o">=</span> <span class="n">sequences</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">seq_start_abs</span> <span class="o">=</span> <span class="n">window_start</span> <span class="o">+</span> <span class="n">seq_start_rel</span>
            <span class="k">return</span> <span class="n">seq_start_abs</span><span class="p">,</span> <span class="n">seq_length</span>

        <span class="c1"># Find the sequence closest to the flood sequence</span>
        <span class="n">flood_center</span> <span class="o">=</span> <span class="p">(</span><span class="n">flood_start</span> <span class="o">+</span> <span class="n">flood_end</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">closest_sequence</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">min_distance</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">seq_start_rel</span><span class="p">,</span> <span class="n">seq_length</span> <span class="ow">in</span> <span class="n">sequences</span><span class="p">:</span>
            <span class="n">seq_start_abs</span> <span class="o">=</span> <span class="n">window_start</span> <span class="o">+</span> <span class="n">seq_start_rel</span>
            <span class="n">seq_end_abs</span> <span class="o">=</span> <span class="n">seq_start_abs</span> <span class="o">+</span> <span class="n">seq_length</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">seq_center</span> <span class="o">=</span> <span class="p">(</span><span class="n">seq_start_abs</span> <span class="o">+</span> <span class="n">seq_end_abs</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

            <span class="c1"># Calculate distance from sequence center to flood center</span>
            <span class="n">distance</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">seq_center</span> <span class="o">-</span> <span class="n">flood_center</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">distance</span> <span class="o">&lt;</span> <span class="n">min_distance</span><span class="p">:</span>
                <span class="n">min_distance</span> <span class="o">=</span> <span class="n">distance</span>
                <span class="n">closest_sequence</span> <span class="o">=</span> <span class="p">(</span><span class="n">seq_start_abs</span><span class="p">,</span> <span class="n">seq_length</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">closest_sequence</span> <span class="ow">or</span> <span class="p">(</span><span class="n">window_start</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get one sample from the dataset with flood mask</span>

<span class="sd">        Returns samples with:</span>
<span class="sd">        1. Variable length sequences (no padding)</span>
<span class="sd">        2. Flood mask for weighted loss computation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">basin</span><span class="p">,</span> <span class="n">start_idx</span><span class="p">,</span> <span class="n">actual_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lookup_table</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
        <span class="n">warmup_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">warmup_length</span>
        <span class="n">end_idx</span> <span class="o">=</span> <span class="n">start_idx</span> <span class="o">+</span> <span class="n">actual_length</span>

        <span class="c1"># Get input and target data for the actual valid range</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">basin</span><span class="p">,</span> <span class="n">start_idx</span><span class="p">:</span><span class="n">end_idx</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">basin</span><span class="p">,</span> <span class="n">start_idx</span> <span class="o">+</span> <span class="n">warmup_length</span> <span class="p">:</span> <span class="n">end_idx</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1"># Create flood mask from flood_event column</span>
        <span class="n">flood_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_flood_mask</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

        <span class="c1"># Replace the original flood_event column with the new flood_mask</span>
        <span class="n">y_with_flood_mask</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">y_with_flood_mask</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flood_event_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">flood_mask</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="c1"># Handle constant features if available</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">(),</span>
                <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">y_with_flood_mask</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">(),</span>
            <span class="p">)</span>

        <span class="c1"># Add constant features to input</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">basin</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">xc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">c</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">xc</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">(),</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">y_with_flood_mask</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">






  <div class="doc doc-object doc-attribute">



<h4 id="torchhydro.datasets.data_sets.FloodEventDataset.noutputvar" class="doc doc-heading">
<code class="highlight language-python"><span class="n">noutputvar</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-property"><code>property</code></small>
      <small class="doc doc-property doc-property-readonly"><code>readonly</code></small>
  </span>

<a href="#torchhydro.datasets.data_sets.FloodEventDataset.noutputvar" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">

      <p>How many output variables in the dataset
Used in evaluation.
For flood datasets, the number of output variables is 2.
But we don't need flood_mask in evaluation.</p>
<h6 id="torchhydro.datasets.data_sets.FloodEventDataset.noutputvar--returns">Returns<a class="headerlink" href="#torchhydro.datasets.data_sets.FloodEventDataset.noutputvar--returns" title="Permanent link">&para;</a></h6>
<p>int
    number of variables</p>
    </div>

  </div>






  <div class="doc doc-object doc-method">



<h4 id="torchhydro.datasets.data_sets.FloodEventDataset.__getitem__" class="doc doc-heading">
<code class="highlight language-python"><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#torchhydro.datasets.data_sets.FloodEventDataset.__getitem__" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">

      <p>Get one sample from the dataset with flood mask</p>
<p>Returns samples with:
1. Variable length sequences (no padding)
2. Flood mask for weighted loss computation</p>

        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/data_sets.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get one sample from the dataset with flood mask</span>

<span class="sd">    Returns samples with:</span>
<span class="sd">    1. Variable length sequences (no padding)</span>
<span class="sd">    2. Flood mask for weighted loss computation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">basin</span><span class="p">,</span> <span class="n">start_idx</span><span class="p">,</span> <span class="n">actual_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lookup_table</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
    <span class="n">warmup_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">warmup_length</span>
    <span class="n">end_idx</span> <span class="o">=</span> <span class="n">start_idx</span> <span class="o">+</span> <span class="n">actual_length</span>

    <span class="c1"># Get input and target data for the actual valid range</span>
    <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">basin</span><span class="p">,</span> <span class="n">start_idx</span><span class="p">:</span><span class="n">end_idx</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">basin</span><span class="p">,</span> <span class="n">start_idx</span> <span class="o">+</span> <span class="n">warmup_length</span> <span class="p">:</span> <span class="n">end_idx</span><span class="p">,</span> <span class="p">:]</span>

    <span class="c1"># Create flood mask from flood_event column</span>
    <span class="n">flood_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_flood_mask</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="c1"># Replace the original flood_event column with the new flood_mask</span>
    <span class="n">y_with_flood_mask</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">y_with_flood_mask</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flood_event_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">flood_mask</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

    <span class="c1"># Handle constant features if available</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">(),</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">y_with_flood_mask</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">(),</span>
        <span class="p">)</span>

    <span class="c1"># Add constant features to input</span>
    <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">basin</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="n">xc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">c</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">xc</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">(),</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">y_with_flood_mask</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="torchhydro.datasets.data_sets.FloodEventDataset.__init__" class="doc doc-heading">
<code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cfgs</span><span class="p">,</span> <span class="n">is_tra_val_te</span><span class="p">)</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#torchhydro.datasets.data_sets.FloodEventDataset.__init__" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">

      <p>Initialize FloodEventDataset</p>
<h6 id="torchhydro.datasets.data_sets.FloodEventDataset.__init__--parameters">Parameters<a class="headerlink" href="#torchhydro.datasets.data_sets.FloodEventDataset.__init__--parameters" title="Permanent link">&para;</a></h6>
<p>cfgs : dict
    Configuration dictionary containing data_cfgs, training_cfgs, evaluation_cfgs
is_tra_val_te : str
    One of 'train', 'valid', or 'test'</p>

        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/data_sets.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cfgs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">is_tra_val_te</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initialize FloodEventDataset</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cfgs : dict</span>
<span class="sd">        Configuration dictionary containing data_cfgs, training_cfgs, evaluation_cfgs</span>
<span class="sd">    is_tra_val_te : str</span>
<span class="sd">        One of &#39;train&#39;, &#39;valid&#39;, or &#39;test&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Find flood_event column index for later processing</span>
    <span class="n">target_cols</span> <span class="o">=</span> <span class="n">cfgs</span><span class="p">[</span><span class="s2">&quot;data_cfgs&quot;</span><span class="p">][</span><span class="s2">&quot;target_cols&quot;</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">flood_event_idx</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">target_cols</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;flood_event&quot;</span> <span class="ow">in</span> <span class="n">col</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flood_event_idx</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">break</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">flood_event_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;flood_event column not found in target_cols. Please ensure flood_event is included in the target columns.&quot;</span>
        <span class="p">)</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">FloodEventDataset</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cfgs</span><span class="p">,</span> <span class="n">is_tra_val_te</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h3 id="torchhydro.datasets.data_sets.FloodEventDplDataset" class="doc doc-heading">
        <code>
FloodEventDplDataset            (<a class="autorefs autorefs-internal" title="
FloodEventDataset            (BaseDataset)
         (torchhydro.datasets.data_sets.FloodEventDataset)" href="#torchhydro.datasets.data_sets.FloodEventDataset">FloodEventDataset</a>)
        </code>



<a href="#torchhydro.datasets.data_sets.FloodEventDplDataset" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Dataset class for flood event detection and prediction with differential parameter learning support.</p>
<p>This dataset combines FloodEventDataset's flood event handling capabilities with
DplDataset's data format for differential parameter learning (dPL) models.
It handles flood event sequences and returns data in the format required for
physical hydrological models with neural network components.</p>

        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/data_sets.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">FloodEventDplDataset</span><span class="p">(</span><span class="n">FloodEventDataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Dataset class for flood event detection and prediction with differential parameter learning support.</span>

<span class="sd">    This dataset combines FloodEventDataset&#39;s flood event handling capabilities with</span>
<span class="sd">    DplDataset&#39;s data format for differential parameter learning (dPL) models.</span>
<span class="sd">    It handles flood event sequences and returns data in the format required for</span>
<span class="sd">    physical hydrological models with neural network components.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cfgs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">is_tra_val_te</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize FloodEventDplDataset</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cfgs : dict</span>
<span class="sd">            Configuration dictionary containing data_cfgs, training_cfgs, evaluation_cfgs</span>
<span class="sd">        is_tra_val_te : str</span>
<span class="sd">            One of &#39;train&#39;, &#39;valid&#39;, or &#39;test&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">FloodEventDplDataset</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cfgs</span><span class="p">,</span> <span class="n">is_tra_val_te</span><span class="p">)</span>

        <span class="c1"># Additional attributes for DPL functionality</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_as_input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;target_as_input&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constant_only</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;constant_only&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_as_input</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">train_mode</span><span class="p">):</span>
            <span class="c1"># if the target is used as input and train_mode is False,</span>
            <span class="c1"># we need to get the target data in training period to generate pbm params</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">train_dataset</span> <span class="o">=</span> <span class="n">FloodEventDplDataset</span><span class="p">(</span><span class="n">cfgs</span><span class="p">,</span> <span class="n">is_tra_val_te</span><span class="o">=</span><span class="s2">&quot;train&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get one sample from the dataset in DPL format with flood mask</span>

<span class="sd">        Returns data in the format required for differential parameter learning:</span>
<span class="sd">        - x_train: not normalized forcing data</span>
<span class="sd">        - z_train: normalized data for DL model (with flood mask)</span>
<span class="sd">        - y_train: not normalized output data</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        item : int</span>
<span class="sd">            Index of the sample</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            ((x_train, z_train), y_train) where:</span>
<span class="sd">            - x_train: torch.Tensor, not normalized forcing data</span>
<span class="sd">            - z_train: torch.Tensor, normalized data for DL model</span>
<span class="sd">            - y_train: torch.Tensor, not normalized output data with flood mask</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">basin</span><span class="p">,</span> <span class="n">start_idx</span><span class="p">,</span> <span class="n">actual_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lookup_table</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
        <span class="n">end_idx</span> <span class="o">=</span> <span class="n">start_idx</span> <span class="o">+</span> <span class="n">actual_length</span>
        <span class="n">warmup_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">warmup_length</span>
        <span class="c1"># Get normalized data first (using parent&#39;s logic for flood mask)</span>
        <span class="n">xc_norm</span><span class="p">,</span> <span class="n">y_norm_with_mask</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">FloodEventDplDataset</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

        <span class="c1"># Get original (not normalized) data</span>
        <span class="n">x_origin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_origin</span><span class="p">[</span><span class="n">basin</span><span class="p">,</span> <span class="n">start_idx</span><span class="p">:</span><span class="n">end_idx</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">y_origin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_origin</span><span class="p">[</span><span class="n">basin</span><span class="p">,</span> <span class="n">start_idx</span> <span class="o">+</span> <span class="n">warmup_length</span> <span class="p">:</span> <span class="n">end_idx</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1"># Create flood mask for original y data</span>
        <span class="n">flood_mask_origin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_flood_mask</span><span class="p">(</span><span class="n">y_origin</span><span class="p">)</span>
        <span class="n">y_origin_with_mask</span> <span class="o">=</span> <span class="n">y_origin</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">y_origin_with_mask</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flood_event_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">flood_mask_origin</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="c1"># Prepare z_train based on configuration</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_as_input</span><span class="p">:</span>
            <span class="c1"># y_norm and xc_norm are concatenated and used for DL model</span>
            <span class="c1"># the order of xc_norm and y_norm matters, please be careful!</span>
            <span class="n">z_train</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">xc_norm</span><span class="p">,</span> <span class="n">y_norm_with_mask</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">constant_only</span><span class="p">:</span>
            <span class="c1"># only use attributes data for DL model</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># If no constant features, use a zero tensor</span>
                <span class="n">z_train</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">actual_length</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">basin</span><span class="p">,</span> <span class="p">:]</span>
                <span class="c1"># Repeat constants for the actual sequence length</span>
                <span class="n">c_repeated</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">actual_length</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                <span class="p">)</span>
                <span class="n">z_train</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">c_repeated</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Use normalized input features with constants</span>
            <span class="n">z_train</span> <span class="o">=</span> <span class="n">xc_norm</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>

        <span class="c1"># Prepare x_train (original forcing data with constants if available)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">x_train</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">x_origin</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_origin</span><span class="p">[</span><span class="n">basin</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">c_repeated</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">actual_length</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">x_origin_with_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">x_origin</span><span class="p">,</span> <span class="n">c_repeated</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">x_train</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">x_origin_with_c</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>

        <span class="c1"># y_train is the original output data with flood mask</span>
        <span class="n">y_train</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">y_origin_with_mask</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">x_train</span><span class="p">,</span> <span class="n">z_train</span><span class="p">),</span> <span class="n">y_train</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">









  <div class="doc doc-object doc-method">



<h4 id="torchhydro.datasets.data_sets.FloodEventDplDataset.__getitem__" class="doc doc-heading">
<code class="highlight language-python"><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#torchhydro.datasets.data_sets.FloodEventDplDataset.__getitem__" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">

      <p>Get one sample from the dataset in DPL format with flood mask</p>
<p>Returns data in the format required for differential parameter learning:
- x_train: not normalized forcing data
- z_train: normalized data for DL model (with flood mask)
- y_train: not normalized output data</p>
<h6 id="torchhydro.datasets.data_sets.FloodEventDplDataset.__getitem__--parameters">Parameters<a class="headerlink" href="#torchhydro.datasets.data_sets.FloodEventDplDataset.__getitem__--parameters" title="Permanent link">&para;</a></h6>
<p>item : int
    Index of the sample</p>
<h6 id="torchhydro.datasets.data_sets.FloodEventDplDataset.__getitem__--returns">Returns<a class="headerlink" href="#torchhydro.datasets.data_sets.FloodEventDplDataset.__getitem__--returns" title="Permanent link">&para;</a></h6>
<p>tuple
    ((x_train, z_train), y_train) where:
    - x_train: torch.Tensor, not normalized forcing data
    - z_train: torch.Tensor, normalized data for DL model
    - y_train: torch.Tensor, not normalized output data with flood mask</p>

        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/data_sets.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get one sample from the dataset in DPL format with flood mask</span>

<span class="sd">    Returns data in the format required for differential parameter learning:</span>
<span class="sd">    - x_train: not normalized forcing data</span>
<span class="sd">    - z_train: normalized data for DL model (with flood mask)</span>
<span class="sd">    - y_train: not normalized output data</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    item : int</span>
<span class="sd">        Index of the sample</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple</span>
<span class="sd">        ((x_train, z_train), y_train) where:</span>
<span class="sd">        - x_train: torch.Tensor, not normalized forcing data</span>
<span class="sd">        - z_train: torch.Tensor, normalized data for DL model</span>
<span class="sd">        - y_train: torch.Tensor, not normalized output data with flood mask</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">basin</span><span class="p">,</span> <span class="n">start_idx</span><span class="p">,</span> <span class="n">actual_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lookup_table</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
    <span class="n">end_idx</span> <span class="o">=</span> <span class="n">start_idx</span> <span class="o">+</span> <span class="n">actual_length</span>
    <span class="n">warmup_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">warmup_length</span>
    <span class="c1"># Get normalized data first (using parent&#39;s logic for flood mask)</span>
    <span class="n">xc_norm</span><span class="p">,</span> <span class="n">y_norm_with_mask</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">FloodEventDplDataset</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="c1"># Get original (not normalized) data</span>
    <span class="n">x_origin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_origin</span><span class="p">[</span><span class="n">basin</span><span class="p">,</span> <span class="n">start_idx</span><span class="p">:</span><span class="n">end_idx</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">y_origin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_origin</span><span class="p">[</span><span class="n">basin</span><span class="p">,</span> <span class="n">start_idx</span> <span class="o">+</span> <span class="n">warmup_length</span> <span class="p">:</span> <span class="n">end_idx</span><span class="p">,</span> <span class="p">:]</span>

    <span class="c1"># Create flood mask for original y data</span>
    <span class="n">flood_mask_origin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_flood_mask</span><span class="p">(</span><span class="n">y_origin</span><span class="p">)</span>
    <span class="n">y_origin_with_mask</span> <span class="o">=</span> <span class="n">y_origin</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">y_origin_with_mask</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flood_event_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">flood_mask_origin</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

    <span class="c1"># Prepare z_train based on configuration</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_as_input</span><span class="p">:</span>
        <span class="c1"># y_norm and xc_norm are concatenated and used for DL model</span>
        <span class="c1"># the order of xc_norm and y_norm matters, please be careful!</span>
        <span class="n">z_train</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">xc_norm</span><span class="p">,</span> <span class="n">y_norm_with_mask</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">constant_only</span><span class="p">:</span>
        <span class="c1"># only use attributes data for DL model</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># If no constant features, use a zero tensor</span>
            <span class="n">z_train</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">actual_length</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">basin</span><span class="p">,</span> <span class="p">:]</span>
            <span class="c1"># Repeat constants for the actual sequence length</span>
            <span class="n">c_repeated</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">actual_length</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="p">)</span>
            <span class="n">z_train</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">c_repeated</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Use normalized input features with constants</span>
        <span class="n">z_train</span> <span class="o">=</span> <span class="n">xc_norm</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>

    <span class="c1"># Prepare x_train (original forcing data with constants if available)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">x_train</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">x_origin</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_origin</span><span class="p">[</span><span class="n">basin</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">c_repeated</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">actual_length</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">x_origin_with_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">x_origin</span><span class="p">,</span> <span class="n">c_repeated</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">x_train</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">x_origin_with_c</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>

    <span class="c1"># y_train is the original output data with flood mask</span>
    <span class="n">y_train</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">y_origin_with_mask</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">x_train</span><span class="p">,</span> <span class="n">z_train</span><span class="p">),</span> <span class="n">y_train</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="torchhydro.datasets.data_sets.FloodEventDplDataset.__init__" class="doc doc-heading">
<code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cfgs</span><span class="p">,</span> <span class="n">is_tra_val_te</span><span class="p">)</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#torchhydro.datasets.data_sets.FloodEventDplDataset.__init__" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">

      <p>Initialize FloodEventDplDataset</p>
<h6 id="torchhydro.datasets.data_sets.FloodEventDplDataset.__init__--parameters">Parameters<a class="headerlink" href="#torchhydro.datasets.data_sets.FloodEventDplDataset.__init__--parameters" title="Permanent link">&para;</a></h6>
<p>cfgs : dict
    Configuration dictionary containing data_cfgs, training_cfgs, evaluation_cfgs
is_tra_val_te : str
    One of 'train', 'valid', or 'test'</p>

        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/data_sets.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cfgs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">is_tra_val_te</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initialize FloodEventDplDataset</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cfgs : dict</span>
<span class="sd">        Configuration dictionary containing data_cfgs, training_cfgs, evaluation_cfgs</span>
<span class="sd">    is_tra_val_te : str</span>
<span class="sd">        One of &#39;train&#39;, &#39;valid&#39;, or &#39;test&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">FloodEventDplDataset</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cfgs</span><span class="p">,</span> <span class="n">is_tra_val_te</span><span class="p">)</span>

    <span class="c1"># Additional attributes for DPL functionality</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">target_as_input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;target_as_input&quot;</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">constant_only</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;constant_only&quot;</span><span class="p">]</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_as_input</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">train_mode</span><span class="p">):</span>
        <span class="c1"># if the target is used as input and train_mode is False,</span>
        <span class="c1"># we need to get the target data in training period to generate pbm params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">train_dataset</span> <span class="o">=</span> <span class="n">FloodEventDplDataset</span><span class="p">(</span><span class="n">cfgs</span><span class="p">,</span> <span class="n">is_tra_val_te</span><span class="o">=</span><span class="s2">&quot;train&quot;</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>




  <div class="doc doc-object doc-class">



<h3 id="torchhydro.datasets.data_sets.GNNDataset" class="doc doc-heading">
        <code>
GNNDataset            (<a class="autorefs autorefs-internal" title="
FloodEventDataset            (BaseDataset)
         (torchhydro.datasets.data_sets.FloodEventDataset)" href="#torchhydro.datasets.data_sets.FloodEventDataset">FloodEventDataset</a>)
        </code>



<a href="#torchhydro.datasets.data_sets.GNNDataset" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Optimized GNN Dataset for hydrological Graph Neural Network tasks.</p>
<p>This dataset extends FloodEventDataset to support Graph Neural Networks by:
1. Integrating station data via StationHydroDataset
2. Processing adjacency matrices with flexible edge weight and attribute handling
3. Merging basin-level features (xc) with station-level features (sxc) per node
4. Returning GNN-ready format: (sxc, y, edge_index, edge_attr)</p>
<p>Key Features:
- Leverages BaseDataset's universal normalization and NaN handling for station data
- Supports flexible edge weight selection (specify column or default to binary)
- Always constructs edge_index and edge_attr for each basin
- Merges basin and station features to create comprehensive node representations</p>
<p>Configuration keys in data_cfgs.gnn_cfgs:
- station_cols: List of station variable names to load
- station_rm_nan: Whether to remove/interpolate NaN values (default: True)
- station_scaler_type: Scaler type for station data normalization
- use_adjacency: Whether to load adjacency matrices (default: True)
- adjacency_src_col: Source node column name (default: "ID")
- adjacency_dst_col: Destination node column name (default: "NEXTDOWNID")
- adjacency_edge_attr_cols: Columns for edge attributes (default: ["dist_hdn", "elev_diff", "strm_slope"])
- adjacency_weight_col: Column to use as edge weights (default: None for binary weights)
- return_edge_weight: Whether to return edge_weight instead of edge_attr (default: False)</p>
<p>edge_attr : torch.Tensor
    Edge attributes [num_edges, edge_attr_dim]</p>

        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/data_sets.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">GNNDataset</span><span class="p">(</span><span class="n">FloodEventDataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Optimized GNN Dataset for hydrological Graph Neural Network tasks.</span>

<span class="sd">    This dataset extends FloodEventDataset to support Graph Neural Networks by:</span>
<span class="sd">    1. Integrating station data via StationHydroDataset</span>
<span class="sd">    2. Processing adjacency matrices with flexible edge weight and attribute handling</span>
<span class="sd">    3. Merging basin-level features (xc) with station-level features (sxc) per node</span>
<span class="sd">    4. Returning GNN-ready format: (sxc, y, edge_index, edge_attr)</span>

<span class="sd">    Key Features:</span>
<span class="sd">    - Leverages BaseDataset&#39;s universal normalization and NaN handling for station data</span>
<span class="sd">    - Supports flexible edge weight selection (specify column or default to binary)</span>
<span class="sd">    - Always constructs edge_index and edge_attr for each basin</span>
<span class="sd">    - Merges basin and station features to create comprehensive node representations</span>

<span class="sd">    Configuration keys in data_cfgs.gnn_cfgs:</span>
<span class="sd">    - station_cols: List of station variable names to load</span>
<span class="sd">    - station_rm_nan: Whether to remove/interpolate NaN values (default: True)</span>
<span class="sd">    - station_scaler_type: Scaler type for station data normalization</span>
<span class="sd">    - use_adjacency: Whether to load adjacency matrices (default: True)</span>
<span class="sd">    - adjacency_src_col: Source node column name (default: &quot;ID&quot;)</span>
<span class="sd">    - adjacency_dst_col: Destination node column name (default: &quot;NEXTDOWNID&quot;)</span>
<span class="sd">    - adjacency_edge_attr_cols: Columns for edge attributes (default: [&quot;dist_hdn&quot;, &quot;elev_diff&quot;, &quot;strm_slope&quot;])</span>
<span class="sd">    - adjacency_weight_col: Column to use as edge weights (default: None for binary weights)</span>
<span class="sd">    - return_edge_weight: Whether to return edge_weight instead of edge_attr (default: False)</span>

<span class="sd">    edge_attr : torch.Tensor</span>
<span class="sd">        Edge attributes [num_edges, edge_attr_dim]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cfgs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">is_tra_val_te</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="c1"># Extract and extend configuration for station data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_extend_data_cfgs_for_stations</span><span class="p">(</span><span class="n">cfgs</span><span class="p">)</span>

        <span class="c1"># Store GNN-specific settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gnn_cfgs</span> <span class="o">=</span> <span class="n">cfgs</span><span class="p">[</span><span class="s2">&quot;data_cfgs&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;station_cfgs&quot;</span><span class="p">,</span> <span class="p">{})</span>

        <span class="c1"># Initialize parent (this will call BaseDataset._load_data() automatically)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">GNNDataset</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cfgs</span><span class="p">,</span> <span class="n">is_tra_val_te</span><span class="p">)</span>

        <span class="c1"># Load adjacency data after main data processing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adjacency_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_adjacency_data</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_extend_data_cfgs_for_stations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cfgs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extend data configuration to include station data as a standard data type</span>

<span class="sd">        This allows BaseDataset to handle station data using its universal processing pipeline.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data_cfgs</span> <span class="o">=</span> <span class="n">cfgs</span><span class="p">[</span><span class="s2">&quot;data_cfgs&quot;</span><span class="p">]</span>
        <span class="n">gnn_cfgs</span> <span class="o">=</span> <span class="n">data_cfgs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;station_cfgs&quot;</span><span class="p">,</span> <span class="p">{})</span>

        <span class="c1"># Add station_cols to data configuration if specifiedgnn_cfgs,data_cfgs</span>
        <span class="k">if</span> <span class="n">gnn_cfgs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;station_cols&quot;</span><span class="p">):</span>
            <span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;station_cols&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gnn_cfgs</span><span class="p">[</span><span class="s2">&quot;station_cols&quot;</span><span class="p">]</span>
            <span class="c1"># Add station data processing settings to leverage BaseDataset pipeline</span>
            <span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;station_rm_nan&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gnn_cfgs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;station_rm_nan&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_read_xyc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read X, Y, C data including station data using unified approach</span>

<span class="sd">        This is the ONLY method we need to override from BaseDataset.</span>
<span class="sd">        All other processing (normalization, NaN handling, array conversion)</span>
<span class="sd">        is handled automatically by BaseDataset&#39;s pipeline.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Read standard basin data using parent&#39;s logic</span>
        <span class="n">data_dict</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">GNNDataset</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_read_xyc</span><span class="p">()</span>

        <span class="c1"># Add station data if configured</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;station_cols&quot;</span><span class="p">):</span>
            <span class="n">station_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_all_station_data</span><span class="p">()</span>
            <span class="n">data_dict</span><span class="p">[</span><span class="s2">&quot;station_cols&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">station_data</span>

        <span class="k">return</span> <span class="n">data_dict</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_read_all_station_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read station data for all basins using StationHydroDataset</span>

<span class="sd">        Creates xr.DataArray with the same structure as other data types</span>
<span class="sd">        so that BaseDataset can process it using the universal pipeline.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_source</span><span class="p">,</span> <span class="s2">&quot;get_stations_by_basin&quot;</span><span class="p">):</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Data source does not support station data, skipping station data reading&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Convert basin IDs from &quot;songliao_21100150&quot; to &quot;21100150&quot; for StationHydroDataset</span>
        <span class="n">basin_ids_with_prefix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_s_dict</span><span class="p">[</span><span class="s2">&quot;sites_id&quot;</span><span class="p">]</span>
        <span class="n">basin_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_basin_to_station_ids</span><span class="p">(</span><span class="n">basin_ids_with_prefix</span><span class="p">)</span>
        <span class="n">t_range</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_s_dict</span><span class="p">[</span><span class="s2">&quot;t_final_range&quot;</span><span class="p">]</span>

        <span class="c1"># Collect station data for all basins</span>
        <span class="n">all_station_data</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">basin_id</span> <span class="ow">in</span> <span class="n">basin_ids</span><span class="p">:</span>
            <span class="n">basin_station_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_basin_station_data</span><span class="p">(</span><span class="n">basin_id</span><span class="p">,</span> <span class="n">t_range</span><span class="p">)</span>
            <span class="n">all_station_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">basin_station_data</span><span class="p">)</span>

        <span class="c1"># Combine into unified xr.DataArray structure</span>
        <span class="k">if</span> <span class="n">all_station_data</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">all_station_data</span><span class="p">):</span>
            <span class="n">combined_station_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_station_data_arrays</span><span class="p">(</span>
                <span class="n">all_station_data</span><span class="p">,</span> <span class="n">basin_ids</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">combined_station_data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_read_basin_station_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">basin_id</span><span class="p">,</span> <span class="n">t_range</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read station data for a single basin, supporting multi-period case&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Get stations for this basin</span>
            <span class="n">station_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_source</span><span class="o">.</span><span class="n">get_stations_by_basin</span><span class="p">(</span><span class="n">basin_id</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">station_ids</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

            <span class="c1"># Handle multi-period case</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                <span class="c1"># Validate that each period has exactly 2 elements (start and end date)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">period</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">t_range</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">period</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">period</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Period </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> must be a list/tuple with exactly 2 elements (start_date, end_date), got: </span><span class="si">{</span><span class="n">period</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>

                <span class="c1"># Multi-period case - read and concatenate data</span>
                <span class="n">all_station_data</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="k">for</span> <span class="n">start_date</span><span class="p">,</span> <span class="n">end_date</span> <span class="ow">in</span> <span class="n">t_range</span><span class="p">:</span>
                    <span class="n">period_station_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_source</span><span class="o">.</span><span class="n">read_station_ts_xrdataset</span><span class="p">(</span>
                        <span class="n">station_id_lst</span><span class="o">=</span><span class="n">station_ids</span><span class="p">,</span>
                        <span class="n">t_range</span><span class="o">=</span><span class="p">[</span><span class="n">start_date</span><span class="p">,</span> <span class="n">end_date</span><span class="p">],</span>
                        <span class="n">var_lst</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;station_cols&quot;</span><span class="p">],</span>
                        <span class="n">time_units</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gnn_cfgs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;station_time_units&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;1D&quot;</span><span class="p">]),</span>
                    <span class="p">)</span>

                    <span class="k">if</span> <span class="n">all_station_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">all_station_data</span> <span class="o">=</span> <span class="n">period_station_data</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">all_station_data</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
                            <span class="p">[</span><span class="n">all_station_data</span><span class="p">,</span> <span class="n">period_station_data</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s2">&quot;time&quot;</span>
                        <span class="p">)</span>

                <span class="n">station_data</span> <span class="o">=</span> <span class="n">all_station_data</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Single period case (existing behavior)</span>
                <span class="n">station_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_source</span><span class="o">.</span><span class="n">read_station_ts_xrdataset</span><span class="p">(</span>
                    <span class="n">station_id_lst</span><span class="o">=</span><span class="n">station_ids</span><span class="p">,</span>
                    <span class="n">t_range</span><span class="o">=</span><span class="n">t_range</span><span class="p">,</span>
                    <span class="n">var_lst</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;station_cols&quot;</span><span class="p">],</span>
                    <span class="n">time_units</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gnn_cfgs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;station_time_units&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;1D&quot;</span><span class="p">]),</span>
                <span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_station_xr_data</span><span class="p">(</span><span class="n">station_data</span><span class="p">)</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not read station data for basin </span><span class="si">{</span><span class="n">basin_id</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_process_station_xr_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">station_data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Process xarray station data into standard format&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">station_data</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Handle multiple time units</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">station_data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="c1"># Use first available time unit</span>
            <span class="n">time_unit</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">station_data</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">station_ds</span> <span class="o">=</span> <span class="n">station_data</span><span class="p">[</span><span class="n">time_unit</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">station_ds</span> <span class="o">=</span> <span class="n">station_data</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">station_ds</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">station_ds</span><span class="o">.</span><span class="n">sizes</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Convert to DataArray with standard format</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">station_ds</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">):</span>
            <span class="n">station_da</span> <span class="o">=</span> <span class="n">station_ds</span><span class="o">.</span><span class="n">to_array</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;variable&quot;</span><span class="p">)</span>
            <span class="c1"># Transpose to [time, station, variable]</span>
            <span class="n">station_da</span> <span class="o">=</span> <span class="n">station_da</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;station&quot;</span><span class="p">,</span> <span class="s2">&quot;variable&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">station_da</span> <span class="o">=</span> <span class="n">station_ds</span>

        <span class="k">return</span> <span class="n">station_da</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_combine_station_data_arrays</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">station_data_list</span><span class="p">,</span> <span class="n">basin_ids</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Combine station data from all basins into a unified structure</span>

<span class="sd">        Creates an xr.DataArray with dimensions [basin, time, station, variable]</span>
<span class="sd">        similar to how other data types are structured in BaseDataset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Find common time dimension and data structure</span>
        <span class="n">valid_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span> <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">station_data_list</span> <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">valid_data</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Use time dimension from first valid dataset</span>
        <span class="n">common_time</span> <span class="o">=</span> <span class="n">valid_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span>

        <span class="c1"># Find maximum number of stations and variables across all basins</span>
        <span class="n">max_stations</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">sizes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;station&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">valid_data</span><span class="p">)</span>
        <span class="n">max_variables</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">sizes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;variable&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">valid_data</span><span class="p">)</span>

        <span class="c1"># Create unified data array</span>
        <span class="n">n_basins</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">basin_ids</span><span class="p">)</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_time</span><span class="p">)</span>

        <span class="c1"># Initialize with NaN (BaseDataset will handle NaN processing)</span>
        <span class="n">unified_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span>
            <span class="p">(</span><span class="n">n_basins</span><span class="p">,</span> <span class="n">n_time</span><span class="p">,</span> <span class="n">max_stations</span><span class="p">,</span> <span class="n">max_variables</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span>
        <span class="p">)</span>

        <span class="c1"># Fill with actual data</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">basin_id</span><span class="p">,</span> <span class="n">station_data</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">basin_ids</span><span class="p">,</span> <span class="n">station_data_list</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">station_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Align time dimension</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">aligned_data</span> <span class="o">=</span> <span class="n">station_data</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span>
                        <span class="n">time</span><span class="o">=</span><span class="n">common_time</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span>
                    <span class="p">)</span>
                    <span class="n">data_array</span> <span class="o">=</span> <span class="n">aligned_data</span><span class="o">.</span><span class="n">values</span>

                    <span class="c1"># Insert into unified array</span>
                    <span class="n">n_stations_basin</span> <span class="o">=</span> <span class="n">data_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">n_vars_basin</span> <span class="o">=</span> <span class="n">data_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">unified_data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:</span><span class="n">n_stations_basin</span><span class="p">,</span> <span class="p">:</span><span class="n">n_vars_basin</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_array</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">LOGGER</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Failed to align station data for basin </span><span class="si">{</span><span class="n">basin_id</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                    <span class="k">continue</span>

        <span class="c1"># Create xr.DataArray with proper coordinates</span>
        <span class="n">station_coords</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;station_</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_stations</span><span class="p">)]</span>
        <span class="n">variable_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;station_cols&quot;</span><span class="p">][:</span><span class="n">max_variables</span><span class="p">]</span>

        <span class="n">station_da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">unified_data</span><span class="p">,</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;basin&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;station&quot;</span><span class="p">,</span> <span class="s2">&quot;variable&quot;</span><span class="p">],</span>
            <span class="n">coords</span><span class="o">=</span><span class="p">{</span>
                <span class="s2">&quot;basin&quot;</span><span class="p">:</span> <span class="n">basin_ids</span><span class="p">,</span>
                <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">common_time</span><span class="p">,</span>
                <span class="s2">&quot;station&quot;</span><span class="p">:</span> <span class="n">station_coords</span><span class="p">,</span>
                <span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">variable_coords</span><span class="p">,</span>
            <span class="p">},</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">station_da</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_load_adjacency_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load and process adjacency data from .nc files</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary containing edge_index, edge_attr for each basin</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">gnn_cfgs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;use_adjacency&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_source</span><span class="p">,</span> <span class="s2">&quot;read_adjacency_xrdataset&quot;</span><span class="p">):</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Data source does not support adjacency data&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">adjacency_data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># basin_ids = self.t_s_dict[&quot;sites_id&quot;]</span>
        <span class="c1"># Convert basin IDs from &quot;songliao_21100150&quot; to &quot;21100150&quot; for StationHydroDataset</span>
        <span class="n">basin_ids_with_prefix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_s_dict</span><span class="p">[</span><span class="s2">&quot;sites_id&quot;</span><span class="p">]</span>
        <span class="n">basin_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_basin_to_station_ids</span><span class="p">(</span><span class="n">basin_ids_with_prefix</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">basin_id</span> <span class="ow">in</span> <span class="n">basin_ids</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Read adjacency data from .nc file</span>
                <span class="n">adj_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_source</span><span class="o">.</span><span class="n">read_adjacency_xrdataset</span><span class="p">(</span><span class="n">basin_id</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">adj_df</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">LOGGER</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;No adjacency data for basin </span><span class="si">{</span><span class="n">basin_id</span><span class="si">}</span><span class="s2">, using self-loops&quot;</span>
                    <span class="p">)</span>
                    <span class="n">adjacency_data</span><span class="p">[</span><span class="n">basin_id</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_self_loop_adjacency</span><span class="p">(</span>
                        <span class="n">basin_id</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Let _process_adjacency_dataframe handle the format checking and processing</span>
                    <span class="n">adjacency_data</span><span class="p">[</span><span class="n">basin_id</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_adjacency_dataframe</span><span class="p">(</span>
                        <span class="n">adj_df</span><span class="p">,</span> <span class="n">basin_id</span>
                    <span class="p">)</span>

            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">LOGGER</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Failed to load adjacency data for basin </span><span class="si">{</span><span class="n">basin_id</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="n">adjacency_data</span><span class="p">[</span><span class="n">basin_id</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_self_loop_adjacency</span><span class="p">(</span><span class="n">basin_id</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">adjacency_data</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_process_adjacency_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">adj_df</span><span class="p">,</span> <span class="n">basin_id</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Process adjacency DataFrame into edge_index and edge_attr tensors</span>

<span class="sd">        Standard GNN processing: extract edges and their attributes from DataFrame or xarray Dataset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        adj_df : pd.DataFrame or xr.Dataset</span>
<span class="sd">            Adjacency DataFrame/Dataset with columns like ID, NEXTDOWNID, dist_hdn, elev_diff, strm_slope</span>
<span class="sd">        basin_id : str</span>
<span class="sd">            Basin identifier</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary containing edge_index, edge_attr, edge_weight, num_nodes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">xarray</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">xr</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

        <span class="c1"># Convert xarray Dataset to pandas DataFrame if needed</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">adj_df</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Convert xarray Dataset to pandas DataFrame</span>
                <span class="n">adj_df</span> <span class="o">=</span> <span class="n">adj_df</span><span class="o">.</span><span class="n">to_dataframe</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
                <span class="c1"># LOGGER.info(f&quot;Basin {basin_id}: Converted xarray Dataset to DataFrame with shape {adj_df.shape}&quot;)</span>
                <span class="c1"># LOGGER.info(f&quot;Basin {basin_id}: DataFrame columns = {list(adj_df.columns)}&quot;)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">LOGGER</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Basin </span><span class="si">{</span><span class="n">basin_id</span><span class="si">}</span><span class="s2">: Failed to convert xarray Dataset to DataFrame: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_self_loop_adjacency</span><span class="p">(</span><span class="n">basin_id</span><span class="p">)</span>

        <span class="c1"># Configuration (simplified)</span>
        <span class="n">src_col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gnn_cfgs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;adjacency_src_col&quot;</span><span class="p">,</span> <span class="s2">&quot;ID&quot;</span><span class="p">)</span>
        <span class="n">dst_col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gnn_cfgs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;adjacency_dst_col&quot;</span><span class="p">,</span> <span class="s2">&quot;NEXTDOWNID&quot;</span><span class="p">)</span>
        <span class="n">edge_attr_cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gnn_cfgs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="s2">&quot;adjacency_edge_attr_cols&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;dist_hdn&quot;</span><span class="p">,</span> <span class="s2">&quot;elev_diff&quot;</span><span class="p">,</span> <span class="s2">&quot;strm_slope&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">weight_col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gnn_cfgs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;adjacency_weight_col&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># </span>
        <span class="c1"># Check if required columns exist</span>
        <span class="k">if</span> <span class="n">src_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">adj_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Basin </span><span class="si">{</span><span class="n">basin_id</span><span class="si">}</span><span class="s2">: Source column &#39;</span><span class="si">{</span><span class="n">src_col</span><span class="si">}</span><span class="s2">&#39; not found in adjacency data. Available columns: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">adj_df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_self_loop_adjacency</span><span class="p">(</span><span class="n">basin_id</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dst_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">adj_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Basin </span><span class="si">{</span><span class="n">basin_id</span><span class="si">}</span><span class="s2">: Destination column &#39;</span><span class="si">{</span><span class="n">dst_col</span><span class="si">}</span><span class="s2">&#39; not found in adjacency data. Available columns: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">adj_df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_self_loop_adjacency</span><span class="p">(</span><span class="n">basin_id</span><span class="p">)</span>

        <span class="c1"># Clean and convert numeric columns to proper dtypes in batch</span>
        <span class="c1"># Handle string &quot;nan&quot; values that may come from NetCDF files</span>
        <span class="n">numeric_cols</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">col</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">edge_attr_cols</span> <span class="o">+</span> <span class="p">([</span><span class="n">weight_col</span><span class="p">]</span> <span class="k">if</span> <span class="n">weight_col</span> <span class="k">else</span> <span class="p">[])</span>
            <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">adj_df</span><span class="o">.</span><span class="n">columns</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="n">numeric_cols</span><span class="p">:</span>
            <span class="c1"># Batch replace string &quot;nan&quot; with actual NaN and convert to numeric</span>
            <span class="n">adj_df</span><span class="p">[</span><span class="n">numeric_cols</span><span class="p">]</span> <span class="o">=</span> <span class="n">adj_df</span><span class="p">[</span><span class="n">numeric_cols</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                <span class="p">[</span><span class="s2">&quot;nan&quot;</span><span class="p">,</span> <span class="s2">&quot;NaN&quot;</span><span class="p">,</span> <span class="s2">&quot;NAN&quot;</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="p">)</span>
            <span class="n">adj_df</span><span class="p">[</span><span class="n">numeric_cols</span><span class="p">]</span> <span class="o">=</span> <span class="n">adj_df</span><span class="p">[</span><span class="n">numeric_cols</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
                <span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;coerce&quot;</span>
            <span class="p">)</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Basin </span><span class="si">{</span><span class="n">basin_id</span><span class="si">}</span><span class="s2">: Converted </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">numeric_cols</span><span class="p">)</span><span class="si">}</span><span class="s2"> numeric columns in batch&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Create comprehensive node mapping including all stations in the basin</span>
        <span class="c1"># First get all nodes that appear in adjacency matrix (connected nodes)</span>
        <span class="n">connected_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">adj_df</span><span class="p">[</span><span class="n">src_col</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">())</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">adj_df</span><span class="p">[</span><span class="n">dst_col</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">())</span>

        <span class="c1"># Then get all stations in this basin (including isolated nodes)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_source</span><span class="p">,</span> <span class="s2">&quot;get_stations_by_basin&quot;</span><span class="p">):</span>
                <span class="n">all_basin_stations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_source</span><span class="o">.</span><span class="n">get_stations_by_basin</span><span class="p">(</span><span class="n">basin_id</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">all_basin_stations</span><span class="p">:</span>
                    <span class="c1"># Convert station IDs to strings to match adjacency data format</span>
                    <span class="n">all_basin_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
                        <span class="nb">str</span><span class="p">(</span><span class="n">station_id</span><span class="p">)</span> <span class="k">for</span> <span class="n">station_id</span> <span class="ow">in</span> <span class="n">all_basin_stations</span>
                    <span class="p">)</span>
                    <span class="c1"># Combine connected nodes with all basin nodes</span>
                    <span class="n">all_nodes</span> <span class="o">=</span> <span class="n">connected_nodes</span> <span class="o">|</span> <span class="n">all_basin_nodes</span>
                    <span class="n">isolated_nodes</span> <span class="o">=</span> <span class="n">all_basin_nodes</span> <span class="o">-</span> <span class="n">connected_nodes</span>
                    <span class="k">if</span> <span class="n">isolated_nodes</span><span class="p">:</span>
                        <span class="n">LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Basin </span><span class="si">{</span><span class="n">basin_id</span><span class="si">}</span><span class="s2">: Found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">isolated_nodes</span><span class="p">)</span><span class="si">}</span><span class="s2"> isolated nodes: </span><span class="si">{</span><span class="n">isolated_nodes</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">all_nodes</span> <span class="o">=</span> <span class="n">connected_nodes</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Fallback to only connected nodes if station data unavailable</span>
                <span class="n">all_nodes</span> <span class="o">=</span> <span class="n">connected_nodes</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Basin </span><span class="si">{</span><span class="n">basin_id</span><span class="si">}</span><span class="s2">: Failed to get all basin stations: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">, using connected nodes only&quot;</span>
            <span class="p">)</span>
            <span class="n">all_nodes</span> <span class="o">=</span> <span class="n">connected_nodes</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Basin </span><span class="si">{</span><span class="n">basin_id</span><span class="si">}</span><span class="s2">: No valid nodes found&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_self_loop_adjacency</span><span class="p">(</span><span class="n">basin_id</span><span class="p">)</span>

        <span class="n">node_to_idx</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">all_nodes</span><span class="p">))}</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Basin </span><span class="si">{</span><span class="n">basin_id</span><span class="si">}</span><span class="s2">: Found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">all_nodes</span><span class="p">)</span><span class="si">}</span><span class="s2"> total nodes (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">connected_nodes</span><span class="p">)</span><span class="si">}</span><span class="s2"> connected, </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">all_nodes</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="n">connected_nodes</span><span class="p">)</span><span class="si">}</span><span class="s2"> isolated)&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Extract edges and attributes using vectorized operations</span>
        <span class="c1"># First process edges from adjacency matrix</span>
        <span class="n">valid_rows</span> <span class="o">=</span> <span class="n">adj_df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="n">src_col</span><span class="p">,</span> <span class="n">dst_col</span><span class="p">])</span>
        <span class="n">edges_from_adj</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">edge_attrs_from_adj</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">edge_weights_from_adj</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid_rows</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Vectorized edge creation from adjacency matrix</span>
            <span class="n">src_nodes</span> <span class="o">=</span> <span class="n">valid_rows</span><span class="p">[</span><span class="n">src_col</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">node_to_idx</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            <span class="n">dst_nodes</span> <span class="o">=</span> <span class="n">valid_rows</span><span class="p">[</span><span class="n">dst_col</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">node_to_idx</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            <span class="n">edges_from_adj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">src_nodes</span><span class="p">,</span> <span class="n">dst_nodes</span><span class="p">])</span>

            <span class="c1"># Vectorized edge attributes extraction</span>
            <span class="n">edge_attrs_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">edge_attr_cols</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">valid_rows</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                    <span class="n">attrs</span> <span class="o">=</span> <span class="n">valid_rows</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">attrs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">valid_rows</span><span class="p">))</span>
                <span class="n">edge_attrs_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">attrs</span><span class="p">)</span>
            <span class="n">edge_attrs_from_adj</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">(</span><span class="n">edge_attrs_list</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">edge_attrs_list</span>
                <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">valid_rows</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge_attr_cols</span><span class="p">)))</span>
            <span class="p">)</span>

            <span class="c1"># Vectorized edge weights extraction</span>
            <span class="k">if</span> <span class="n">weight_col</span> <span class="ow">and</span> <span class="n">weight_col</span> <span class="ow">in</span> <span class="n">valid_rows</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">edge_weights_from_adj</span> <span class="o">=</span> <span class="n">valid_rows</span><span class="p">[</span><span class="n">weight_col</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">edge_weights_from_adj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">valid_rows</span><span class="p">))</span>

        <span class="c1"># Add self-loops for isolated nodes (nodes not in adjacency matrix)</span>
        <span class="n">isolated_nodes</span> <span class="o">=</span> <span class="n">all_nodes</span> <span class="o">-</span> <span class="n">connected_nodes</span>
        <span class="n">edges_from_isolated</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">edge_attrs_from_isolated</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">edge_weights_from_isolated</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">isolated_nodes</span><span class="p">:</span>
            <span class="c1"># Create self-loops for isolated nodes</span>
            <span class="n">isolated_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">node_to_idx</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">isolated_nodes</span><span class="p">]</span>
            <span class="n">edges_from_isolated</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">isolated_indices</span><span class="p">,</span> <span class="n">isolated_indices</span><span class="p">])</span>
            <span class="n">edge_attrs_from_isolated</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">isolated_nodes</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge_attr_cols</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="n">edge_weights_from_isolated</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">isolated_nodes</span><span class="p">))</span>

        <span class="c1"># Combine edges from adjacency matrix and self-loops for isolated nodes</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges_from_adj</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges_from_isolated</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">all_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">edges_from_adj</span><span class="p">,</span> <span class="n">edges_from_isolated</span><span class="p">])</span>
            <span class="n">all_edge_attrs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">edge_attrs_from_adj</span><span class="p">,</span> <span class="n">edge_attrs_from_isolated</span><span class="p">])</span>
            <span class="n">all_edge_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">[</span><span class="n">edge_weights_from_adj</span><span class="p">,</span> <span class="n">edge_weights_from_isolated</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges_from_adj</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">all_edges</span> <span class="o">=</span> <span class="n">edges_from_adj</span>
            <span class="n">all_edge_attrs</span> <span class="o">=</span> <span class="n">edge_attrs_from_adj</span>
            <span class="n">all_edge_weights</span> <span class="o">=</span> <span class="n">edge_weights_from_adj</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges_from_isolated</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">all_edges</span> <span class="o">=</span> <span class="n">edges_from_isolated</span>
            <span class="n">all_edge_attrs</span> <span class="o">=</span> <span class="n">edge_attrs_from_isolated</span>
            <span class="n">all_edge_weights</span> <span class="o">=</span> <span class="n">edge_weights_from_isolated</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Fallback: create self-loops for all nodes</span>
            <span class="c1"># LOGGER.warning(f&quot;Basin {basin_id}: No edges found, creating self-loops for all nodes&quot;)</span>
            <span class="n">n_nodes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_nodes</span><span class="p">)</span>
            <span class="n">node_indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_nodes</span><span class="p">))</span>
            <span class="n">all_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">node_indices</span><span class="p">,</span> <span class="n">node_indices</span><span class="p">])</span>
            <span class="n">all_edge_attrs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_nodes</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge_attr_cols</span><span class="p">)))</span>
            <span class="n">all_edge_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_nodes</span><span class="p">)</span>

        <span class="c1"># Convert to tensors</span>
        <span class="n">edge_index</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">all_edges</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">long</span><span class="p">)</span><span class="o">.</span><span class="n">contiguous</span><span class="p">()</span>
        <span class="n">edge_attr</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">all_edge_attrs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">all_edge_attrs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="kc">None</span>
        <span class="p">)</span>
        <span class="n">edge_weight</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">all_edge_weights</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;edge_index&quot;</span><span class="p">:</span> <span class="n">edge_index</span><span class="p">,</span>
            <span class="s2">&quot;edge_attr&quot;</span><span class="p">:</span> <span class="n">edge_attr</span><span class="p">,</span>
            <span class="s2">&quot;edge_weight&quot;</span><span class="p">:</span> <span class="n">edge_weight</span><span class="p">,</span>  <span class="c1"># </span>
            <span class="s2">&quot;num_nodes&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_nodes</span><span class="p">),</span>
            <span class="s2">&quot;node_to_idx&quot;</span><span class="p">:</span> <span class="n">node_to_idx</span><span class="p">,</span>
            <span class="s2">&quot;weight_col&quot;</span><span class="p">:</span> <span class="n">weight_col</span><span class="p">,</span>  <span class="c1"># </span>
        <span class="p">}</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_create_self_loop_adjacency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">basin_id</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create self-loop adjacency as fallback&quot;&quot;&quot;</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Try to get station count for this basin</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_source</span><span class="p">,</span> <span class="s2">&quot;get_stations_by_basin&quot;</span><span class="p">):</span>
                <span class="n">station_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_source</span><span class="o">.</span><span class="n">get_stations_by_basin</span><span class="p">(</span><span class="n">basin_id</span><span class="p">)</span>
                <span class="n">n_nodes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">station_ids</span><span class="p">)</span> <span class="k">if</span> <span class="n">station_ids</span> <span class="k">else</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">n_nodes</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">n_nodes</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># Create self-loops: edge_index = [[0,1,2,...], [0,1,2,...]]</span>
        <span class="n">edge_index</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_nodes</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Create default edge attributes</span>
        <span class="n">edge_attr_cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gnn_cfgs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="s2">&quot;adjacency_edge_attr_cols&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;dist_hdn&quot;</span><span class="p">,</span> <span class="s2">&quot;elev_diff&quot;</span><span class="p">,</span> <span class="s2">&quot;strm_slope&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">edge_attr_cols</span><span class="p">:</span>
            <span class="n">edge_attr</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_nodes</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge_attr_cols</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">edge_attr</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Create default edge weights (1.0 for self-loops)</span>
        <span class="n">edge_weight</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_nodes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;edge_index&quot;</span><span class="p">:</span> <span class="n">edge_index</span><span class="p">,</span>
            <span class="s2">&quot;edge_attr&quot;</span><span class="p">:</span> <span class="n">edge_attr</span><span class="p">,</span>
            <span class="s2">&quot;edge_weight&quot;</span><span class="p">:</span> <span class="n">edge_weight</span><span class="p">,</span>  <span class="c1"># </span>
            <span class="s2">&quot;num_nodes&quot;</span><span class="p">:</span> <span class="n">n_nodes</span><span class="p">,</span>
            <span class="s2">&quot;node_to_idx&quot;</span><span class="p">:</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_nodes</span><span class="p">)},</span>
            <span class="s2">&quot;weight_col&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># </span>
        <span class="p">}</span>

    <span class="c1"># GNN-specific utility methods</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_station_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">basin_idx</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get station data for a specific basin</span>

<span class="sd">        Since station data is now processed by BaseDataset pipeline,</span>
<span class="sd">        it&#39;s available as self.station_cols (converted to numpy array).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;station_cols&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">station_cols</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">station_cols</span><span class="p">[</span><span class="n">basin_idx</span><span class="p">]</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_adjacency_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">basin_idx</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get adjacency data for a specific basin</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict or None</span>
<span class="sd">            Dictionary containing edge_index, edge_attr, edge_weight, etc. or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjacency_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Get the specific basin ID for this basin index</span>
        <span class="n">basin_id_with_prefix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_s_dict</span><span class="p">[</span><span class="s2">&quot;sites_id&quot;</span><span class="p">][</span><span class="n">basin_idx</span><span class="p">]</span>
        <span class="c1"># Convert single basin ID to station ID (without prefix)</span>
        <span class="n">basin_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_basin_to_station_ids</span><span class="p">([</span><span class="n">basin_id_with_prefix</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjacency_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">basin_id</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_edge_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">basin_idx</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get edge weights for a specific basin</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        basin_idx : int</span>
<span class="sd">            Basin index</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch.Tensor or None</span>
<span class="sd">            Edge weights tensor [num_edges] or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">adjacency_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_adjacency_data</span><span class="p">(</span><span class="n">basin_idx</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">adjacency_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">adjacency_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;edge_weight&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_convert_basin_to_station_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">basin_ids</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert basin IDs (with prefix) to station IDs (without prefix) for StationHydroDataset</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        basin_ids : list</span>
<span class="sd">            List of basin IDs with prefix (e.g., [&quot;songliao_21100150&quot;])</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            List of station IDs without prefix (e.g., [&quot;21100150&quot;])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">station_ids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">basin_id</span> <span class="ow">in</span> <span class="n">basin_ids</span><span class="p">:</span>
            <span class="c1"># Remove common prefixes</span>
            <span class="k">if</span> <span class="s2">&quot;_&quot;</span> <span class="ow">in</span> <span class="n">basin_id</span><span class="p">:</span>
                <span class="c1"># Extract the part after the last underscore</span>
                <span class="n">station_id</span> <span class="o">=</span> <span class="n">basin_id</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If no underscore, use the original ID</span>
                <span class="n">station_id</span> <span class="o">=</span> <span class="n">basin_id</span>
            <span class="n">station_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">station_id</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">station_ids</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_convert_station_to_basin_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">station_ids</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;songliao&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert station IDs (without prefix) to basin IDs (with prefix) for consistency</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        station_ids : list</span>
<span class="sd">            List of station IDs without prefix (e.g., [&quot;21100150&quot;])</span>
<span class="sd">        prefix : str</span>
<span class="sd">            Prefix to add (default: &quot;songliao&quot;)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            List of basin IDs with prefix (e.g., [&quot;songliao_21100150&quot;])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">basin_ids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">station_id</span> <span class="ow">in</span> <span class="n">station_ids</span><span class="p">:</span>
            <span class="n">basin_id</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">station_id</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">basin_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">basin_id</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">basin_ids</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get one sample with GNN-specific data format.</span>

<span class="sd">        This method merges basin-level features (xc) into each station node&#39;s</span>
<span class="sd">        features (sxc), so each node&#39;s input includes both station and basin</span>
<span class="sd">        attributes.</span>

<span class="sd">        Args:</span>
<span class="sd">            item: The index of the sample to retrieve.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A tuple of (sxc, y, edge_index, edge_weight) where:</span>
<span class="sd">            - sxc: Station features merged with basin features.</span>
<span class="sd">                   Shape: [num_stations, seq_length, feature_dim]</span>
<span class="sd">            - y: Target values for prediction.</span>
<span class="sd">                 Shape: [forecast_length, output_dim]</span>
<span class="sd">            - edge_index: Edge connectivity.</span>
<span class="sd">                          Shape: [2, num_edges]</span>
<span class="sd">            - edge_weight: Edge weights.</span>
<span class="sd">                           Shape: [num_edges]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

        <span class="c1"># Get basic sample from parent (includes flood mask if FloodEventDataset)</span>
        <span class="n">basic_sample</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">GNNDataset</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

        <span class="c1"># Extract x, y from parent&#39;s output</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">basic_sample</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">basic_sample</span>  <span class="c1"># x: [seq_length, x_feature_dim], y_full: [full_length, y_feature_dim]</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">basic_sample</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">basic_sample</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">basic_sample</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected basic_sample format: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">basic_sample</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Get sample metadata</span>
        <span class="n">basin</span><span class="p">,</span> <span class="n">time_idx</span><span class="p">,</span> <span class="n">actual_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lookup_table</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>

        <span class="c1"># For GNN prediction, we only need the forecast part of y as target</span>
        <span class="c1"># The structure should be: warmup + hindcast (rho) + forecast (horizon)</span>
        <span class="c1"># We only predict the forecast (horizon) part</span>

        <span class="c1"># Get station data for current basin and time window</span>
        <span class="n">station_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_station_data</span><span class="p">(</span><span class="n">basin</span><span class="p">)</span>  <span class="c1"># [time, station, variable]</span>
        <span class="n">adjacency_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_adjacency_data</span><span class="p">(</span><span class="n">basin</span><span class="p">)</span>

        <span class="c1"># Extract station data for the time window (input sequence)</span>
        <span class="k">if</span> <span class="n">station_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># For station data, we need the input sequence (not just forecast part)</span>
            <span class="n">seq_end</span> <span class="o">=</span> <span class="n">time_idx</span> <span class="o">+</span> <span class="n">actual_length</span>
            <span class="n">sxc_raw</span> <span class="o">=</span> <span class="n">station_data</span><span class="p">[</span>
                <span class="n">time_idx</span><span class="p">:</span><span class="n">seq_end</span>
            <span class="p">]</span>  <span class="c1"># [seq_length, num_stations, station_feature_dim]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If no station data, create dummy station data</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;No station data for basin </span><span class="si">{</span><span class="n">basin</span><span class="si">}</span><span class="s2">, using single dummy station&quot;</span>
            <span class="p">)</span>
            <span class="n">dummy_station_features</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># Number of dummy features</span>
            <span class="n">sxc_raw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                <span class="p">(</span><span class="n">actual_length</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dummy_station_features</span><span class="p">)</span>
            <span class="p">)</span>  <span class="c1"># [seq_length, 1, 1]</span>

        <span class="c1"># Get basin-level features (xc) for merging</span>
        <span class="c1"># x contains basin-level features, we need to replicate it for each station</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">xc</span> <span class="o">=</span> <span class="n">x</span>  <span class="c1"># [seq_length, basin_feature_dim]</span>
            <span class="n">basin_feature_dim</span> <span class="o">=</span> <span class="n">xc</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">seq_length</span><span class="p">,</span> <span class="n">num_stations</span><span class="p">,</span> <span class="n">station_feature_dim</span> <span class="o">=</span> <span class="n">sxc_raw</span><span class="o">.</span><span class="n">shape</span>

            <span class="c1"># Replicate basin features for each station and concatenate with station features</span>
            <span class="c1"># xc expanded: [seq_length, 1, basin_feature_dim] -&gt; [seq_length, num_stations, basin_feature_dim]</span>
            <span class="n">xc_expanded</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">xc</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_stations</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

            <span class="c1"># Concatenate station features with basin features</span>
            <span class="c1"># sxc_temp: [seq_length, num_stations, station_feature_dim + basin_feature_dim]</span>
            <span class="n">sxc_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">sxc_raw</span><span class="p">,</span> <span class="n">xc_expanded</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># Transpose to get desired shape: [num_stations, seq_length, feature_dim]</span>
            <span class="n">sxc</span> <span class="o">=</span> <span class="n">sxc_temp</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If no basin features, use only station features and transpose</span>
            <span class="c1"># sxc: [num_stations, seq_length, station_feature_dim]</span>
            <span class="n">sxc</span> <span class="o">=</span> <span class="n">sxc_raw</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Process adjacency data (GNN edge orientation handled here)</span>
        <span class="c1"># Edge orientation logic: support &#39;upstream&#39;, &#39;downstream&#39;, &#39;bidirectional&#39; (default: downstream)</span>
        <span class="n">edge_orientation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gnn_cfgs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;edge_orientation&quot;</span><span class="p">,</span> <span class="s2">&quot;downstream&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">adjacency_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">edge_index</span> <span class="o">=</span> <span class="n">adjacency_data</span><span class="p">[</span><span class="s2">&quot;edge_index&quot;</span><span class="p">]</span>  <span class="c1"># [2, num_edges]</span>
            <span class="n">edge_attr</span> <span class="o">=</span> <span class="n">adjacency_data</span><span class="p">[</span>
                <span class="s2">&quot;edge_attr&quot;</span>
            <span class="p">]</span>  <span class="c1"># [num_edges, edge_attr_dim] or None</span>
            <span class="n">edge_weight</span> <span class="o">=</span> <span class="n">adjacency_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;edge_weight&quot;</span><span class="p">)</span>  <span class="c1"># [num_edges]</span>
            <span class="c1"># If edge_weight is None, fill with ones (all edges weight=1)</span>
            <span class="k">if</span> <span class="n">edge_weight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">num_edges</span> <span class="o">=</span> <span class="n">edge_index</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">edge_weight</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">num_edges</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

            <span class="c1"># Edge orientation handling</span>
            <span class="k">if</span> <span class="n">edge_orientation</span> <span class="o">==</span> <span class="s2">&quot;downstream&quot;</span><span class="p">:</span>
                <span class="c1"># Reverse all edges: swap source and target</span>
                <span class="n">edge_index</span> <span class="o">=</span> <span class="n">edge_index</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">:]</span>
            <span class="k">elif</span> <span class="n">edge_orientation</span> <span class="o">==</span> <span class="s2">&quot;bidirectional&quot;</span><span class="p">:</span>
                <span class="c1"># Add reversed edges to make bidirectional</span>
                <span class="n">edge_index_rev</span> <span class="o">=</span> <span class="n">edge_index</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">:]</span>
                <span class="n">edge_index</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">edge_index</span><span class="p">,</span> <span class="n">edge_index_rev</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">edge_attr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">edge_attr</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">edge_attr</span><span class="p">,</span> <span class="n">edge_attr</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">edge_weight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">edge_weight</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">edge_weight</span><span class="p">,</span> <span class="n">edge_weight</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="c1"># else: downstream (default), do nothing</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Default: self-loops for each station</span>
            <span class="n">num_stations</span> <span class="o">=</span> <span class="n">sxc</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span>
                <span class="mi">0</span>
            <span class="p">]</span>  <span class="c1"># Now sxc is [num_stations, seq_length, feature_dim]</span>
            <span class="n">edge_index</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_stations</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">edge_attr</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">edge_weight</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">num_stations</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>  <span class="c1"># 1</span>

        <span class="c1"># Ensure edge_attr has proper shape</span>
        <span class="k">if</span> <span class="n">edge_attr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num_edges</span> <span class="o">=</span> <span class="n">edge_index</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">edge_attr_dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gnn_cfgs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="s2">&quot;adjacency_edge_attr_cols&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;dist_hdn&quot;</span><span class="p">,</span> <span class="s2">&quot;elev_diff&quot;</span><span class="p">,</span> <span class="s2">&quot;strm_slope&quot;</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">edge_attr</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_edges</span><span class="p">,</span> <span class="n">edge_attr_dim</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

        <span class="c1"># Convert to tensors if needed</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sxc</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
            <span class="n">sxc</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">sxc</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">sxc</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">edge_index</span><span class="p">,</span> <span class="n">edge_weight</span>  <span class="c1"># edge_attr</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">









  <div class="doc doc-object doc-method">



<h4 id="torchhydro.datasets.data_sets.GNNDataset.__getitem__" class="doc doc-heading">
<code class="highlight language-python"><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#torchhydro.datasets.data_sets.GNNDataset.__getitem__" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">

      <p>Get one sample with GNN-specific data format.</p>
<p>This method merges basin-level features (xc) into each station node's
features (sxc), so each node's input includes both station and basin
attributes.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>item</code></td>
        <td><code>int</code></td>
        <td><p>The index of the sample to retrieve.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>A tuple of (sxc, y, edge_index, edge_weight) where</code></td>
      <td><ul>
<li>sxc: Station features merged with basin features.
       Shape: [num_stations, seq_length, feature_dim]</li>
<li>y: Target values for prediction.
     Shape: [forecast_length, output_dim]</li>
<li>edge_index: Edge connectivity.
              Shape: [2, num_edges]</li>
<li>edge_weight: Edge weights.
               Shape: [num_edges]</li>
</ul></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/data_sets.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get one sample with GNN-specific data format.</span>

<span class="sd">    This method merges basin-level features (xc) into each station node&#39;s</span>
<span class="sd">    features (sxc), so each node&#39;s input includes both station and basin</span>
<span class="sd">    attributes.</span>

<span class="sd">    Args:</span>
<span class="sd">        item: The index of the sample to retrieve.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A tuple of (sxc, y, edge_index, edge_weight) where:</span>
<span class="sd">        - sxc: Station features merged with basin features.</span>
<span class="sd">               Shape: [num_stations, seq_length, feature_dim]</span>
<span class="sd">        - y: Target values for prediction.</span>
<span class="sd">             Shape: [forecast_length, output_dim]</span>
<span class="sd">        - edge_index: Edge connectivity.</span>
<span class="sd">                      Shape: [2, num_edges]</span>
<span class="sd">        - edge_weight: Edge weights.</span>
<span class="sd">                       Shape: [num_edges]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

    <span class="c1"># Get basic sample from parent (includes flood mask if FloodEventDataset)</span>
    <span class="n">basic_sample</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">GNNDataset</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="c1"># Extract x, y from parent&#39;s output</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">basic_sample</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">basic_sample</span>  <span class="c1"># x: [seq_length, x_feature_dim], y_full: [full_length, y_feature_dim]</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">basic_sample</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">basic_sample</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">basic_sample</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected basic_sample format: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">basic_sample</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Get sample metadata</span>
    <span class="n">basin</span><span class="p">,</span> <span class="n">time_idx</span><span class="p">,</span> <span class="n">actual_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lookup_table</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>

    <span class="c1"># For GNN prediction, we only need the forecast part of y as target</span>
    <span class="c1"># The structure should be: warmup + hindcast (rho) + forecast (horizon)</span>
    <span class="c1"># We only predict the forecast (horizon) part</span>

    <span class="c1"># Get station data for current basin and time window</span>
    <span class="n">station_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_station_data</span><span class="p">(</span><span class="n">basin</span><span class="p">)</span>  <span class="c1"># [time, station, variable]</span>
    <span class="n">adjacency_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_adjacency_data</span><span class="p">(</span><span class="n">basin</span><span class="p">)</span>

    <span class="c1"># Extract station data for the time window (input sequence)</span>
    <span class="k">if</span> <span class="n">station_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># For station data, we need the input sequence (not just forecast part)</span>
        <span class="n">seq_end</span> <span class="o">=</span> <span class="n">time_idx</span> <span class="o">+</span> <span class="n">actual_length</span>
        <span class="n">sxc_raw</span> <span class="o">=</span> <span class="n">station_data</span><span class="p">[</span>
            <span class="n">time_idx</span><span class="p">:</span><span class="n">seq_end</span>
        <span class="p">]</span>  <span class="c1"># [seq_length, num_stations, station_feature_dim]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># If no station data, create dummy station data</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;No station data for basin </span><span class="si">{</span><span class="n">basin</span><span class="si">}</span><span class="s2">, using single dummy station&quot;</span>
        <span class="p">)</span>
        <span class="n">dummy_station_features</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># Number of dummy features</span>
        <span class="n">sxc_raw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="n">actual_length</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dummy_station_features</span><span class="p">)</span>
        <span class="p">)</span>  <span class="c1"># [seq_length, 1, 1]</span>

    <span class="c1"># Get basin-level features (xc) for merging</span>
    <span class="c1"># x contains basin-level features, we need to replicate it for each station</span>
    <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">xc</span> <span class="o">=</span> <span class="n">x</span>  <span class="c1"># [seq_length, basin_feature_dim]</span>
        <span class="n">basin_feature_dim</span> <span class="o">=</span> <span class="n">xc</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">seq_length</span><span class="p">,</span> <span class="n">num_stations</span><span class="p">,</span> <span class="n">station_feature_dim</span> <span class="o">=</span> <span class="n">sxc_raw</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># Replicate basin features for each station and concatenate with station features</span>
        <span class="c1"># xc expanded: [seq_length, 1, basin_feature_dim] -&gt; [seq_length, num_stations, basin_feature_dim]</span>
        <span class="n">xc_expanded</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">xc</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_stations</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Concatenate station features with basin features</span>
        <span class="c1"># sxc_temp: [seq_length, num_stations, station_feature_dim + basin_feature_dim]</span>
        <span class="n">sxc_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">sxc_raw</span><span class="p">,</span> <span class="n">xc_expanded</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Transpose to get desired shape: [num_stations, seq_length, feature_dim]</span>
        <span class="n">sxc</span> <span class="o">=</span> <span class="n">sxc_temp</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># If no basin features, use only station features and transpose</span>
        <span class="c1"># sxc: [num_stations, seq_length, station_feature_dim]</span>
        <span class="n">sxc</span> <span class="o">=</span> <span class="n">sxc_raw</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Process adjacency data (GNN edge orientation handled here)</span>
    <span class="c1"># Edge orientation logic: support &#39;upstream&#39;, &#39;downstream&#39;, &#39;bidirectional&#39; (default: downstream)</span>
    <span class="n">edge_orientation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gnn_cfgs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;edge_orientation&quot;</span><span class="p">,</span> <span class="s2">&quot;downstream&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">adjacency_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">edge_index</span> <span class="o">=</span> <span class="n">adjacency_data</span><span class="p">[</span><span class="s2">&quot;edge_index&quot;</span><span class="p">]</span>  <span class="c1"># [2, num_edges]</span>
        <span class="n">edge_attr</span> <span class="o">=</span> <span class="n">adjacency_data</span><span class="p">[</span>
            <span class="s2">&quot;edge_attr&quot;</span>
        <span class="p">]</span>  <span class="c1"># [num_edges, edge_attr_dim] or None</span>
        <span class="n">edge_weight</span> <span class="o">=</span> <span class="n">adjacency_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;edge_weight&quot;</span><span class="p">)</span>  <span class="c1"># [num_edges]</span>
        <span class="c1"># If edge_weight is None, fill with ones (all edges weight=1)</span>
        <span class="k">if</span> <span class="n">edge_weight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num_edges</span> <span class="o">=</span> <span class="n">edge_index</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">edge_weight</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">num_edges</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

        <span class="c1"># Edge orientation handling</span>
        <span class="k">if</span> <span class="n">edge_orientation</span> <span class="o">==</span> <span class="s2">&quot;downstream&quot;</span><span class="p">:</span>
            <span class="c1"># Reverse all edges: swap source and target</span>
            <span class="n">edge_index</span> <span class="o">=</span> <span class="n">edge_index</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">:]</span>
        <span class="k">elif</span> <span class="n">edge_orientation</span> <span class="o">==</span> <span class="s2">&quot;bidirectional&quot;</span><span class="p">:</span>
            <span class="c1"># Add reversed edges to make bidirectional</span>
            <span class="n">edge_index_rev</span> <span class="o">=</span> <span class="n">edge_index</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">:]</span>
            <span class="n">edge_index</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">edge_index</span><span class="p">,</span> <span class="n">edge_index_rev</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">edge_attr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">edge_attr</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">edge_attr</span><span class="p">,</span> <span class="n">edge_attr</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">edge_weight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">edge_weight</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">edge_weight</span><span class="p">,</span> <span class="n">edge_weight</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># else: downstream (default), do nothing</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Default: self-loops for each station</span>
        <span class="n">num_stations</span> <span class="o">=</span> <span class="n">sxc</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span>
            <span class="mi">0</span>
        <span class="p">]</span>  <span class="c1"># Now sxc is [num_stations, seq_length, feature_dim]</span>
        <span class="n">edge_index</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_stations</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">edge_attr</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">edge_weight</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">num_stations</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>  <span class="c1"># 1</span>

    <span class="c1"># Ensure edge_attr has proper shape</span>
    <span class="k">if</span> <span class="n">edge_attr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">num_edges</span> <span class="o">=</span> <span class="n">edge_index</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">edge_attr_dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gnn_cfgs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="s2">&quot;adjacency_edge_attr_cols&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;dist_hdn&quot;</span><span class="p">,</span> <span class="s2">&quot;elev_diff&quot;</span><span class="p">,</span> <span class="s2">&quot;strm_slope&quot;</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">edge_attr</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_edges</span><span class="p">,</span> <span class="n">edge_attr_dim</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

    <span class="c1"># Convert to tensors if needed</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sxc</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
        <span class="n">sxc</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">sxc</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">sxc</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">edge_index</span><span class="p">,</span> <span class="n">edge_weight</span>  <span class="c1"># edge_attr</span>
</code></pre></div>
        </details>
    </div>

  </div>




  <div class="doc doc-object doc-method">



<h4 id="torchhydro.datasets.data_sets.GNNDataset.get_adjacency_data" class="doc doc-heading">
<code class="highlight language-python"><span class="n">get_adjacency_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">basin_idx</span><span class="p">)</span></code>


<a href="#torchhydro.datasets.data_sets.GNNDataset.get_adjacency_data" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">

      <p>Get adjacency data for a specific basin</p>
<h6 id="torchhydro.datasets.data_sets.GNNDataset.get_adjacency_data--returns">Returns<a class="headerlink" href="#torchhydro.datasets.data_sets.GNNDataset.get_adjacency_data--returns" title="Permanent link">&para;</a></h6>
<p>dict or None
    Dictionary containing edge_index, edge_attr, edge_weight, etc. or None</p>

        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/data_sets.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">get_adjacency_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">basin_idx</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get adjacency data for a specific basin</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict or None</span>
<span class="sd">        Dictionary containing edge_index, edge_attr, edge_weight, etc. or None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjacency_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Get the specific basin ID for this basin index</span>
    <span class="n">basin_id_with_prefix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_s_dict</span><span class="p">[</span><span class="s2">&quot;sites_id&quot;</span><span class="p">][</span><span class="n">basin_idx</span><span class="p">]</span>
    <span class="c1"># Convert single basin ID to station ID (without prefix)</span>
    <span class="n">basin_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_basin_to_station_ids</span><span class="p">([</span><span class="n">basin_id_with_prefix</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjacency_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">basin_id</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="torchhydro.datasets.data_sets.GNNDataset.get_edge_weight" class="doc doc-heading">
<code class="highlight language-python"><span class="n">get_edge_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">basin_idx</span><span class="p">)</span></code>


<a href="#torchhydro.datasets.data_sets.GNNDataset.get_edge_weight" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">

      <p>Get edge weights for a specific basin</p>
<h6 id="torchhydro.datasets.data_sets.GNNDataset.get_edge_weight--parameters">Parameters<a class="headerlink" href="#torchhydro.datasets.data_sets.GNNDataset.get_edge_weight--parameters" title="Permanent link">&para;</a></h6>
<p>basin_idx : int
    Basin index</p>
<h6 id="torchhydro.datasets.data_sets.GNNDataset.get_edge_weight--returns">Returns<a class="headerlink" href="#torchhydro.datasets.data_sets.GNNDataset.get_edge_weight--returns" title="Permanent link">&para;</a></h6>
<p>torch.Tensor or None
    Edge weights tensor [num_edges] or None</p>

        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/data_sets.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">get_edge_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">basin_idx</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get edge weights for a specific basin</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    basin_idx : int</span>
<span class="sd">        Basin index</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    torch.Tensor or None</span>
<span class="sd">        Edge weights tensor [num_edges] or None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">adjacency_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_adjacency_data</span><span class="p">(</span><span class="n">basin_idx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">adjacency_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">adjacency_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;edge_weight&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">None</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="torchhydro.datasets.data_sets.GNNDataset.get_station_data" class="doc doc-heading">
<code class="highlight language-python"><span class="n">get_station_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">basin_idx</span><span class="p">)</span></code>


<a href="#torchhydro.datasets.data_sets.GNNDataset.get_station_data" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">

      <p>Get station data for a specific basin</p>
<p>Since station data is now processed by BaseDataset pipeline,
it's available as self.station_cols (converted to numpy array).</p>

        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/data_sets.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">get_station_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">basin_idx</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get station data for a specific basin</span>

<span class="sd">    Since station data is now processed by BaseDataset pipeline,</span>
<span class="sd">    it&#39;s available as self.station_cols (converted to numpy array).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;station_cols&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">station_cols</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">station_cols</span><span class="p">[</span><span class="n">basin_idx</span><span class="p">]</span>
    <span class="k">return</span> <span class="kc">None</span>
</code></pre></div>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>




  <div class="doc doc-object doc-class">



<h3 id="torchhydro.datasets.data_sets.ObsForeDataset" class="doc doc-heading">
        <code>
ObsForeDataset            (<a class="autorefs autorefs-internal" title="
BaseDataset            (Dataset)
         (torchhydro.datasets.data_sets.BaseDataset)" href="#torchhydro.datasets.data_sets.BaseDataset">BaseDataset</a>)
        </code>



<a href="#torchhydro.datasets.data_sets.ObsForeDataset" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p></p>
<p> lead_time  time 
</p>

        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/data_sets.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">ObsForeDataset</span><span class="p">(</span><span class="n">BaseDataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">     lead_time  time </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cfgs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">is_tra_val_te</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cfgs : dict</span>
<span class="sd">            all configs</span>
<span class="sd">        is_tra_val_te : str</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># </span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ObsForeDataset</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cfgs</span><span class="p">,</span> <span class="n">is_tra_val_te</span><span class="p">)</span>
        <span class="c1"># for each batch, we fix length of hindcast and forecast length.</span>
        <span class="c1"># data from different lead time with a number representing the lead time,</span>
        <span class="c1"># for example, now is 2020-09-30, our min_time_interval is 1 day, hindcast length is 30 and forecast length is 1,</span>
        <span class="c1"># lead_time = 3 means 2020-09-01 to 2020-09-30, and the forecast data is 2020-10-01 from 2020-09-28</span>
        <span class="c1"># for forecast data, we have two different configurations:</span>
        <span class="c1"># 1st, we can set a same lead time for all forecast time</span>
        <span class="c1"># 2020-09-30now, 30hindcast, 2forecast, 3leadtime means 2020-09-01 to 2020-09-30 obs concatenate with 2020-10-01 forecast data from 2020-09-28 and 2020-10-02 forecast data from 2020-09-29</span>
        <span class="c1"># 2nd, we can set a increasing lead time for each forecast time</span>
        <span class="c1"># 2020-09-30now, 30hindcast, 2forecast, [1, 2]leadtime means 2020-09-01 to 2020-09-30 obs concatenate with 2020-10-01 to 2010-10-02 forecast data from 2020-09-30</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lead_time_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">training_cfgs</span><span class="p">[</span><span class="s2">&quot;lead_time_type&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lead_time_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;fixed&quot;</span><span class="p">,</span> <span class="s2">&quot;increasing&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;lead_time_type must be one of &#39;fixed&#39; or &#39;increasing&#39;, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;but got </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">lead_time_type</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lead_time_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">training_cfgs</span><span class="p">[</span><span class="s2">&quot;lead_time_start&quot;</span><span class="p">]</span>
        <span class="n">horizon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">horizon</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">horizon</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lead_time_type</span> <span class="o">==</span> <span class="s2">&quot;fixed&quot;</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">lead_time_start</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">lead_time_type</span> <span class="o">==</span> <span class="s2">&quot;increasing&quot;</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lead_time_start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lead_time_start</span> <span class="o">+</span> <span class="n">horizon</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">horizon_offset</span> <span class="o">=</span> <span class="n">offset</span>
        <span class="n">feature_mapping</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;feature_mapping&quot;</span><span class="p">]</span>
        <span class="c1">#</span>
        <span class="n">xf_var_indices</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">obs_var</span><span class="p">,</span> <span class="n">fore_var</span> <span class="ow">in</span> <span class="n">feature_mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># x</span>
            <span class="n">x_var_indice</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">i</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;relevant_cols&quot;</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">var</span> <span class="o">==</span> <span class="n">obs_var</span>
            <span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># f</span>
            <span class="n">f_var_indice</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">i</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;forecast_cols&quot;</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">var</span> <span class="o">==</span> <span class="n">fore_var</span>
            <span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">xf_var_indices</span><span class="p">[</span><span class="n">x_var_indice</span><span class="p">]</span> <span class="o">=</span> <span class="n">f_var_indice</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xf_var_indices</span> <span class="o">=</span> <span class="n">xf_var_indices</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_read_xyc_specified_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_date</span><span class="p">,</span> <span class="n">end_date</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;read f data from data source with specified time range and add it to the whole dict&quot;&quot;&quot;</span>
        <span class="n">data_dict</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">ObsForeDataset</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_read_xyc_specified_time</span><span class="p">(</span>
            <span class="n">start_date</span><span class="p">,</span> <span class="n">end_date</span>
        <span class="p">)</span>
        <span class="n">lead_time</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;lead_time&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">f_origin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_source</span><span class="o">.</span><span class="n">read_ts_xrdataset</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">t_s_dict</span><span class="p">[</span><span class="s2">&quot;sites_id&quot;</span><span class="p">],</span>
            <span class="p">[</span><span class="n">start_date</span><span class="p">,</span> <span class="n">end_date</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;forecast_cols&quot;</span><span class="p">],</span>
            <span class="n">forecast_mode</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">lead_time</span><span class="o">=</span><span class="n">lead_time</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">f_origin_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rm_timeunit_key</span><span class="p">(</span><span class="n">f_origin</span><span class="p">)</span>
        <span class="n">f_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trans2da_and_setunits</span><span class="p">(</span><span class="n">f_origin_</span><span class="p">)</span>
        <span class="n">data_dict</span><span class="p">[</span><span class="s2">&quot;forecast_cols&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">f_data</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span>
            <span class="s2">&quot;basin&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;lead_step&quot;</span><span class="p">,</span> <span class="s2">&quot;variable&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">data_dict</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a sample from the dataset</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        item : int</span>
<span class="sd">            index of sample</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            A pair of (x, y) data, where x contains input features and lead time flags,</span>
<span class="sd">            and y contains target values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># train mode</span>
        <span class="n">basin</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lookup_table</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
        <span class="n">warmup_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">warmup_length</span>
        <span class="c1"># for x, we only chose data before horizon, but we may need forecast data for not all variables</span>
        <span class="c1"># hence, to avoid nan values for some variables without forecast in horizon</span>
        <span class="c1"># we still get data from the first time to the end of horizon</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">basin</span><span class="p">,</span> <span class="n">idx</span> <span class="o">-</span> <span class="n">warmup_length</span> <span class="p">:</span> <span class="n">idx</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">horizon</span><span class="p">,</span> <span class="p">:]</span>
        <span class="c1"># for y, we chose data after warmup_length</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">basin</span><span class="p">,</span> <span class="n">idx</span> <span class="p">:</span> <span class="n">idx</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">horizon</span><span class="p">,</span> <span class="p">:]</span>
        <span class="c1"># use offset to get forecast data</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">horizon_offset</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lead_time_type</span> <span class="o">==</span> <span class="s2">&quot;fixed&quot;</span><span class="p">:</span>
            <span class="c1"># Fixed lead_time mode - All forecast steps use the same lead_step</span>
            <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span>
                <span class="n">basin</span><span class="p">,</span> <span class="n">idx</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="p">:</span> <span class="n">idx</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">horizon</span><span class="p">,</span> <span class="n">offset</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Increasing lead_time mode - Each forecast step uses a different lead_step</span>
            <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">basin</span><span class="p">,</span> <span class="n">idx</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">xf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_concat_xf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">xfc</span> <span class="o">=</span> <span class="n">xf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">basin</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">xf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">xfc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">xf</span><span class="p">,</span> <span class="n">c</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">xfc</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">(),</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_concat_xf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="c1"># Create a copy of x to avoid modifying the original data</span>
        <span class="n">x_combined</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Iterate through the variable mapping relationship</span>
        <span class="k">for</span> <span class="n">x_idx</span><span class="p">,</span> <span class="n">f_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">xf_var_indices</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Replace the variables in the forecast period of x with the forecast variables in f</span>
            <span class="c1"># The forecast period of x starts from the rho position</span>
            <span class="n">x_combined</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">warmup_length</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="p">:,</span> <span class="n">x_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[:,</span> <span class="n">f_idx</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">x_combined</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">









  <div class="doc doc-object doc-method">



<h4 id="torchhydro.datasets.data_sets.ObsForeDataset.__getitem__" class="doc doc-heading">
<code class="highlight language-python"><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#torchhydro.datasets.data_sets.ObsForeDataset.__getitem__" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">

      <p>Get a sample from the dataset</p>
<h6 id="torchhydro.datasets.data_sets.ObsForeDataset.__getitem__--parameters">Parameters<a class="headerlink" href="#torchhydro.datasets.data_sets.ObsForeDataset.__getitem__--parameters" title="Permanent link">&para;</a></h6>
<p>item : int
    index of sample</p>
<h6 id="torchhydro.datasets.data_sets.ObsForeDataset.__getitem__--returns">Returns<a class="headerlink" href="#torchhydro.datasets.data_sets.ObsForeDataset.__getitem__--returns" title="Permanent link">&para;</a></h6>
<p>tuple
    A pair of (x, y) data, where x contains input features and lead time flags,
    and y contains target values</p>

        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/data_sets.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get a sample from the dataset</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    item : int</span>
<span class="sd">        index of sample</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple</span>
<span class="sd">        A pair of (x, y) data, where x contains input features and lead time flags,</span>
<span class="sd">        and y contains target values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># train mode</span>
    <span class="n">basin</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lookup_table</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
    <span class="n">warmup_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">warmup_length</span>
    <span class="c1"># for x, we only chose data before horizon, but we may need forecast data for not all variables</span>
    <span class="c1"># hence, to avoid nan values for some variables without forecast in horizon</span>
    <span class="c1"># we still get data from the first time to the end of horizon</span>
    <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">basin</span><span class="p">,</span> <span class="n">idx</span> <span class="o">-</span> <span class="n">warmup_length</span> <span class="p">:</span> <span class="n">idx</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">horizon</span><span class="p">,</span> <span class="p">:]</span>
    <span class="c1"># for y, we chose data after warmup_length</span>
    <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">basin</span><span class="p">,</span> <span class="n">idx</span> <span class="p">:</span> <span class="n">idx</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">horizon</span><span class="p">,</span> <span class="p">:]</span>
    <span class="c1"># use offset to get forecast data</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">horizon_offset</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lead_time_type</span> <span class="o">==</span> <span class="s2">&quot;fixed&quot;</span><span class="p">:</span>
        <span class="c1"># Fixed lead_time mode - All forecast steps use the same lead_step</span>
        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span>
            <span class="n">basin</span><span class="p">,</span> <span class="n">idx</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="p">:</span> <span class="n">idx</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">horizon</span><span class="p">,</span> <span class="n">offset</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:</span>
        <span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Increasing lead_time mode - Each forecast step uses a different lead_step</span>
        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">basin</span><span class="p">,</span> <span class="n">idx</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">xf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_concat_xf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">xfc</span> <span class="o">=</span> <span class="n">xf</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">basin</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">xf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">xfc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">xf</span><span class="p">,</span> <span class="n">c</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">xfc</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">(),</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="torchhydro.datasets.data_sets.ObsForeDataset.__init__" class="doc doc-heading">
<code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cfgs</span><span class="p">,</span> <span class="n">is_tra_val_te</span><span class="p">)</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#torchhydro.datasets.data_sets.ObsForeDataset.__init__" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">

      <p></p>
<h6 id="torchhydro.datasets.data_sets.ObsForeDataset.__init__--parameters">Parameters<a class="headerlink" href="#torchhydro.datasets.data_sets.ObsForeDataset.__init__--parameters" title="Permanent link">&para;</a></h6>
<p>cfgs : dict
    all configs
is_tra_val_te : str
    </p>

        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/data_sets.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cfgs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">is_tra_val_te</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cfgs : dict</span>
<span class="sd">        all configs</span>
<span class="sd">    is_tra_val_te : str</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># </span>
    <span class="nb">super</span><span class="p">(</span><span class="n">ObsForeDataset</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cfgs</span><span class="p">,</span> <span class="n">is_tra_val_te</span><span class="p">)</span>
    <span class="c1"># for each batch, we fix length of hindcast and forecast length.</span>
    <span class="c1"># data from different lead time with a number representing the lead time,</span>
    <span class="c1"># for example, now is 2020-09-30, our min_time_interval is 1 day, hindcast length is 30 and forecast length is 1,</span>
    <span class="c1"># lead_time = 3 means 2020-09-01 to 2020-09-30, and the forecast data is 2020-10-01 from 2020-09-28</span>
    <span class="c1"># for forecast data, we have two different configurations:</span>
    <span class="c1"># 1st, we can set a same lead time for all forecast time</span>
    <span class="c1"># 2020-09-30now, 30hindcast, 2forecast, 3leadtime means 2020-09-01 to 2020-09-30 obs concatenate with 2020-10-01 forecast data from 2020-09-28 and 2020-10-02 forecast data from 2020-09-29</span>
    <span class="c1"># 2nd, we can set a increasing lead time for each forecast time</span>
    <span class="c1"># 2020-09-30now, 30hindcast, 2forecast, [1, 2]leadtime means 2020-09-01 to 2020-09-30 obs concatenate with 2020-10-01 to 2010-10-02 forecast data from 2020-09-30</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">lead_time_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">training_cfgs</span><span class="p">[</span><span class="s2">&quot;lead_time_type&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lead_time_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;fixed&quot;</span><span class="p">,</span> <span class="s2">&quot;increasing&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;lead_time_type must be one of &#39;fixed&#39; or &#39;increasing&#39;, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;but got </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">lead_time_type</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">lead_time_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">training_cfgs</span><span class="p">[</span><span class="s2">&quot;lead_time_start&quot;</span><span class="p">]</span>
    <span class="n">horizon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">horizon</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">horizon</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lead_time_type</span> <span class="o">==</span> <span class="s2">&quot;fixed&quot;</span><span class="p">:</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">lead_time_start</span>
    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">lead_time_type</span> <span class="o">==</span> <span class="s2">&quot;increasing&quot;</span><span class="p">:</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lead_time_start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lead_time_start</span> <span class="o">+</span> <span class="n">horizon</span>
        <span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">horizon_offset</span> <span class="o">=</span> <span class="n">offset</span>
    <span class="n">feature_mapping</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;feature_mapping&quot;</span><span class="p">]</span>
    <span class="c1">#</span>
    <span class="n">xf_var_indices</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">obs_var</span><span class="p">,</span> <span class="n">fore_var</span> <span class="ow">in</span> <span class="n">feature_mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1"># x</span>
        <span class="n">x_var_indice</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">i</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;relevant_cols&quot;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">var</span> <span class="o">==</span> <span class="n">obs_var</span>
        <span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># f</span>
        <span class="n">f_var_indice</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">i</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;forecast_cols&quot;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">var</span> <span class="o">==</span> <span class="n">fore_var</span>
        <span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">xf_var_indices</span><span class="p">[</span><span class="n">x_var_indice</span><span class="p">]</span> <span class="o">=</span> <span class="n">f_var_indice</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">xf_var_indices</span> <span class="o">=</span> <span class="n">xf_var_indices</span>
</code></pre></div>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>







  <div class="doc doc-object doc-function">



<h3 id="torchhydro.datasets.data_sets.detect_date_format" class="doc doc-heading">
<code class="highlight language-python"><span class="n">detect_date_format</span><span class="p">(</span><span class="n">date_str</span><span class="p">)</span></code>


<a href="#torchhydro.datasets.data_sets.detect_date_format" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p></p>
<h5 id="torchhydro.datasets.data_sets.detect_date_format--parameters">Parameters<a class="headerlink" href="#torchhydro.datasets.data_sets.detect_date_format--parameters" title="Permanent link">&para;</a></h5>
<p>date_str : str or list
    </p>
<h5 id="torchhydro.datasets.data_sets.detect_date_format--returns">Returns<a class="headerlink" href="#torchhydro.datasets.data_sets.detect_date_format--returns" title="Permanent link">&para;</a></h5>
<p>str
    </p>

        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/data_sets.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">detect_date_format</span><span class="p">(</span><span class="n">date_str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    date_str : str or list</span>
<span class="sd">        </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    str</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># </span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">date_str</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">date_str</span><span class="p">:</span>  <span class="c1"># </span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Empty date list&quot;</span><span class="p">)</span>
        <span class="n">date_str</span> <span class="o">=</span> <span class="n">date_str</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># </span>

    <span class="c1"># </span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">date_str</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Date must be string or list of strings, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">date_str</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="c1"># </span>
    <span class="k">for</span> <span class="n">date_format</span> <span class="ow">in</span> <span class="n">DATE_FORMATS</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">date_str</span><span class="p">,</span> <span class="n">date_format</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">date_format</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">continue</span>

    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown date format: </span><span class="si">{</span><span class="n">date_str</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="torchhydro.datasets.data_sources" class="doc doc-heading">
        <code>data_sources</code>



<a href="#torchhydro.datasets.data_sources" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Author: Wenyu Ouyang
Date: 2024-04-02 14:37:09
LastEditTime: 2025-11-08 09:58:42
LastEditors: Wenyu Ouyang
Description: A module for different data sources
FilePath:       orchhydro       orchhydro\datasets\data_sources.py
Copyright (c) 2023-2024 Wenyu Ouyang. All rights reserved.</p>



  <div class="doc doc-children">












  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="torchhydro.datasets.data_utils" class="doc doc-heading">
        <code>data_utils</code>



<a href="#torchhydro.datasets.data_utils" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Author: Wenyu Ouyang
Date: 2023-09-21 15:37:58
LastEditTime: 2025-07-13 15:46:09
LastEditors: Wenyu Ouyang
Description: Some basic funtions for dealing with data
FilePath:       orchhydro       orchhydro\datasets\data_utils.py
Copyright (c) 2023-2024 Wenyu Ouyang. All rights reserved.</p>



  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="torchhydro.datasets.data_utils.choose_basins_with_area" class="doc doc-heading">
<code class="highlight language-python"><span class="n">choose_basins_with_area</span><span class="p">(</span><span class="n">gages</span><span class="p">,</span> <span class="n">usgs_ids</span><span class="p">,</span> <span class="n">smallest_area</span><span class="p">,</span> <span class="n">largest_area</span><span class="p">)</span></code>


<a href="#torchhydro.datasets.data_utils.choose_basins_with_area" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>choose basins with not too large or too small area</p>
<h5 id="torchhydro.datasets.data_utils.choose_basins_with_area--parameters">Parameters<a class="headerlink" href="#torchhydro.datasets.data_utils.choose_basins_with_area--parameters" title="Permanent link">&para;</a></h5>
<p>gages
    Camels, CamelsSeries, Gages or GagesPro object
!!! usgs_ids "list"
    given sites' ids
smallest_area
    lower limit; unit is km2
largest_area
    upper limit; unit is km2</p>
<h5 id="torchhydro.datasets.data_utils.choose_basins_with_area--returns">Returns<a class="headerlink" href="#torchhydro.datasets.data_utils.choose_basins_with_area--returns" title="Permanent link">&para;</a></h5>
<p>list
    sites_chosen: [] -- ids of chosen gages</p>

        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/data_utils.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">choose_basins_with_area</span><span class="p">(</span>
    <span class="n">gages</span><span class="p">,</span>
    <span class="n">usgs_ids</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
    <span class="n">smallest_area</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">largest_area</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    choose basins with not too large or too small area</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    gages</span>
<span class="sd">        Camels, CamelsSeries, Gages or GagesPro object</span>
<span class="sd">    usgs_ids: list</span>
<span class="sd">        given sites&#39; ids</span>
<span class="sd">    smallest_area</span>
<span class="sd">        lower limit; unit is km2</span>
<span class="sd">    largest_area</span>
<span class="sd">        upper limit; unit is km2</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        sites_chosen: [] -- ids of chosen gages</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">basins_areas</span> <span class="o">=</span> <span class="n">gages</span><span class="o">.</span><span class="n">read_basin_area</span><span class="p">(</span><span class="n">usgs_ids</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">sites_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">usgs_ids</span><span class="p">))</span>
    <span class="n">sites_chosen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">usgs_ids</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sites_index</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
        <span class="c1"># loop for every site</span>
        <span class="k">if</span> <span class="n">basins_areas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">smallest_area</span> <span class="ow">or</span> <span class="n">basins_areas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">largest_area</span><span class="p">:</span>
            <span class="n">sites_chosen</span><span class="p">[</span><span class="n">sites_index</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sites_chosen</span><span class="p">[</span><span class="n">sites_index</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">usgs_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sites_chosen</span><span class="p">))</span> <span class="k">if</span> <span class="n">sites_chosen</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="torchhydro.datasets.data_utils.choose_sites_in_ecoregion" class="doc doc-heading">
<code class="highlight language-python"><span class="n">choose_sites_in_ecoregion</span><span class="p">(</span><span class="n">gages</span><span class="p">,</span> <span class="n">site_ids</span><span class="p">,</span> <span class="n">ecoregion</span><span class="p">)</span></code>


<a href="#torchhydro.datasets.data_utils.choose_sites_in_ecoregion" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Choose sites in ecoregions</p>
<h5 id="torchhydro.datasets.data_utils.choose_sites_in_ecoregion--parameters">Parameters<a class="headerlink" href="#torchhydro.datasets.data_utils.choose_sites_in_ecoregion--parameters" title="Permanent link">&para;</a></h5>
<p>gages : Gages
    Only gages dataset has ecoregion attribute
site_ids : list
    all ids of sites
ecoregion : Union[list, tuple]
    which ecoregions</p>
<h5 id="torchhydro.datasets.data_utils.choose_sites_in_ecoregion--returns">Returns<a class="headerlink" href="#torchhydro.datasets.data_utils.choose_sites_in_ecoregion--returns" title="Permanent link">&para;</a></h5>
<p>list
    chosen sites' ids</p>
<h5 id="torchhydro.datasets.data_utils.choose_sites_in_ecoregion--raises">Raises<a class="headerlink" href="#torchhydro.datasets.data_utils.choose_sites_in_ecoregion--raises" title="Permanent link">&para;</a></h5>
<p>NotImplementedError
    PLease choose 'ECO2_CODE' or 'ECO3_CODE'
NotImplementedError
    must be in EC02 code list
NotImplementedError
    must be in EC03 code list</p>

        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/data_utils.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">choose_sites_in_ecoregion</span><span class="p">(</span>
    <span class="n">gages</span><span class="p">,</span> <span class="n">site_ids</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">ecoregion</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Choose sites in ecoregions</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    gages : Gages</span>
<span class="sd">        Only gages dataset has ecoregion attribute</span>
<span class="sd">    site_ids : list</span>
<span class="sd">        all ids of sites</span>
<span class="sd">    ecoregion : Union[list, tuple]</span>
<span class="sd">        which ecoregions</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        chosen sites&#39; ids</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    NotImplementedError</span>
<span class="sd">        PLease choose &#39;ECO2_CODE&#39; or &#39;ECO3_CODE&#39;</span>
<span class="sd">    NotImplementedError</span>
<span class="sd">        must be in EC02 code list</span>
<span class="sd">    NotImplementedError</span>
<span class="sd">        must be in EC03 code list</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">ecoregion</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ECO2_CODE&quot;</span><span class="p">,</span> <span class="s2">&quot;ECO3_CODE&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;PLease choose &#39;ECO2_CODE&#39; or &#39;ECO3_CODE&#39;&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ecoregion</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;ECO2_CODE&quot;</span><span class="p">:</span>
        <span class="n">ec02_code_lst</span> <span class="o">=</span> <span class="p">[</span>
            <span class="mf">5.2</span><span class="p">,</span>
            <span class="mf">5.3</span><span class="p">,</span>
            <span class="mf">6.2</span><span class="p">,</span>
            <span class="mf">7.1</span><span class="p">,</span>
            <span class="mf">8.1</span><span class="p">,</span>
            <span class="mf">8.2</span><span class="p">,</span>
            <span class="mf">8.3</span><span class="p">,</span>
            <span class="mf">8.4</span><span class="p">,</span>
            <span class="mf">8.5</span><span class="p">,</span>
            <span class="mf">9.2</span><span class="p">,</span>
            <span class="mf">9.3</span><span class="p">,</span>
            <span class="mf">9.4</span><span class="p">,</span>
            <span class="mf">9.5</span><span class="p">,</span>
            <span class="mf">9.6</span><span class="p">,</span>
            <span class="mf">10.1</span><span class="p">,</span>
            <span class="mf">10.2</span><span class="p">,</span>
            <span class="mf">10.4</span><span class="p">,</span>
            <span class="mf">11.1</span><span class="p">,</span>
            <span class="mf">12.1</span><span class="p">,</span>
            <span class="mf">13.1</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="n">ecoregion</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ec02_code_lst</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;No such EC02 code, please choose from </span><span class="si">{</span><span class="n">ec02_code_lst</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="n">attr_name</span> <span class="o">=</span> <span class="s2">&quot;ECO2_BAS_DOM&quot;</span>
    <span class="k">elif</span> <span class="n">ecoregion</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">85</span><span class="p">):</span>
        <span class="n">attr_name</span> <span class="o">=</span> <span class="s2">&quot;ECO3_BAS_DOM&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;No such EC03 code, please choose from 1 - 85&quot;</span><span class="p">)</span>
    <span class="n">attr_lst</span> <span class="o">=</span> <span class="p">[</span><span class="n">attr_name</span><span class="p">]</span>
    <span class="n">data_attr</span> <span class="o">=</span> <span class="n">gages</span><span class="o">.</span><span class="n">read_constant_cols</span><span class="p">(</span><span class="n">site_ids</span><span class="p">,</span> <span class="n">attr_lst</span><span class="p">)</span>
    <span class="n">eco_names</span> <span class="o">=</span> <span class="n">data_attr</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">site_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">eco_names</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="k">if</span> <span class="n">eco_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">ecoregion</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="torchhydro.datasets.data_utils.dam_num_chosen" class="doc doc-heading">
<code class="highlight language-python"><span class="n">dam_num_chosen</span><span class="p">(</span><span class="n">gages</span><span class="p">,</span> <span class="n">usgs_id</span><span class="p">,</span> <span class="n">dam_num</span><span class="p">)</span></code>


<a href="#torchhydro.datasets.data_utils.dam_num_chosen" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>choose basins of dams</p>

        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/data_utils.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">dam_num_chosen</span><span class="p">(</span><span class="n">gages</span><span class="p">,</span> <span class="n">usgs_id</span><span class="p">,</span> <span class="n">dam_num</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;choose basins of dams&quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">usgs_id</span><span class="p">,</span> <span class="n">usgs_id</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
    <span class="n">attr_lst</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;NDAMS_2009&quot;</span><span class="p">]</span>
    <span class="n">data_attr</span> <span class="o">=</span> <span class="n">gages</span><span class="o">.</span><span class="n">read_constant_cols</span><span class="p">(</span><span class="n">usgs_id</span><span class="p">,</span> <span class="n">attr_lst</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="p">[</span>
            <span class="n">usgs_id</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data_attr</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dam_num</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">data_attr</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">dam_num</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">dam_num</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span>
        <span class="k">else</span> <span class="p">[</span>
            <span class="n">usgs_id</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data_attr</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="k">if</span> <span class="n">data_attr</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">dam_num</span>
        <span class="p">]</span>
    <span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>




  <div class="doc doc-object doc-function">



<h3 id="torchhydro.datasets.data_utils.dor_reservoirs_chosen" class="doc doc-heading">
<code class="highlight language-python"><span class="n">dor_reservoirs_chosen</span><span class="p">(</span><span class="n">gages</span><span class="p">,</span> <span class="n">usgs_id</span><span class="p">,</span> <span class="n">dor_chosen</span><span class="p">)</span></code>


<a href="#torchhydro.datasets.data_utils.dor_reservoirs_chosen" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>choose basins of small DOR(calculated by NOR_STORAGE/RUNAVE7100)</p>

        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/data_utils.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">dor_reservoirs_chosen</span><span class="p">(</span><span class="n">gages</span><span class="p">,</span> <span class="n">usgs_id</span><span class="p">,</span> <span class="n">dor_chosen</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    choose basins of small DOR(calculated by NOR_STORAGE/RUNAVE7100)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dors</span> <span class="o">=</span> <span class="n">get_dor_values</span><span class="p">(</span><span class="n">gages</span><span class="p">,</span> <span class="n">usgs_id</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">dor_chosen</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">]:</span>
        <span class="c1"># right half-open range</span>
        <span class="n">chosen_id</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">usgs_id</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dors</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dor_chosen</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">dors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">dor_chosen</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">]</span>
    <span class="k">elif</span> <span class="n">dor_chosen</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">chosen_id</span> <span class="o">=</span> <span class="p">[</span><span class="n">usgs_id</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dors</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="k">if</span> <span class="n">dors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">dor_chosen</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">chosen_id</span> <span class="o">=</span> <span class="p">[</span><span class="n">usgs_id</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dors</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="k">if</span> <span class="n">dors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">dor_chosen</span><span class="p">]</span>

    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">chosen_id</span><span class="p">,</span> <span class="n">chosen_id</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
    <span class="k">return</span> <span class="n">chosen_id</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="torchhydro.datasets.data_utils.set_unit_to_var" class="doc doc-heading">
<code class="highlight language-python"><span class="n">set_unit_to_var</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span></code>


<a href="#torchhydro.datasets.data_utils.set_unit_to_var" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>returned xa.Dataset need has units for each variable -- xr.DataArray
or the dataset cannot be saved to netCDF file</p>
<h5 id="torchhydro.datasets.data_utils.set_unit_to_var--parameters">Parameters<a class="headerlink" href="#torchhydro.datasets.data_utils.set_unit_to_var--parameters" title="Permanent link">&para;</a></h5>
<p>ds : xr.Dataset
    the dataset with units as attributes</p>
<h5 id="torchhydro.datasets.data_utils.set_unit_to_var--returns">Returns<a class="headerlink" href="#torchhydro.datasets.data_utils.set_unit_to_var--returns" title="Permanent link">&para;</a></h5>
<p>ds : xr.Dataset
    unit attrs are for each variable dataarray</p>

        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/data_utils.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">set_unit_to_var</span><span class="p">(</span><span class="n">ds</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;returned xa.Dataset need has units for each variable -- xr.DataArray</span>
<span class="sd">    or the dataset cannot be saved to netCDF file</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ds : xr.Dataset</span>
<span class="sd">        the dataset with units as attributes</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ds : xr.Dataset</span>
<span class="sd">        unit attrs are for each variable dataarray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">units_dict</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;units&quot;</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">units</span> <span class="ow">in</span> <span class="n">units_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="n">ds</span><span class="p">:</span>
            <span class="n">ds</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;units&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">units</span>
    <span class="k">if</span> <span class="s2">&quot;units&quot;</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
        <span class="k">del</span> <span class="n">ds</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;units&quot;</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">ds</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="torchhydro.datasets.data_utils.unify_streamflow_unit" class="doc doc-heading">
<code class="highlight language-python"><span class="n">unify_streamflow_unit</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">area</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inverse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>


<a href="#torchhydro.datasets.data_utils.unify_streamflow_unit" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Unify the unit of xr_dataset to be mm/day in a basin or inverse</p>
<h5 id="torchhydro.datasets.data_utils.unify_streamflow_unit--parameters">Parameters<a class="headerlink" href="#torchhydro.datasets.data_utils.unify_streamflow_unit--parameters" title="Permanent link">&para;</a></h5>
<p>!!! ds "xarray dataset"
    <em>description</em>
!!! area
    area of each basin</p>
<h5 id="torchhydro.datasets.data_utils.unify_streamflow_unit--returns">Returns<a class="headerlink" href="#torchhydro.datasets.data_utils.unify_streamflow_unit--returns" title="Permanent link">&para;</a></h5>
<p><em>type</em>
    <em>description</em></p>

        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/data_utils.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">unify_streamflow_unit</span><span class="p">(</span><span class="n">ds</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span> <span class="n">area</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Unify the unit of xr_dataset to be mm/day in a basin or inverse</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ds: xarray dataset</span>
<span class="sd">        _description_</span>
<span class="sd">    area:</span>
<span class="sd">        area of each basin</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    _type_</span>
<span class="sd">        _description_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># use pint to convert unit</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">inverse</span><span class="p">:</span>
        <span class="n">target_unit</span> <span class="o">=</span> <span class="s2">&quot;mm/d&quot;</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">pint</span><span class="o">.</span><span class="n">quantify</span><span class="p">()</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">area</span><span class="o">.</span><span class="n">pint</span><span class="o">.</span><span class="n">quantify</span><span class="p">()</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">/</span> <span class="n">a</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">pint</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">target_unit</span><span class="p">)</span><span class="o">.</span><span class="n">to_dataset</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">target_unit</span> <span class="o">=</span> <span class="s2">&quot;m^3/s&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">pint</span><span class="o">.</span><span class="n">quantify</span><span class="p">()</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">area</span><span class="o">.</span><span class="n">pint</span><span class="o">.</span><span class="n">quantify</span><span class="p">()</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="n">a</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="c1"># q = q.pint.quantify()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">pint</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">target_unit</span><span class="p">)</span><span class="o">.</span><span class="n">to_dataset</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">])</span>
    <span class="c1"># dequantify to get normal xr_dataset</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">pint</span><span class="o">.</span><span class="n">dequantify</span><span class="p">()</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="torchhydro.datasets.data_utils.warn_if_nan" class="doc doc-heading">
<code class="highlight language-python"><span class="n">warn_if_nan</span><span class="p">(</span><span class="n">dataarray</span><span class="p">,</span> <span class="n">max_display</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">nan_mode</span><span class="o">=</span><span class="s1">&#39;any&#39;</span><span class="p">,</span> <span class="n">data_name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span></code>


<a href="#torchhydro.datasets.data_utils.warn_if_nan" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Issue a warning if the dataarray contains any NaN values and display their locations.</p>
<h5 id="torchhydro.datasets.data_utils.warn_if_nan--parameters">Parameters<a class="headerlink" href="#torchhydro.datasets.data_utils.warn_if_nan--parameters" title="Permanent link">&para;</a></h5>
<p>!!! dataarray "xr.DataArray"
    Input dataarray to check for NaN values.
!!! max_display "int"
    Maximum number of NaN locations to display in the warning.
!!! nan_mode "str"
    Mode of NaN checking:
    'any' means if any NaNs exist return True, if all values are NaNs raise ValueError
    'all' means if all values are NaNs return True
!!! data_name "str"
    Name of the dataarray to be displayed in the warning message.</p>

        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/data_utils.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">warn_if_nan</span><span class="p">(</span><span class="n">dataarray</span><span class="p">,</span> <span class="n">max_display</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">nan_mode</span><span class="o">=</span><span class="s2">&quot;any&quot;</span><span class="p">,</span> <span class="n">data_name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Issue a warning if the dataarray contains any NaN values and display their locations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    dataarray: xr.DataArray</span>
<span class="sd">        Input dataarray to check for NaN values.</span>
<span class="sd">    max_display: int</span>
<span class="sd">        Maximum number of NaN locations to display in the warning.</span>
<span class="sd">    nan_mode: str</span>
<span class="sd">        Mode of NaN checking:</span>
<span class="sd">        &#39;any&#39; means if any NaNs exist return True, if all values are NaNs raise ValueError</span>
<span class="sd">        &#39;all&#39; means if all values are NaNs return True</span>
<span class="sd">    data_name: str</span>
<span class="sd">        Name of the dataarray to be displayed in the warning message.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">dataarray</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The dataarray is None!&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nan_mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;any&quot;</span><span class="p">,</span> <span class="s2">&quot;all&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nan_mode must be &#39;any&#39; or &#39;all&#39;&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dataarray</span><span class="o">.</span><span class="n">values</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">nan_mode</span> <span class="o">==</span> <span class="s2">&quot;any&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The dataarray contains only NaN values!&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

    <span class="n">nan_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dataarray</span><span class="o">.</span><span class="n">values</span><span class="p">))</span>
    <span class="n">total_nans</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nan_indices</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">total_nans</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="n">message</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;The </span><span class="si">{</span><span class="n">data_name</span><span class="si">}</span><span class="s2"> dataarray contains </span><span class="si">{</span><span class="n">total_nans</span><span class="si">}</span><span class="s2"> NaN values!&quot;</span>

    <span class="c1"># Displaying only the first few NaN locations if there are too many</span>
    <span class="n">display_indices</span> <span class="o">=</span> <span class="n">nan_indices</span><span class="p">[:</span><span class="n">max_display</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">message</span> <span class="o">+=</span> <span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot; Here are the indices of the first </span><span class="si">{</span><span class="n">max_display</span><span class="si">}</span><span class="s2"> NaNs: </span><span class="si">{</span><span class="n">display_indices</span><span class="si">}</span><span class="s2">...&quot;</span>
        <span class="k">if</span> <span class="n">total_nans</span> <span class="o">&gt;</span> <span class="n">max_display</span>
        <span class="k">else</span> <span class="sa">f</span><span class="s2">&quot; Here are the indices of the NaNs: </span><span class="si">{</span><span class="n">display_indices</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="p">)</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

    <span class="k">return</span> <span class="kc">True</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="torchhydro.datasets.data_utils.wrap_t_s_dict" class="doc doc-heading">
<code class="highlight language-python"><span class="n">wrap_t_s_dict</span><span class="p">(</span><span class="n">data_cfgs</span><span class="p">,</span> <span class="n">is_tra_val_te</span><span class="p">)</span></code>


<a href="#torchhydro.datasets.data_utils.wrap_t_s_dict" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Basins and periods</p>
<h5 id="torchhydro.datasets.data_utils.wrap_t_s_dict--parameters">Parameters<a class="headerlink" href="#torchhydro.datasets.data_utils.wrap_t_s_dict--parameters" title="Permanent link">&para;</a></h5>
<p>data_cfgs
    configs for reading from data source
is_tra_val_te
    train, valid or test</p>
<h5 id="torchhydro.datasets.data_utils.wrap_t_s_dict--returns">Returns<a class="headerlink" href="#torchhydro.datasets.data_utils.wrap_t_s_dict--returns" title="Permanent link">&para;</a></h5>
<p>OrderedDict
    OrderedDict(sites_id=basins_id, t_final_range=t_range_list)</p>

        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/data_utils.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">wrap_t_s_dict</span><span class="p">(</span><span class="n">data_cfgs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">is_tra_val_te</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">OrderedDict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Basins and periods</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data_cfgs</span>
<span class="sd">        configs for reading from data source</span>
<span class="sd">    is_tra_val_te</span>
<span class="sd">        train, valid or test</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    OrderedDict</span>
<span class="sd">        OrderedDict(sites_id=basins_id, t_final_range=t_range_list)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">basins_id</span> <span class="o">=</span> <span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;object_ids&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">basins_id</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span> <span class="ow">and</span> <span class="n">basins_id</span> <span class="o">==</span> <span class="s2">&quot;ALL&quot;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Please specify the basins_id in configs!&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">basins_id</span><span class="p">,</span> <span class="n">basins_id</span><span class="p">[</span><span class="mi">1</span><span class="p">:])):</span>
        <span class="c1"># raise a warning if the basins_id is not sorted</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The basins_id is not sorted!&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="sa">f</span><span class="s2">&quot;t_range_</span><span class="si">{</span><span class="n">is_tra_val_te</span><span class="si">}</span><span class="s2">&quot;</span> <span class="ow">in</span> <span class="n">data_cfgs</span><span class="p">:</span>
        <span class="n">t_range_list</span> <span class="o">=</span> <span class="n">data_cfgs</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;t_range_</span><span class="si">{</span><span class="n">is_tra_val_te</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error! The mode </span><span class="si">{</span><span class="n">is_tra_val_te</span><span class="si">}</span><span class="s2"> was not found. Please add it.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">OrderedDict</span><span class="p">(</span><span class="n">sites_id</span><span class="o">=</span><span class="n">basins_id</span><span class="p">,</span> <span class="n">t_final_range</span><span class="o">=</span><span class="n">t_range_list</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="torchhydro.datasets.sampler" class="doc doc-heading">
        <code>sampler</code>



<a href="#torchhydro.datasets.sampler" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Author: Wenyu Ouyang
Date: 2023-09-25 08:21:27
LastEditTime: 2025-07-13 15:47:53
LastEditors: Wenyu Ouyang
Description: Some sampling class or functions
FilePath:       orchhydro       orchhydro\datasets\sampler.py
Copyright (c) 2023-2024 Wenyu Ouyang. All rights reserved.</p>



  <div class="doc doc-children">








  <div class="doc doc-object doc-class">



<h3 id="torchhydro.datasets.sampler.BasinBatchSampler" class="doc doc-heading">
        <code>
BasinBatchSampler            (<span title="torch.utils.data.sampler.Sampler">Sampler</span>)
        </code>



<a href="#torchhydro.datasets.sampler.BasinBatchSampler" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>A custom sampler for hydrological modeling that iterates over a dataset in
a way tailored for batches of hydrological data. It ensures that each batch
contains data from a single randomly selected 'basin' out of several basins,
with batches constructed to respect the specified batch size and the unique
characteristics of hydrological datasets.
TODO: made by Xinzhuo Wu, maybe need to be tested more</p>
<h5 id="torchhydro.datasets.sampler.BasinBatchSampler--parameters">Parameters<a class="headerlink" href="#torchhydro.datasets.sampler.BasinBatchSampler--parameters" title="Permanent link">&para;</a></h5>
<p>dataset : BaseDataset
    The dataset to sample from, expected to have a <code>data_cfgs</code> attribute.
num_samples : Optional[int], default=None
    The total number of samples to draw (optional).
generator : Optional[torch.Generator]
    A PyTorch Generator object for random number generation (optional).</p>
<p>The sampler divides the dataset by the number of basins, then iterates through
each basin's range in shuffled order, ensuring non-overlapping, basin-specific
batches suitable for models that predict hydrological outcomes.</p>

        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/sampler.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">BasinBatchSampler</span><span class="p">(</span><span class="n">Sampler</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A custom sampler for hydrological modeling that iterates over a dataset in</span>
<span class="sd">    a way tailored for batches of hydrological data. It ensures that each batch</span>
<span class="sd">    contains data from a single randomly selected &#39;basin&#39; out of several basins,</span>
<span class="sd">    with batches constructed to respect the specified batch size and the unique</span>
<span class="sd">    characteristics of hydrological datasets.</span>
<span class="sd">    TODO: made by Xinzhuo Wu, maybe need to be tested more</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dataset : BaseDataset</span>
<span class="sd">        The dataset to sample from, expected to have a `data_cfgs` attribute.</span>
<span class="sd">    num_samples : Optional[int], default=None</span>
<span class="sd">        The total number of samples to draw (optional).</span>
<span class="sd">    generator : Optional[torch.Generator]</span>
<span class="sd">        A PyTorch Generator object for random number generation (optional).</span>

<span class="sd">    The sampler divides the dataset by the number of basins, then iterates through</span>
<span class="sd">    each basin&#39;s range in shuffled order, ensuring non-overlapping, basin-specific</span>
<span class="sd">    batches suitable for models that predict hydrological outcomes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dataset</span><span class="p">,</span>
        <span class="n">num_samples</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">generator</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_num_samples</span> <span class="o">=</span> <span class="n">num_samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generator</span> <span class="o">=</span> <span class="n">generator</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;num_samples should be a positive integer value, but got num_samples=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">num_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">training_cfgs</span><span class="p">[</span><span class="s2">&quot;batch_size&quot;</span><span class="p">]</span>
        <span class="n">basin_number</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">data_cfgs</span><span class="p">[</span><span class="s2">&quot;object_ids&quot;</span><span class="p">])</span>
        <span class="n">basin_range</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">)</span> <span class="o">//</span> <span class="n">basin_number</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">basin_range</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;batch_size should equal or less than basin_range=</span><span class="si">{</span><span class="n">basin_range</span><span class="si">}</span><span class="s2"> &quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">generator</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">seed</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">((),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span><span class="o">.</span><span class="n">random_</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>
            <span class="n">generator</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Generator</span><span class="p">()</span>
            <span class="n">generator</span><span class="o">.</span><span class="n">manual_seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">generator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generator</span>

        <span class="c1"># basin_list = torch.randperm(basin_number)</span>
        <span class="c1"># for select_basin in basin_list:</span>
        <span class="c1">#     x = torch.randperm(basin_range)</span>
        <span class="c1">#     for i in range(0, basin_range, n):</span>
        <span class="c1">#         yield from (x[i : i + n] + basin_range * select_basin.item()).tolist()</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randperm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="k">yield from</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">n</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">















  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h3 id="torchhydro.datasets.sampler.KuaiSampler" class="doc doc-heading">
        <code>
KuaiSampler            (<span title="torch.utils.data.sampler.RandomSampler">RandomSampler</span>)
        </code>



<a href="#torchhydro.datasets.sampler.KuaiSampler" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">


        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/sampler.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">KuaiSampler</span><span class="p">(</span><span class="n">RandomSampler</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dataset</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="p">,</span>
        <span class="n">warmup_length</span><span class="p">,</span>
        <span class="n">rho_horizon</span><span class="p">,</span>
        <span class="n">ngrid</span><span class="p">,</span>
        <span class="n">nt</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;a sampler from Kuai Fang&#39;s paper: https://doi.org/10.1002/2017GL075619</span>
<span class="sd">           He used a random pick-up that we don&#39;t need to iterate all samples.</span>
<span class="sd">           Then, we can train model more quickly</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dataset : torch.utils.data.Dataset</span>
<span class="sd">            just a object of dataset class inherited from torch.utils.data.Dataset</span>
<span class="sd">        batch_size : int</span>
<span class="sd">            we need batch_size to calculate the number of samples in an epoch</span>
<span class="sd">        warmup_length : int</span>
<span class="sd">            warmup length, typically for physical hydrological models</span>
<span class="sd">        rho_horizon : int</span>
<span class="sd">            sequence length of a mini-batch, for encoder-decoder models, rho+horizon, for decoder-only models, horizon</span>
<span class="sd">        ngrid : int</span>
<span class="sd">            number of basins</span>
<span class="sd">        nt : int</span>
<span class="sd">            number of all periods</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">while</span> <span class="n">batch_size</span> <span class="o">*</span> <span class="n">rho_horizon</span> <span class="o">&gt;=</span> <span class="n">ngrid</span> <span class="o">*</span> <span class="n">nt</span><span class="p">:</span>
            <span class="c1"># try to use a smaller batch_size to make the model runnable</span>
            <span class="n">batch_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">batch_size</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span>
        <span class="n">batch_size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># 99% chance that all periods&#39; data are used in an epoch</span>
        <span class="n">n_iter_ep</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>
                <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">batch_size</span> <span class="o">*</span> <span class="n">rho_horizon</span> <span class="o">/</span> <span class="n">ngrid</span> <span class="o">/</span> <span class="p">(</span><span class="n">nt</span> <span class="o">-</span> <span class="n">warmup_length</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="n">n_iter_ep</span> <span class="o">&gt;=</span> <span class="mi">1</span>
        <span class="c1"># __len__ means the number of all samples, then, the number of loops in an epoch is __len__()/batch_size = n_iter_ep</span>
        <span class="c1"># hence we return n_iter_ep * batch_size</span>
        <span class="n">num_samples</span> <span class="o">=</span> <span class="n">n_iter_ep</span> <span class="o">*</span> <span class="n">batch_size</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">KuaiSampler</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="n">num_samples</span><span class="p">)</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">









  <div class="doc doc-object doc-method">



<h4 id="torchhydro.datasets.sampler.KuaiSampler.__init__" class="doc doc-heading">
<code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">warmup_length</span><span class="p">,</span> <span class="n">rho_horizon</span><span class="p">,</span> <span class="n">ngrid</span><span class="p">,</span> <span class="n">nt</span><span class="p">)</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#torchhydro.datasets.sampler.KuaiSampler.__init__" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">

      <p>a sampler from Kuai Fang's paper: https://doi.org/10.1002/2017GL075619
   He used a random pick-up that we don't need to iterate all samples.
   Then, we can train model more quickly</p>
<h6 id="torchhydro.datasets.sampler.KuaiSampler.__init__--parameters">Parameters<a class="headerlink" href="#torchhydro.datasets.sampler.KuaiSampler.__init__--parameters" title="Permanent link">&para;</a></h6>
<p>dataset : torch.utils.data.Dataset
    just a object of dataset class inherited from torch.utils.data.Dataset
batch_size : int
    we need batch_size to calculate the number of samples in an epoch
warmup_length : int
    warmup length, typically for physical hydrological models
rho_horizon : int
    sequence length of a mini-batch, for encoder-decoder models, rho+horizon, for decoder-only models, horizon
ngrid : int
    number of basins
nt : int
    number of all periods</p>

        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/sampler.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">dataset</span><span class="p">,</span>
    <span class="n">batch_size</span><span class="p">,</span>
    <span class="n">warmup_length</span><span class="p">,</span>
    <span class="n">rho_horizon</span><span class="p">,</span>
    <span class="n">ngrid</span><span class="p">,</span>
    <span class="n">nt</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;a sampler from Kuai Fang&#39;s paper: https://doi.org/10.1002/2017GL075619</span>
<span class="sd">       He used a random pick-up that we don&#39;t need to iterate all samples.</span>
<span class="sd">       Then, we can train model more quickly</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dataset : torch.utils.data.Dataset</span>
<span class="sd">        just a object of dataset class inherited from torch.utils.data.Dataset</span>
<span class="sd">    batch_size : int</span>
<span class="sd">        we need batch_size to calculate the number of samples in an epoch</span>
<span class="sd">    warmup_length : int</span>
<span class="sd">        warmup length, typically for physical hydrological models</span>
<span class="sd">    rho_horizon : int</span>
<span class="sd">        sequence length of a mini-batch, for encoder-decoder models, rho+horizon, for decoder-only models, horizon</span>
<span class="sd">    ngrid : int</span>
<span class="sd">        number of basins</span>
<span class="sd">    nt : int</span>
<span class="sd">        number of all periods</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">while</span> <span class="n">batch_size</span> <span class="o">*</span> <span class="n">rho_horizon</span> <span class="o">&gt;=</span> <span class="n">ngrid</span> <span class="o">*</span> <span class="n">nt</span><span class="p">:</span>
        <span class="c1"># try to use a smaller batch_size to make the model runnable</span>
        <span class="n">batch_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">batch_size</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span>
    <span class="n">batch_size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1"># 99% chance that all periods&#39; data are used in an epoch</span>
    <span class="n">n_iter_ep</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>
            <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">batch_size</span> <span class="o">*</span> <span class="n">rho_horizon</span> <span class="o">/</span> <span class="n">ngrid</span> <span class="o">/</span> <span class="p">(</span><span class="n">nt</span> <span class="o">-</span> <span class="n">warmup_length</span><span class="p">))</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="k">assert</span> <span class="n">n_iter_ep</span> <span class="o">&gt;=</span> <span class="mi">1</span>
    <span class="c1"># __len__ means the number of all samples, then, the number of loops in an epoch is __len__()/batch_size = n_iter_ep</span>
    <span class="c1"># hence we return n_iter_ep * batch_size</span>
    <span class="n">num_samples</span> <span class="o">=</span> <span class="n">n_iter_ep</span> <span class="o">*</span> <span class="n">batch_size</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">KuaiSampler</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="n">num_samples</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>





  <div class="doc doc-object doc-function">



<h3 id="torchhydro.datasets.sampler.fl_sample_basin" class="doc doc-heading">
<code class="highlight language-python"><span class="n">fl_sample_basin</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span></code>


<a href="#torchhydro.datasets.sampler.fl_sample_basin" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Sample one basin data as a client from a dataset for federated learning</p>
<h5 id="torchhydro.datasets.sampler.fl_sample_basin--parameters">Parameters<a class="headerlink" href="#torchhydro.datasets.sampler.fl_sample_basin--parameters" title="Permanent link">&para;</a></h5>
<p>dataset
    dataset</p>
<h5 id="torchhydro.datasets.sampler.fl_sample_basin--returns">Returns<a class="headerlink" href="#torchhydro.datasets.sampler.fl_sample_basin--returns" title="Permanent link">&para;</a></h5>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span></pre></div></td><td class="code"><div><pre><span></span><code>dict of image index
</code></pre></div></td></tr></table></div>

        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/sampler.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">fl_sample_basin</span><span class="p">(</span><span class="n">dataset</span><span class="p">:</span> <span class="n">BaseDataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sample one basin data as a client from a dataset for federated learning</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dataset</span>
<span class="sd">        dataset</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        dict of image index</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lookup_table</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">lookup_table</span>
    <span class="n">basins</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">basins</span>
    <span class="c1"># one basin is one user</span>
    <span class="n">num_users</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">basins</span><span class="p">)</span>
    <span class="c1"># set group for basins</span>
    <span class="n">basin_groups</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">basin</span><span class="p">,</span> <span class="n">date</span><span class="p">)</span> <span class="ow">in</span> <span class="n">lookup_table</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">basin_groups</span><span class="p">[</span><span class="n">basin</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

    <span class="c1"># one user is one basin</span>
    <span class="n">user_basins</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">basin</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">basins</span><span class="p">):</span>
        <span class="n">user_id</span> <span class="o">=</span> <span class="n">i</span> <span class="o">%</span> <span class="n">num_users</span>
        <span class="n">user_basins</span><span class="p">[</span><span class="n">user_id</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">basin</span><span class="p">)</span>

    <span class="c1"># a lookup_table subset for each user</span>
    <span class="n">user_lookup_tables</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">user_id</span><span class="p">,</span> <span class="n">basins</span> <span class="ow">in</span> <span class="n">user_basins</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">user_lookup_table</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">basin</span> <span class="ow">in</span> <span class="n">basins</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">basin_groups</span><span class="p">[</span><span class="n">basin</span><span class="p">]:</span>
                <span class="n">user_lookup_table</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">lookup_table</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">user_lookup_tables</span><span class="p">[</span><span class="n">user_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">user_lookup_table</span>

    <span class="k">return</span> <span class="n">user_lookup_tables</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="torchhydro.datasets.sampler.fl_sample_region" class="doc doc-heading">
<code class="highlight language-python"><span class="n">fl_sample_region</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span></code>


<a href="#torchhydro.datasets.sampler.fl_sample_region" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Sample one region data as a client from a dataset for federated learning</p>
<p>TODO: not finished</p>

        <details class="quote">
          <summary>Source code in <code>torchhydro/datasets/sampler.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">fl_sample_region</span><span class="p">(</span><span class="n">dataset</span><span class="p">:</span> <span class="n">BaseDataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sample one region data as a client from a dataset for federated learning</span>

<span class="sd">    TODO: not finished</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">num_users</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">num_shards</span><span class="p">,</span> <span class="n">num_imgs</span> <span class="o">=</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">250</span>
    <span class="n">idx_shard</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num_shards</span><span class="p">))</span>
    <span class="n">dict_users</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_users</span><span class="p">)}</span>
    <span class="n">idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_shards</span> <span class="o">*</span> <span class="n">num_imgs</span><span class="p">)</span>
    <span class="c1"># labels = dataset.train_labels.numpy()</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">train_labels</span><span class="p">)</span>

    <span class="c1"># sort labels</span>
    <span class="n">idxs_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">idxs</span><span class="p">,</span> <span class="n">labels</span><span class="p">))</span>
    <span class="n">idxs_labels</span> <span class="o">=</span> <span class="n">idxs_labels</span><span class="p">[:,</span> <span class="n">idxs_labels</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">argsort</span><span class="p">()]</span>
    <span class="n">idxs</span> <span class="o">=</span> <span class="n">idxs_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>

    <span class="c1"># divide and assign</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_users</span><span class="p">):</span>
        <span class="n">rand_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">idx_shard</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
        <span class="n">idx_shard</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">idx_shard</span><span class="p">)</span> <span class="o">-</span> <span class="n">rand_set</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">rand</span> <span class="ow">in</span> <span class="n">rand_set</span><span class="p">:</span>
            <span class="n">dict_users</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">(</span><span class="n">dict_users</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">idxs</span><span class="p">[</span><span class="n">rand</span> <span class="o">*</span> <span class="n">num_imgs</span> <span class="p">:</span> <span class="p">(</span><span class="n">rand</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_imgs</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
            <span class="p">)</span>
    <span class="k">return</span> <span class="n">dict_users</span>
</code></pre></div>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>




  </div>

    </div>

  </div>







  
    
  
  


  <aside class="md-source-file">
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="Last update">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M21 13.1c-.1 0-.3.1-.4.2l-1 1 2.1 2.1 1-1c.2-.2.2-.6 0-.8l-1.3-1.3c-.1-.1-.2-.2-.4-.2m-1.9 1.8-6.1 6V23h2.1l6.1-6.1zM12.5 7v5.2l4 2.4-1 1L11 13V7zM11 21.9c-5.1-.5-9-4.8-9-9.9C2 6.5 6.5 2 12 2c5.3 0 9.6 4.1 10 9.3-.3-.1-.6-.2-1-.2s-.7.1-1 .2C19.6 7.2 16.2 4 12 4c-4.4 0-8 3.6-8 8 0 4.1 3.1 7.5 7.1 7.9l-.1.2z"/></svg>
    </span>
    2025-11-08
  </span>

    
    
    
    
  </aside>





                

              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "../..", "features": ["navigation.instant", "search.highlight"], "search": "../../assets/javascripts/workers/search.973d3a69.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../../assets/javascripts/bundle.92b07e13.min.js"></script>
      
    
  </body>
</html>